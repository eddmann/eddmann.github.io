<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Explore multiple efficient methods to solve anagrams using Clojure, including Hash-Map, Trie, and Prime Number approaches.">

    <title>
        
            Anagram Solver in Clojure &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Anagram Solver in Clojure</h1>
    <time datetime="2016-08-15T00:00:00+00:00" class="post-date">15 Aug 2016</time>
    <p>This past week, a discussion around solving anagrams was brought up.
I thought it would be interesting to devise a couple of methods for computationally achieving such a task.
Providing an anagram string and a dictionary file, I wished to return all possible matching words from the dictionary.</p>



<p>I decided this experimental exercise was a great opportunity to use Clojure.
Whilst thinking of ways to tackle this problem, I initially knew of two different means of storing an effective dictionary for anagram lookup.
I was able to generalise into a higher-order function the process of taking each word within the supplied dictionary file and adding it into the initial <code class="language-plaintext highlighter-rouge">dictionary</code> data structure using the <code class="language-plaintext highlighter-rouge">add-word</code> function.
To avoid generation performance penalties each time this function was invoked, I decided to memoize the function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">reader-&gt;words</span><span class="w"> </span><span class="p">[</span><span class="n">rdr</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">single-word?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">nil?</span><span class="w"> </span><span class="p">(</span><span class="nb">re-find</span><span class="w"> </span><span class="o">#</span><span class="s">"[^a-z]"</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w">
        </span><span class="n">max-five-letters?</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="mi">6</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">line-seq</span><span class="w"> </span><span class="n">rdr</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">clojure.string/lower-case</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="n">single-word?</span><span class="w"> </span><span class="n">max-five-letters?</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">generate-dictionary</span><span class="w">
  </span><span class="p">(</span><span class="nf">memoize</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">dictionary</span><span class="w"> </span><span class="n">add-word</span><span class="w"> </span><span class="n">filename</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="nb">with-open</span><span class="w"> </span><span class="p">[</span><span class="n">rdr</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.java.io/reader</span><span class="w"> </span><span class="n">filename</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="n">add-word</span><span class="w"> </span><span class="n">dictionary</span><span class="w"> </span><span class="p">(</span><span class="nf">reader-&gt;words</span><span class="w"> </span><span class="n">rdr</span><span class="p">))))))</span><span class="w">
</span></code></pre></div></div>

<p>You will notice that I added some constraints upon the words we wished to include from the supplied dictionary.
This was to simplify the large English dictionary provided with Unix platforms such as Mac OS <code class="language-plaintext highlighter-rouge">/usr/share/dict/words</code>.</p>

<h2 id="hash-map">Hash-Map</h2>

<p>The first solution used a simple hash-map, devising the key based on the alphabetical sorting of the supplied word.
This meant that each matching anagram would generate the same unique key and then be stored within the hash-mapâ€™s Set value.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">word-&gt;key</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="p">(</span><span class="nb">sort</span><span class="w"> </span><span class="n">word</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">add-to-map</span><span class="w"> </span><span class="p">[</span><span class="n">hmap</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nf">word-&gt;key</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w">
        </span><span class="n">words</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">hmap</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="o">#</span><span class="p">{})]</span><span class="w">
    </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="n">hmap</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">words</span><span class="w"> </span><span class="n">word</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">map-anagrams</span><span class="w"> </span><span class="p">[</span><span class="n">filename</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">generate-dictionary</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">add-to-map</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">word-&gt;key</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<h2 id="trie">Trie</h2>

<p>The above solution provided a simple design, along with quick lookup times.
However, I felt that a better-suited data structure could help ease memory requirements.
Using a <a href="https://en.wikipedia.org/wiki/Trie">Trie</a> data structure allowed us to more effectively store the computed keys for the lookup dictionary.
Clojure provides an efficient way to interact with nested associated data structures using the familiar hash-map.
Instead of the key being converted back into a sorted string, it was maintained as a vector and used as a sequence of keys, forming the path to the matching anagram words.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">word-&gt;key</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="p">(</span><span class="nf">vec</span><span class="w"> </span><span class="p">(</span><span class="nb">sort</span><span class="w"> </span><span class="n">word</span><span class="p">))</span><span class="w"> </span><span class="no">:words</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">add-to-trie</span><span class="w"> </span><span class="p">[</span><span class="n">trie</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nf">word-&gt;key</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w">
        </span><span class="n">words</span><span class="w"> </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="n">trie</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="o">#</span><span class="p">{})]</span><span class="w">
    </span><span class="p">(</span><span class="nf">assoc-in</span><span class="w"> </span><span class="n">trie</span><span class="w"> </span><span class="nb">key</span><span class="w"> </span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">words</span><span class="w"> </span><span class="n">word</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">trie-anagrams</span><span class="w"> </span><span class="p">[</span><span class="n">filename</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">get-in</span><span class="w"> </span><span class="p">(</span><span class="nf">generate-dictionary</span><span class="w"> </span><span class="p">{}</span><span class="w"> </span><span class="n">add-to-trie</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">word-&gt;key</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<h2 id="hash-map-using-prime-numbers">Hash-Map using Prime Numbers</h2>

<p>After some <a href="http://stackoverflow.com/a/28948975">internet research</a>, I noticed a different way to generate unique word keys regardless of character ordering.
Taking advantage of the fact that prime numbers are â€˜multiplicatively uniqueâ€™, I created a character-to-prime number lookup function.
The product of each characterâ€™s corresponding prime number resulted in a unique integer value being generated.
I was then able to use a more efficient <code class="language-plaintext highlighter-rouge">int-map</code> dictionary data structure, providing better lookup and storage costs than the initial implementation.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sieve</span><span class="w"> </span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">cons</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">s</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">lazy-seq</span><span class="w"> </span><span class="p">(</span><span class="nf">sieve</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">not=</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="p">(</span><span class="nf">mod</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">s</span><span class="p">)))</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">s</span><span class="p">))))))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">alpha-&gt;prime</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">hash-map</span><span class="w">
    </span><span class="p">(</span><span class="nb">interleave</span><span class="w"> </span><span class="s">"abcdefghijklmnopqrstuvwxyz"</span><span class="w"> </span><span class="p">(</span><span class="nf">sieve</span><span class="w"> </span><span class="p">(</span><span class="nb">iterate</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="mi">2</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">word-&gt;key</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="p">(</span><span class="nf">alpha-&gt;prime</span><span class="w"> </span><span class="n">%2</span><span class="p">))</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="n">word</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">prime-map-anagrams</span><span class="w"> </span><span class="p">[</span><span class="n">filename</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">generate-dictionary</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.data.int-map/int-map</span><span class="p">)</span><span class="w"> </span><span class="n">add-to-map</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nf">word-&gt;key</span><span class="w"> </span><span class="n">word</span><span class="p">)</span><span class="w">
       </span><span class="o">#</span><span class="p">{}))</span><span class="w">
</span></code></pre></div></div>

<h2 id="sub-string-anagrams">Sub-string Anagrams</h2>

<p>Finally, I wished to extend the initial problem and provide the ability to include sub-string anagrams in the result.
I achieved this by creating a small function that took a word and created its power set (set of all possible subsets).
With this implementation, I was then able to create a higher-order function that took the desired finder implementation and fetched both full and sub-string anagrams from the lookup dictionary.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">power-set</span><span class="w"> </span><span class="p">[</span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">add-char-seqs</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">clojure.set/union</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="n">%2</span><span class="p">)</span><span class="w"> </span><span class="n">%1</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">reduce</span><span class="w"> </span><span class="n">add-char-seqs</span><span class="w"> </span><span class="o">#</span><span class="p">{</span><span class="s">""</span><span class="p">}</span><span class="w"> </span><span class="n">word</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">sub-anagrams</span><span class="w"> </span><span class="p">[</span><span class="n">finder</span><span class="w"> </span><span class="n">filename</span><span class="w"> </span><span class="n">word</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="n">clojure.set/union</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">finder</span><span class="w"> </span><span class="n">filename</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">power-set</span><span class="w"> </span><span class="n">word</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
