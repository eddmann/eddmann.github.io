<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Depth-First Search and Breadth-First Search in Python - Edd Mann</title>
<meta name=description content="An in-depth guide to implementing Depth-First Search and Breadth-First Search in Python, exploring graph theory, connected components and pathfinding algorithms."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Depth-First Search and Breadth-First Search in Python"><meta itemprop=description content="Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics. Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains. One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph."><meta itemprop=datePublished content="2014-03-05T00:00:00+00:00"><meta itemprop=dateModified content="2014-03-05T00:00:00+00:00"><meta itemprop=wordCount content="1146"><meta itemprop=keywords content="Python,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Depth-First Search and Breadth-First Search in Python"><meta property="og:description" content="Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics. Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains. One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-03-05T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-05T00:00:00+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Depth-First Search and Breadth-First Search in Python"><meta name=twitter:description content="Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics. Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains. One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.29e5081eb89985e1a0a80efa54bbaeb1c3b876bd282e34b5167c32a23e0ffe38.css integrity="sha256-KeUIHriZheGgqA76VLuuscO4dr0oLjS1Fnwyoj4P/jg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1 class=transition-between-pages style=--id:depth-first-search-and-breadth-first-search-in-python>Depth-First Search and Breadth-First Search in Python</h1><time class=post__time>Mar 5, 2014</time></header><main class=prose><p>Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics.
Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains.
One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph.</p><p>Properties such as edge weighting and direction are two factors that the algorithm designer can take into consideration.
In this post I will be exploring two of the simpler available algorithms, depth-first and breadth-first search, to achieve the goals highlighted below:</p><ul><li>Find all vertices in a subject vertex&rsquo;s <a href=http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29 rel="external noopener" target=_blank>connected component</a>.</li><li>Return all available paths between two vertices.</li><li>And, in the case of BFS, return the shortest path (with length measured by the number of path edges).</li></ul><h2 id=the-graph>The Graph</h2><p>So as to clearly discuss each algorithm, I have crafted a <a href=http://mathworld.wolfram.com/ConnectedGraph.html rel="external noopener" target=_blank>connected graph</a> with six vertices and six incident edges.
The resulting graph is undirected with no assigned edge weightings, as length will be evaluated based on the number of path edges traversed.
There are two popular options for representing a graph: the first is an <a href=http://en.wikipedia.org/wiki/Adjacency_matrix rel="external noopener" target=_blank>adjacency matrix</a> (effective with dense graphs) and the second is an <a href=http://en.wikipedia.org/wiki/Adjacency_list rel="external noopener" target=_blank>adjacency list</a> (effective with sparse graphs).
I have opted to implement an adjacency list which stores each node in a dictionary along with a set containing its adjacent nodes.
As the graph is undirected, each edge is stored in both incident nodes&rsquo; adjacent sets.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>graph <span style=color:#f92672>=</span> {<span style=color:#e6db74>&#39;A&#39;</span>: set([<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;C&#39;</span>]),
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#39;B&#39;</span>: set([<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;D&#39;</span>, <span style=color:#e6db74>&#39;E&#39;</span>]),
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#39;C&#39;</span>: set([<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>]),
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#39;D&#39;</span>: set([<span style=color:#e6db74>&#39;B&#39;</span>]),
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#39;E&#39;</span>: set([<span style=color:#e6db74>&#39;B&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>]),
</span></span><span style=display:flex><span>         <span style=color:#e6db74>&#39;F&#39;</span>: set([<span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;E&#39;</span>])}
</span></span></code></pre></div><p>Looking at the graph depiction below, you will also notice the inclusion of a cycle, by the adjacent connections between &lsquo;F&rsquo; and &lsquo;C/E&rsquo;.
This has been purposely included to provide the algorithms with the option to return multiple paths between two desired nodes.</p><p><picture><source type=image/webp srcset=", /posts/depth-first-search-and-breadth-first-search-in-python/graph_hu_3f800b675de9fa8a.webp 267w"><source type=image/jpeg srcset=", /posts/depth-first-search-and-breadth-first-search-in-python/graph_hu_796c74da4ab4b50.jpg 267w"><img src=/posts/depth-first-search-and-breadth-first-search-in-python/graph_hu_796c74da4ab4b50.jpg alt=Graph loading=lazy></picture></p><h2 id=depth-first-search>Depth-First Search</h2><p>The first algorithm I will be discussing is depth-first search, which, as the name hints, explores possible vertices (from a supplied root) down each branch before backtracking.
This property allows the algorithm to be implemented succinctly in both iterative and recursive forms.
Below is a listing of the actions performed upon each visit to a node:</p><ul><li>Mark the current vertex as visited.</li><li>Explore each adjacent vertex that is not included in the visited set.</li></ul><h3 id=connected-component>Connected Component</h3><p>The implementation below uses the stack data structure to build up and return a set of vertices that are accessible within the subject&rsquo;s connected component.
Using Python&rsquo;s overloading of the subtraction operator to remove items from a set, we are able to add only the unvisited adjacent vertices.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(graph, start):
</span></span><span style=display:flex><span>    visited, stack <span style=color:#f92672>=</span> set(), [start]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stack:
</span></span><span style=display:flex><span>        vertex <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> vertex <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>            visited<span style=color:#f92672>.</span>add(vertex)
</span></span><span style=display:flex><span>            stack<span style=color:#f92672>.</span>extend(graph[vertex] <span style=color:#f92672>-</span> visited)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> visited
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfs(graph, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#75715e># {&#39;E&#39;, &#39;D&#39;, &#39;F&#39;, &#39;A&#39;, &#39;C&#39;, &#39;B&#39;}</span>
</span></span></code></pre></div><p>The second implementation provides the same functionality as the first; however, this time we are using the more succinct recursive form.
Due to a common Python gotcha with <a href=http://developmentality.wordpress.com/2010/08/23/python-gotcha-default-arguments/ rel="external noopener" target=_blank>default parameter values</a> being created only once, we are required to create a new visited set on each user invocation.
Another Python language detail is that function variables are passed by reference, resulting in the visited mutable set not having to be reassigned upon each recursive call.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs</span>(graph, start, visited<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> visited <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        visited <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    visited<span style=color:#f92672>.</span>add(start)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> next <span style=color:#f92672>in</span> graph[start] <span style=color:#f92672>-</span> visited:
</span></span><span style=display:flex><span>        dfs(graph, next, visited)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> visited
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>dfs(graph, <span style=color:#e6db74>&#39;C&#39;</span>) <span style=color:#75715e># {&#39;E&#39;, &#39;D&#39;, &#39;F&#39;, &#39;A&#39;, &#39;C&#39;, &#39;B&#39;}</span>
</span></span></code></pre></div><h3 id=paths>Paths</h3><p>We are able to tweak both of the previous implementations to return all possible paths between a start and goal vertex.
The implementation below uses the stack data structure again to iteratively solve the problem, yielding each possible path when we locate the goal.
Using a <a href=https://wiki.python.org/moin/Generators rel="external noopener" target=_blank>generator</a> allows the user to compute only the desired number of alternative paths.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs_paths</span>(graph, start, goal):
</span></span><span style=display:flex><span>    stack <span style=color:#f92672>=</span> [(start, [start])]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> stack:
</span></span><span style=display:flex><span>        (vertex, path) <span style=color:#f92672>=</span> stack<span style=color:#f92672>.</span>pop()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> next <span style=color:#f92672>in</span> graph[vertex] <span style=color:#f92672>-</span> set(path):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> next <span style=color:#f92672>==</span> goal:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> path <span style=color:#f92672>+</span> [next]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                stack<span style=color:#f92672>.</span>append((next, path <span style=color:#f92672>+</span> [next]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>list(dfs_paths(graph, <span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>)) <span style=color:#75715e># [[&#39;A&#39;, &#39;C&#39;, &#39;F&#39;], [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;]]</span>
</span></span></code></pre></div><p>The implementation below uses the recursive approach, calling the &lsquo;yield from&rsquo; <a href=http://legacy.python.org/dev/peps/pep-0380/ rel="external noopener" target=_blank>PEP 380</a> addition to return the located paths.
Unfortunately, the version of <a href=http://pygments.org/ rel="external noopener" target=_blank>Pygments</a> installed on the server at this time does not include the updated keyword combination.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>dfs_paths</span>(graph, start, goal, path<span style=color:#f92672>=</span><span style=color:#66d9ef>None</span>):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> path <span style=color:#f92672>is</span> <span style=color:#66d9ef>None</span>:
</span></span><span style=display:flex><span>        path <span style=color:#f92672>=</span> [start]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> start <span style=color:#f92672>==</span> goal:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield</span> path
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> next <span style=color:#f92672>in</span> graph[start] <span style=color:#f92672>-</span> set(path):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>yield from</span> dfs_paths(graph, next, goal, path <span style=color:#f92672>+</span> [next])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>list(dfs_paths(graph, <span style=color:#e6db74>&#39;C&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>)) <span style=color:#75715e># [[&#39;C&#39;, &#39;F&#39;], [&#39;C&#39;, &#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;]]</span>
</span></span></code></pre></div><h2 id=breadth-first-search>Breadth-First Search</h2><p>An alternative algorithm called breadth-first search provides us with the ability to return the same results as DFS, but with the added guarantee of returning the shortest path first.
This algorithm is a little more tricky to implement in a recursive manner; instead, using the queue data structure is preferable, as such I will only be documenting the iterative approach.
The actions performed per each explored vertex are the same as the depth-first implementation, however, replacing the stack with a queue will instead explore the breadth of a vertex&rsquo;s depth before moving on.
This behaviour guarantees that the first path located is one of the shortest paths present, based on the number of edges being the cost factor.</p><h3 id=connected-component-1>Connected Component</h3><p>Similar to the iterative DFS implementation, the only alteration required is to remove the next item from the beginning of the list structure instead of the stack&rsquo;s last item.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bfs</span>(graph, start):
</span></span><span style=display:flex><span>    visited, queue <span style=color:#f92672>=</span> set(), [start]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        vertex <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> vertex <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> visited:
</span></span><span style=display:flex><span>            visited<span style=color:#f92672>.</span>add(vertex)
</span></span><span style=display:flex><span>            queue<span style=color:#f92672>.</span>extend(graph[vertex] <span style=color:#f92672>-</span> visited)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> visited
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bfs(graph, <span style=color:#e6db74>&#39;A&#39;</span>) <span style=color:#75715e># {&#39;B&#39;, &#39;C&#39;, &#39;A&#39;, &#39;F&#39;, &#39;D&#39;, &#39;E&#39;}</span>
</span></span></code></pre></div><h3 id=paths-1>Paths</h3><p>This implementation can again be altered slightly to instead return all possible paths between two vertices, the first of which is one of the shortest such paths.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>bfs_paths</span>(graph, start, goal):
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> [(start, [start])]
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        (vertex, path) <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>pop(<span style=color:#ae81ff>0</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> next <span style=color:#f92672>in</span> graph[vertex] <span style=color:#f92672>-</span> set(path):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> next <span style=color:#f92672>==</span> goal:
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> path <span style=color:#f92672>+</span> [next]
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span>:
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append((next, path <span style=color:#f92672>+</span> [next]))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>list(bfs_paths(graph, <span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>)) <span style=color:#75715e># [[&#39;A&#39;, &#39;C&#39;, &#39;F&#39;], [&#39;A&#39;, &#39;B&#39;, &#39;E&#39;, &#39;F&#39;]]</span>
</span></span></code></pre></div><p>Knowing that the shortest path will be returned first from the BFS path generator method, we can create a useful method which simply returns the shortest path found, or &lsquo;None&rsquo; if no path exists.
As we are using a generator, this in theory should provide similar performance results to just breaking out and returning the first matching path in the BFS implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>shortest_path</span>(graph, start, goal):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>try</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> next(bfs_paths(graph, start, goal))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>except</span> <span style=color:#a6e22e>StopIteration</span>:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>None</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>shortest_path(graph, <span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;F&#39;</span>) <span style=color:#75715e># [&#39;A&#39;, &#39;C&#39;, &#39;F&#39;]</span>
</span></span></code></pre></div><h2 id=resources>Resources</h2><ul><li><a href=http://jeremykun.com/2013/01/22/depth-and-breadth-first-search/ rel="external noopener" target=_blank>Depth-and Breadth-First Search</a></li><li><a href=http://en.wikipedia.org/wiki/Connected_component_%28graph_theory%29 rel="external noopener" target=_blank>Connected component</a></li><li><a href=http://en.wikipedia.org/wiki/Adjacency_matrix rel="external noopener" target=_blank>Adjacency matrix</a></li><li><a href=http://en.wikipedia.org/wiki/Adjacency_list rel="external noopener" target=_blank>Adjacency list</a></li><li><a href=http://developmentality.wordpress.com/2010/08/23/python-gotcha-default-arguments/ rel="external noopener" target=_blank>Python Gotcha: Default arguments and mutable data structures</a></li><li><a href=http://legacy.python.org/dev/peps/pep-0380/ rel="external noopener" target=_blank>PEP 380</a></li><li><a href=https://wiki.python.org/moin/Generators rel="external noopener" target=_blank>Generators</a></li></ul></main><footer class=post__tags><a href=/archive/tag/python>python</a><a href=/archive/tag/algorithms>algorithms</a></footer></article><div class="related-posts prose"><h3>Related Posts</h3><ul><li><a href=/posts/creating-a-basic-auth-wsgi-middleware-in-python/>Creating a Basic Auth. WSGI Middleware in Python</a></li><li><a href=/posts/processing-a-list-of-links-using-python-and-beautifulsoup/>Processing a List of Links using Python and BeautifulSoup</a></li><li><a href=/posts/understanding-python-wsgi-with-examples/>Understanding Python WSGI with Examples</a></li><li><a href=/posts/implementing-basic-python-decorators-in-php/>Implementing Basic Python Decorators in PHP</a></li><li><a href=/posts/using-basic-auth-and-decorators-in-pythons-flask/>Using Basic Auth. and Decorators in Python's Flask</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div><button class=theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer><script>(function(){document.querySelector(".theme-toggle").addEventListener("click",()=>{localStorage.setItem("theme",localStorage.getItem("theme")==="dark"?"light":"dark"),document.documentElement.setAttribute("data-theme",localStorage.getItem("theme"))}),document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;setTimeout(()=>{const s=window.pageYOffset;n.classList.toggle("is-sticky",s>0&&t>s),t=s,e=!1},500),e=!0})})()</script></body></html>