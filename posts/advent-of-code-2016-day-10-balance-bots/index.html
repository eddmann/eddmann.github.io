<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2016 - Day 10 - Balance Bots - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2016 Day 10 puzzle using Python."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2016 - Day 10 - Balance Bots"><meta itemprop=description content="On the tenth day of Advent of Code 2016, we come across a factory in which many robots are zooming around, handing small microchips to each other."><meta itemprop=datePublished content="2021-04-03T00:00:00+00:00"><meta itemprop=dateModified content="2021-04-03T00:00:00+00:00"><meta itemprop=wordCount content="587"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2016,Python"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2016-day-10-balance-bots/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2016 - Day 10 - Balance Bots"><meta property="og:description" content="On the tenth day of Advent of Code 2016, we come across a factory in which many robots are zooming around, handing small microchips to each other."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-03T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-03T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2016"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2016 - Day 10 - Balance Bots"><meta name=twitter:description content="On the tenth day of Advent of Code 2016, we come across a factory in which many robots are zooming around, handing small microchips to each other."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2016-day-10-balance-bots/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Advent of Code 2016 - Day 10 - Balance Bots</h1><time class=post__time>Apr 3, 2021</time></header><main class=prose><p>On the tenth day of Advent of Code 2016, we come across a factory in which many robots are zooming around, handing small microchips to each other.</p><p>Upon entry into the factory, we notice that each bot only proceeds when it has two microchips.
Once it does, it gives each one to a different bot or puts it in a marked <em>output</em> bin.
Sometimes, bots take microchips from <em>input</em> bins, too.</p><h2 id=part-1>Part 1</h2><p>We are supplied with the bot instructions as our input and are required to determine which numbered bot is responsible for comparing value-61 microchips with value-17 microchips.
To begin, we will provide the functionality to parse the input (value) and bot/output allocation instructions.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_values</span>(instructions):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [(int(val<span style=color:#f92672>.</span>group(<span style=color:#ae81ff>1</span>)), val<span style=color:#f92672>.</span>group(<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> instructions
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (val <span style=color:#f92672>:=</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;value (\d+) goes to (bot \d+)&#39;</span>, line))]
</span></span></code></pre></div><p>This allows us to return input (value) instructions as a tuple, containing the value and bot number to which it should be supplied.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_allocations</span>(instructions):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [alloc<span style=color:#f92672>.</span>groups()
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> instructions
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (alloc <span style=color:#f92672>:=</span> re<span style=color:#f92672>.</span><span style=color:#66d9ef>match</span>(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;(bot \d+) gives low to (\w+ \d+) and high to (\w+ \d+)&#39;</span>, line))]
</span></span></code></pre></div><p>This allows us to return high/low value allocations as a tuple, containing the sender bot and the high and low microchip recipients (either another bot or an output bin).</p><p>With the ability to now parse the instruction set into a form we can process, we can begin to model how we wish to handle each bot allocation.
I initially modelled this as a queue, in which we processed each valid instruction and subsequent allocations until there were no more actions to take.
This worked well.
However, since the initial solution, I thought it would be interesting to explore taking advantage of partial function application instead.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>setup_bins</span>(allocations):
</span></span><span style=display:flex><span>    bins <span style=color:#f92672>=</span> collections<span style=color:#f92672>.</span>defaultdict(<span style=color:#66d9ef>lambda</span>: <span style=color:#66d9ef>lambda</span> x: x)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>config_bot</span>(low_recipient, high_recipient):
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>awaiting_first_chip</span>(a):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>awaiting_second_chip</span>(b):
</span></span><span style=display:flex><span>                l, h <span style=color:#f92672>=</span> sorted((a, b))
</span></span><span style=display:flex><span>                bins[low_recipient] <span style=color:#f92672>=</span> bins[low_recipient](l)
</span></span><span style=display:flex><span>                bins[high_recipient] <span style=color:#f92672>=</span> bins[high_recipient](h)
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>return</span> (l, h)
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> awaiting_second_chip
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> awaiting_first_chip
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> bot, low, high <span style=color:#f92672>in</span> allocations:
</span></span><span style=display:flex><span>        bins[bot] <span style=color:#f92672>=</span> config_bot(low, high)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> bins
</span></span></code></pre></div><p>To simplify the design, we store both outputs and bots in the same dictionary called <em>bins</em>.
Each entry consists of a single-arity function, which either returns a value (when the bot has performed its allocation) or a subsequent single-arity function that needs to be applied in a later action.
We use Python&rsquo;s default dictionary capabilities to return an identity function for non-existent keys, ensuring uniform application of output bin allocations.
All bot allocation instructions are translated into <em>configured bots</em> within the dictionary, which is then returned to the caller.</p><p>From here, we are then able to set up the bins and provide all the initial value instructions to the bots.
Subsequently, all the bot allocation functions will be applied as specified, resulting in a final bin representation.
This final bin representation can then be inspected to determine which bot compares bot-17 and bot-61&rsquo;s microchips 🌟.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(input):
</span></span><span style=display:flex><span>    instructions <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span>splitlines()
</span></span><span style=display:flex><span>    bins <span style=color:#f92672>=</span> setup_bins(parse_allocations(instructions))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> val, bot <span style=color:#f92672>in</span> parse_values(instructions):
</span></span><span style=display:flex><span>        bins[bot] <span style=color:#f92672>=</span> bins[bot](val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> next(bot <span style=color:#66d9ef>for</span> bot, allocated <span style=color:#f92672>in</span> bins<span style=color:#f92672>.</span>items() <span style=color:#66d9ef>if</span> allocated <span style=color:#f92672>==</span> (<span style=color:#ae81ff>17</span>, <span style=color:#ae81ff>61</span>))
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><p>For part two, we are required to multiply together the values of one chip in each of outputs 0, 1, and 2.
This can be achieved using the same initial process as in part one, except now we inspect the bins for the resulting <code>output N</code> values.
These values are then multiplied, leading to our answer 🌟.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(input):
</span></span><span style=display:flex><span>    instructions <span style=color:#f92672>=</span> input<span style=color:#f92672>.</span>splitlines()
</span></span><span style=display:flex><span>    bins <span style=color:#f92672>=</span> setup_bins(parse_allocations(instructions))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> val, bot <span style=color:#f92672>in</span> parse_values(instructions):
</span></span><span style=display:flex><span>        bins[bot] <span style=color:#f92672>=</span> bins[bot](val)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> math<span style=color:#f92672>.</span>prod(bins[<span style=color:#e6db74>&#39;output </span><span style=color:#e6db74>{}</span><span style=color:#e6db74>&#39;</span><span style=color:#f92672>.</span>format(i)] <span style=color:#66d9ef>for</span> i <span style=color:#f92672>in</span> range(<span style=color:#ae81ff>3</span>))
</span></span></code></pre></div></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/advent-of-code-2016>advent-of-code-2016</a><a href=/archive/tag/python>python</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>