<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Discover two optimised implementations of merge sort in Scala using tail recursion and streams, complete with detailed code examples and explanations.">

    <title>
        
            Merge sort in Scala using Tail-recursion and Streams &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Merge sort in Scala using Tail-recursion and Streams</h1>
    <time datetime="2013-12-01T00:00:00+00:00" class="post-date">01 Dec 2013</time>
    <p>In a previous <a href="/posts/merge-sort-comparison-in-java-and-scala/">post</a> I made a rudimentary comparison of Java and Scala using the <a href="http://en.wikipedia.org/wiki/Merge_sort">Merge sort</a> algorithm as a case study.
There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list.
In this post I wish to describe two very different implementations that resolve this glaring omission.</p>



<h2 id="tail-recursion">Tail-recursion</h2>

<p>A method call can be categorised as tail-recursive if there is no action to undertake after the method returns, aside from returning its own value.
In such an example, a compiler rewrite (in effect mimicking <a href="http://en.wikipedia.org/wiki/Goto">Goto</a>) can replace the caller in-place for the callee without any side effects.
As a result, no new stack frame is required (re-using the existing one) per recursive call, providing similar efficiency to a common iteration loop.</p>

<p>The ‘merge’ method, which is the point of stack overflow consideration in our example, has been refactored below to instead use an accumulator parameter, now completing all required work before the next call.
The compiler is then able to parse these recursive method calls and run the described optimisation.
In this case, the Scala compiler does not require that an annotation be present as it can deduce this requirement; however, for clarity I have included it.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">implicit</span> <span class="k">def</span> <span class="nf">IntIntLessThan</span><span class="o">(</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span>

<span class="k">def</span> <span class="nf">mergeSort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">xs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">])(</span><span class="k">implicit</span> <span class="n">pred</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="nd">@scala</span><span class="o">.</span><span class="py">annotation</span><span class="o">.</span><span class="py">tailrec</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">rs</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">acc</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">())</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">rs</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="nf">case</span> <span class="o">(</span><span class="nc">Nil</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">++</span> <span class="n">rs</span>
            <span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nc">Nil</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">acc</span> <span class="o">++</span> <span class="n">ls</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">l</span> <span class="o">::</span> <span class="n">ls1</span><span class="o">,</span> <span class="n">r</span> <span class="o">::</span> <span class="n">rs1</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nf">if</span> <span class="o">(</span><span class="nf">pred</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls1</span><span class="o">,</span> <span class="n">rs</span><span class="o">,</span> <span class="n">acc</span> <span class="o">:+</span> <span class="n">l</span><span class="o">)</span>
                <span class="k">else</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">rs1</span><span class="o">,</span> <span class="n">acc</span> <span class="o">:+</span> <span class="n">r</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">m</span>
        <span class="nf">merge</span><span class="o">(</span><span class="nf">mergeSort</span><span class="o">(</span><span class="n">l</span><span class="o">),</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="n">r</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">mergeSort</span><span class="o">(</span><span class="nc">List</span><span class="o">(</span><span class="mi">4</span><span class="o">,</span> <span class="mi">2</span><span class="o">,</span> <span class="mi">1</span><span class="o">,</span> <span class="mi">3</span><span class="o">)))</span>
</code></pre></div></div>

<p>A small, example-driven inclusion that I have also made is in the use of an implicit method to provide the less-than predicate.
Implicits are an extremely powerful feature that deserves its own post.
Simply put, the compiler is able to implicitly deduce that I wish to use this comparator method based on its type signature <code class="language-plaintext highlighter-rouge">(Int, Int) =&gt; Boolean</code>.</p>

<h2 id="streams">Streams</h2>

<p>Another example which eliminates the chance of a stack overflow when calling the ‘merge’ method is with the use of <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream">Streams</a>.
From the provided ‘numbers’ method you can gain a simple understanding that a Stream is basically a lazily evaluated sequence that only does the work (the generator method) when it is required.
This property does not particularly help us in this case, as we are required to know the finite length of the list for the divide step.
What we can take advantage of is the implicit conversion that occurs with the call #:: to a <a href="http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream$$ConsWrapper">ConsWrapper</a>.
Calling this operator creates a new ‘Cons’ object via the application <code class="language-plaintext highlighter-rouge">cons.apply[A](hd: A, tl -&gt; Stream[A]): Cons[A]</code>, and due to the second argument being called-by-name, it does not get evaluated at this time on the stack.
As all objects on the JVM are created on the much larger heap, we in essence are indirectly transferring this work.</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">mergeSort</span><span class="o">[</span><span class="kt">T</span><span class="o">](</span><span class="n">pred</span><span class="k">:</span> <span class="o">(</span><span class="kt">T</span><span class="o">,</span> <span class="kt">T</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Boolean</span><span class="o">)(</span><span class="n">xs</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
    <span class="k">val</span> <span class="nv">m</span> <span class="k">=</span> <span class="nv">xs</span><span class="o">.</span><span class="py">length</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="n">xs</span>
    <span class="k">else</span> <span class="o">{</span>
        <span class="k">def</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">],</span> <span class="n">rs</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">])</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">T</span><span class="o">]</span> <span class="k">=</span> <span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">rs</span><span class="o">)</span> <span class="k">match</span> <span class="o">{</span>
            <span class="nf">case</span> <span class="o">(</span><span class="nv">Stream</span><span class="o">.</span><span class="py">Empty</span><span class="o">,</span> <span class="k">_</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">rs</span>
            <span class="nf">case</span> <span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">Empty</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">ls</span>
            <span class="nf">case</span> <span class="o">(</span><span class="n">l</span> <span class="o">#::</span> <span class="n">ls1</span><span class="o">,</span> <span class="n">r</span> <span class="o">#::</span> <span class="n">rs1</span><span class="o">)</span> <span class="k">=&gt;</span>
                <span class="nf">if</span> <span class="o">(</span><span class="nf">pred</span><span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">))</span> <span class="n">l</span> <span class="o">#::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls1</span><span class="o">,</span> <span class="n">rs</span><span class="o">)</span>
                <span class="k">else</span> <span class="n">r</span> <span class="o">#::</span> <span class="nf">merge</span><span class="o">(</span><span class="n">ls</span><span class="o">,</span> <span class="n">rs1</span><span class="o">)</span>
        <span class="o">}</span>
        <span class="nf">val</span> <span class="o">(</span><span class="n">l</span><span class="o">,</span> <span class="n">r</span><span class="o">)</span> <span class="k">=</span> <span class="n">xs</span> <span class="n">splitAt</span> <span class="n">m</span>
        <span class="nf">merge</span><span class="o">(</span><span class="nf">mergeSort</span><span class="o">(</span><span class="n">pred</span><span class="o">)(</span><span class="n">l</span><span class="o">),</span> <span class="nf">mergeSort</span><span class="o">(</span><span class="n">pred</span><span class="o">)(</span><span class="n">r</span><span class="o">))</span>
    <span class="o">}</span>
<span class="o">}</span>

<span class="k">def</span> <span class="nf">numbers</span><span class="o">(</span><span class="n">remain</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span><span class="k">:</span> <span class="kt">Stream</span><span class="o">[</span><span class="kt">Int</span><span class="o">]</span> <span class="k">=</span>
    <span class="nf">if</span> <span class="o">(</span><span class="n">remain</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">Empty</span>
    <span class="k">else</span> <span class="nv">Stream</span><span class="o">.</span><span class="py">cons</span><span class="o">(</span><span class="nv">util</span><span class="o">.</span><span class="py">Random</span><span class="o">.</span><span class="py">nextInt</span><span class="o">(</span><span class="mi">100</span><span class="o">),</span> <span class="nf">numbers</span><span class="o">(</span><span class="n">remain</span> <span class="o">-</span> <span class="mi">1</span><span class="o">))</span>

<span class="nf">println</span><span class="o">(</span><span class="nf">mergeSort</span><span class="o">((</span><span class="n">x</span><span class="k">:</span> <span class="kt">Int</span><span class="o">,</span> <span class="n">y</span><span class="k">:</span> <span class="kt">Int</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="n">y</span><span class="o">)(</span><span class="nf">numbers</span><span class="o">(</span><span class="mi">4</span><span class="o">)).</span><span class="py">toList</span><span class="o">)</span>
</code></pre></div></div>

<p>I should note, however, that although the above example is very crafty in its attempt to eliminate a stack overflow, it does, of course, move this issue over to the heap.
As a result, it is recommended to use the first example (tail-recursive optimisations) and enjoy the ninja-esque skills of the second one.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
