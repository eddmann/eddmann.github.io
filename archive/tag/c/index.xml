<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>C on Edd Mann</title><link>https://eddmann.com/archive/tag/c/</link><description>Recent content in C on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Fri, 03 Jun 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/c/index.xml" rel="self" type="application/rss+xml"/><item><title>Solving the Advent of Code 2021 calendar on a Raspberry Pi Pico</title><link>https://eddmann.com/posts/solving-the-advent-of-code-2021-calendar-on-a-raspberry-pi-pico/</link><pubDate>Fri, 03 Jun 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/solving-the-advent-of-code-2021-calendar-on-a-raspberry-pi-pico/</guid><description>&lt;p>Over the past year or so, I have been interested in microcontrollers and finding ways I can look to &lt;a href="https://eddmann.com/posts/building-a-2fa-totp-generator-using-a-raspberry-pi-pico-and-micropython/">use them&lt;/a> within personal projects.
Having just completed the &lt;a href="https://eddmann.com/posts/solving-the-advent-of-code-2021-calendar-using-c-in-under-half-a-second/">Advent of Code 2021&lt;/a> calendar in C, I thought it would be interesting to see how many of these solutions I could get to run on the constrained hardware of a Raspberry Pi Pico.
In this article, I will discuss how I went about achieving this, presenting the solutions&amp;rsquo; answers on a &lt;a href="https://shop.pimoroni.com/products/pico-display-pack?variant=32368664215635" rel="external noopener" target="_blank">Pimoroni Display&lt;/a> via an interactive menu (with paging).&lt;/p></description></item><item><title>Solving the Advent of Code 2021 calendar using C in under half-a-second</title><link>https://eddmann.com/posts/solving-the-advent-of-code-2021-calendar-using-c-in-under-half-a-second/</link><pubDate>Mon, 30 May 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/solving-the-advent-of-code-2021-calendar-using-c-in-under-half-a-second/</guid><description>&lt;p>Since being introduced to the world of &lt;a href="https://adventofcode.com/" rel="external noopener" target="_blank">Advent of Code&lt;/a> just prior to the 2020 calendar starting, I subsequently spent the majority of 2021 completing (and documenting) the &lt;a href="https://eddmann.com/archive/tag/advent-of-code-2015">2015&lt;/a>, &lt;a href="https://eddmann.com/archive/tag/advent-of-code-2016">2016&lt;/a> and &lt;a href="https://github.com/eddmann/advent-of-code/tree/master/2017/rust" rel="external noopener" target="_blank">2017&lt;/a> calendars.
For the 2021 calendar, I decided that it would be interesting (and challenging) to complete the calendar in C, with an initial solution written in Python to meet the daily aspect of the challenge.
Additionally, with C being such a performant language, I also wanted to set the goal of ensuring that the entire C calendar was solvable on a single CPU core in under half a second (inspired by &lt;a href="https://www.dannyvankooten.com/blog/2021/solving-advent-of-code-2020-under-1-second/" rel="external noopener" target="_blank">this&lt;/a> blog post).
In this post, I wish to discuss how I went about achieving this goal (&lt;em>spoiler&lt;/em>: &lt;code>410315 Î¼s (0.410 s)&lt;/code> on average) and the hurdles I faced along the way.&lt;/p></description></item><item><title>Developing a Resizable-Indexed Array as a PHP Extension with Joe Watkins</title><link>https://eddmann.com/posts/developing-a-resizable-indexed-array-as-a-php-extension-with-joe-watkins/</link><pubDate>Fri, 28 Aug 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/developing-a-resizable-indexed-array-as-a-php-extension-with-joe-watkins/</guid><description>Following on from our first screencast, which touched upon how to set up a PHP extension development environment and the creation of a simple &lt;code>array_sum&lt;/code>-like function. We now further this topic by implementing a resizable-indexed array class which supplies very similar functionality to that of the &lt;code>SplFixedArray&lt;/code> class.</description></item><item><title>PHP Extension Development for Beginners with Joe Watkins</title><link>https://eddmann.com/posts/php-extension-development-for-beginners-with-joe-watkins/</link><pubDate>Mon, 03 Aug 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/php-extension-development-for-beginners-with-joe-watkins/</guid><description>In the very first screencast episode of Three Devs and a Maybe, I was fortunate to chat with PHP core developer Joe Watkins, discussing PHP 5 and 7 extension development for beginners.</description></item><item><title>Introduction to Creating a Basic PHP Extension</title><link>https://eddmann.com/posts/introduction-to-creating-a-basic-php-extension/</link><pubDate>Wed, 12 Mar 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/introduction-to-creating-a-basic-php-extension/</guid><description>&lt;p>I recently decided to test my novice C skills in the field of building a PHP extension.
However, despite some very good resources (&lt;a href="http://www.phpinternalsbook.com/" rel="external noopener" target="_blank">here&lt;/a> and &lt;a href="http://devzone.zend.com/303/extension-writing-part-i-introduction-to-php-and-zend/" rel="external noopener" target="_blank">here&lt;/a>), there still seems to be a lack of beginner-friendly material on the subject.
In this post I will document a simple development environment that has worked well on a fresh CentOS 6.5 installation.
Once this has been set up, we will then move on to creating a simple &amp;lsquo;Hello World&amp;rsquo; extension, highlighting some of the extension platform&amp;rsquo;s capabilities.&lt;/p></description></item><item><title>Implementing a Dynamic Vector (Array) in C</title><link>https://eddmann.com/posts/implementing-a-dynamic-vector-array-in-c/</link><pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-dynamic-vector-array-in-c/</guid><description>&lt;p>An array (vector) is a commonplace data type, used to hold and describe a collection of elements.
These elements can be fetched at runtime by one or more indices (identifying keys).
A distinguishing feature of an array compared to a list is that arrays allow constant-time random access, unlike lists which provide sequential access.
Resizable arrays allow for an unspecified upper bound of collection elements at runtime, and are conceptually similar to lists.&lt;/p></description></item><item><title>Implementing Heapsort in Java and C</title><link>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</link><pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</guid><description>&lt;p>In this post, we will delve into the mechanics of heapsort by building a tree-based heap data structure and then methodically extracting a sorted array.
We will then implement said algorithm in both Java and C to get a feel for how the process is modelled in code.&lt;/p></description></item><item><title>Implementing a Doubly Linked List in C</title><link>https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/</link><pubDate>Fri, 03 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/</guid><description>&lt;p>Following on from the discussion on implementing a &lt;a href="https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/">singly linked list&lt;/a> in C, a logical follow-up data structure is the doubly linked list.&lt;/p></description></item><item><title>Implementing a XOR Doubly Linked-List in C</title><link>https://eddmann.com/posts/implementing-a-xor-doubly-linked-list-in-c/</link><pubDate>Fri, 03 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-xor-doubly-linked-list-in-c/</guid><description>&lt;p>This post examines the implementation of a XOR doubly linked-list in C.
It provides a detailed explanation of how pointer arithmetic combined with the XOR operation can reduce memory usage in a linked list.
The discussion covers both the benefits and the challenges of managing memory at a low level in C.&lt;/p></description></item><item><title>Implementing a Singly Linked-List in C</title><link>https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/</link><pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/</guid><description>&lt;p>Over the past couple of days I have become very interested in brushing up on my limited C knowledge.
As I discussed in my previous &lt;a href="https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/">post&lt;/a> on using the XOR swap method, everyday languages are becoming very high-level, and as a result taking away some of the fun.
In the next couple of posts I wish to implement some of the commonplace data structures found in development, but unlike previous attempts, these will be in straight C.&lt;/p></description></item></channel></rss>