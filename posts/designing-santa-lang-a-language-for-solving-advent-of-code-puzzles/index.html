<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Designing santa-lang, a language for solving Advent of Code puzzles - Edd Mann</title>
<meta name=description content="This post documents my experience developing a functional, C-like programming language for solving Advent of Code puzzles."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Designing santa-lang, a language for solving Advent of Code puzzles"><meta itemprop=description content="Over the past several years, I have been slowly working my way through the previous Advent of Code calendars. For each calendar, I opt to solve the puzzles in a new programming language to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar when I grow to dislike some aspect of the language. So I had an ideaâ€¦ why not give this whole programming language design a go? That way, if I grow to dislike the language, I only have myself to blame!"><meta itemprop=datePublished content="2022-11-30T00:00:00+00:00"><meta itemprop=dateModified content="2022-11-30T00:00:00+00:00"><meta itemprop=wordCount content="1872"><meta itemprop=keywords content="Typescript,Santa-Lang,Advent-of-Code"><meta property="og:url" content="https://eddmann.com/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Designing santa-lang, a language for solving Advent of Code puzzles"><meta property="og:description" content="Over the past several years, I have been slowly working my way through the previous Advent of Code calendars. For each calendar, I opt to solve the puzzles in a new programming language to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar when I grow to dislike some aspect of the language. So I had an ideaâ€¦ why not give this whole programming language design a go? That way, if I grow to dislike the language, I only have myself to blame!"><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-30T00:00:00+00:00"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Santa-Lang"><meta property="article:tag" content="Advent-of-Code"><meta name=twitter:card content="summary"><meta name=twitter:title content="Designing santa-lang, a language for solving Advent of Code puzzles"><meta name=twitter:description content="Over the past several years, I have been slowly working my way through the previous Advent of Code calendars. For each calendar, I opt to solve the puzzles in a new programming language to familiarise myself with other ways of understanding and working. However, there comes a time in each calendar when I grow to dislike some aspect of the language. So I had an ideaâ€¦ why not give this whole programming language design a go? That way, if I grow to dislike the language, I only have myself to blame!"><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.c3ee6cab58dd3fee7e6960b0391e996ba9254804702bc60a52ec5e0e3591a018.css integrity="sha256-w+5sq1jdP+5+aWCwOR6Za6klSARwK8YKUuxeDjWRoBg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.164d56ac6f4c8613b0b7109fd1b4d9dfdce1d004edab8e1afb7240013f9221d7.js integrity="sha256-Fk1WrG9MhhOwtxCf0bTZ39zh0ATtq44a+3JAAT+SIdc=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:designing-santa-lang-a-language-for-solving-advent-of-code-puzzles>Designing santa-lang, a language for solving Advent of Code puzzles</h1><time datetime=2022-11-30T00:00:00Z class=published-at>Nov 30, 2022</time></header><main class=u-prose><p>Over the past several years, I have been slowly working <a href=https://github.com/eddmann/advent-of-code/tree/master/2015 rel="external noopener" target=_blank>my</a> <a href=https://github.com/eddmann/advent-of-code/tree/master/2016/python rel="external noopener" target=_blank>way</a> <a href=https://github.com/eddmann/advent-of-code/tree/master/2017/rust rel="external noopener" target=_blank>through</a> the previous Advent of Code calendars.
For each calendar, I opt to solve the puzzles in a new programming language to familiarise myself with other ways of understanding and working.
However, there comes a time in each calendar when I grow to dislike some aspect of the language.
So I had an idea&mldr; why not give this whole programming language design a go?
That way, if I grow to dislike the language, I only have myself to blame!</p><p><a href=https://github.com/eddmann/santa-lang-ts rel="external noopener" target=_blank><picture><source type=image/webp srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_534716efdd84dee5.webp 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_c970fea05e68d715.webp 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_dff387258a8eda6b.webp 869w"><source type=image/jpeg srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_406b55cbd55d7351.jpg 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_91ac4c5711f2ec4f.jpg 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_ddd8662e1f4342b4.jpg 869w"><img src=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/logo_hu_91ac4c5711f2ec4f.jpg alt=santa-lang loading=lazy></picture></a></p><p>Welcome <em>santa-lang</em>, my <a href=https://en.wikipedia.org/wiki/Interpreter_%28computing%29 rel="external noopener" target=_blank>tree-walking interpreted</a> programming language designed to help tackle Advent of Code puzzles.
In this article, I would like to discuss the high-level thought process and design considerations that went into building the initial language.</p><h2 id=the-design-specification>The Design Specification</h2><p>The first step I took was to clearly lay out the overall design goals of the language.
Having done a little research into how other languages had been formed and continued to grow, it seemed that the underlying core values and design principles shaped each new decision.
As such, I decided to compile a list of my desired direction and feature set for a language that would best help me solve Advent of Code puzzles.</p><h3 id=the-language>The Language</h3><ul><li>Dynamically typed, C-like language with a rich suite of core types: integers, decimals, strings, lists, hash maps, and sets.</li><li><a href=https://en.wikipedia.org/wiki/Persistent_data_structure rel="external noopener" target=_blank>Persistent (Immutable) data structures</a>, which follow the same value semantics as integers, decimals, and strings.</li><li>Cheap function/closure definition, composition, and invocation - aided by the inclusion of <a href=https://en.wikipedia.org/wiki/Currying rel="external noopener" target=_blank>auto-currying</a>.</li><li>Everything is a function, with infix invocation being purely syntactic sugar, i.e., <code>1 + 2</code> is boiled down to <code>+(1, 2)</code>.</li><li>Everything is an expression, with the last statement within a block being its return value (by default), i.e., <code>let x = if y > 5 { y } else { y - 1 }</code>.</li><li>The ability to handle lazy sequences and infinite ranges.</li><li>A rich suite of in-built functions targeting the core types and data structures, following <a href=https://www.quora.com/Why-is-it-better-to-have-100-functions-operate-on-one-data-structure-than-10-functions-on-10-data-structures-on-Clojure rel="external noopener" target=_blank>Clojure&rsquo;s philosophy</a>.</li><li>No mutation, opting for readability and correctness over outright speed.</li></ul><h3 id=the-aoc-runner>The AoC Runner</h3><p>Whilst writing the list above, I soon realised that there was a differentiation between the core language requirements and the Advent of Code <em>runner</em>/<em>runtime</em> in which it would be evaluated.
Thinking upon past experience whilst solving Advent of Code puzzles, and how a language runtime could aid in solution development, I devised the list below:</p><ul><li>The source file can be optionally structured to represent the two parts of an Advent of Code solution.</li><li>Based on this source file structure, there is an in-built test runner which can be used to validate test input supplied with a puzzle.</li><li>Easy means of downloading, parsing, and interacting with the puzzle input.</li><li>The ability to run the written solutions within a CLI and Web-IDE based setting.</li><li>Detailed error handling, with a clear understanding of where the issue is within the source file.</li></ul><h2 id=the-initial-implementation>The Initial Implementation</h2><p>With my desired language and runtime goals laid out, I set off in developing the initial implementation.
Fortunately, there are <a href=https://interpreterbook.com/ rel="external noopener" target=_blank>some</a> <a href=https://monkeylang.org/ rel="external noopener" target=_blank>amazing</a> <a href=https://craftinginterpreters.com/ rel="external noopener" target=_blank>resources</a> available to help get started building your own programming language.
With respect to my runtime requirements (CLI and Web), and with the feeling that this journey would no doubt be a huge learning experience in itself, I felt it best to opt for a host language I was comfortable in.
As such, I chose <a href=https://github.com/eddmann/santa-lang-ts rel="external noopener" target=_blank>TypeScript</a>.</p><h3 id=show-me-the-code>Show me the code?!</h3><p>One of the biggest takeaways from the initial development phase was the importance of spending time in the <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang rel="external noopener" target=_blank>language</a> you are designing and exercising its use within the domain you want to solve problems in.
In my case, this was Advent of Code puzzles.
Below is an example of this process, where I went about solving <a href=https://adventofcode.com/2020/day/1 rel="external noopener" target=_blank>day 1</a> of the 2020 calendar in <em>santa-lang</em>.</p><pre tabindex=0><code>input: read(&#34;aoc://2020/1&#34;)

part_one: {
  input
    |&gt; ints
    |&gt; combinations(2)
    |&gt; find(|[a, b]| a + b == 2020)
    |&gt; reduce(*);
}

part_two: {
  input
    |&gt; ints
    |&gt; combinations(3)
    |&gt; find(|[a, b, c]| a + b + c == 2020)
    |&gt; reduce(*);
}

test: {
  input: &#34;1721\n979\n366\n299\n675\n1456&#34;
  part_one: 514579
  part_two: 241861950
}
</code></pre><p>The source file has been structured to represent how an Advent of Code day puzzle is laid out.
The language formally includes the concept of <em>sections</em>, which in this case (aided by the <em>runner</em>) are used to define the <code>input</code>, <code>part_one</code>, <code>part_two</code>, and <code>test</code> blocks.
Both <code>part_*</code> sections are supplied with the resulting evaluation of the <code>input</code> section, within a global <code>input</code> variable.
The in-built <code>read</code> function is host runtime specific (CLI and Web) and provides a means to read the relevant input file (into a string) based on the use of the <code>aoc://</code> schema.
Tests added to help aid in the solution of the puzzle can be defined in <code>test</code> sections, with the expected answers being supplied for automatic test-runner validation.</p><p>Within the above example, you can see how we have exercised the language&rsquo;s function threading (<code>|></code>) and partial application support, list destructuring, and use of rich built-in functions (<code>ints</code>, <code>combinations</code>).
The language itself pushes you towards a more functional mindset, declaring the puzzle solution as opposed to imperatively laying out each step.</p><p>Below are several other example solutions which exercise more of the built-in language and runtime constructs provided.</p><pre tabindex=0><code>input: read(&#34;aoc://2021/1&#34;)

let parse_measurements = lines &gt;&gt; map(int);

part_one: {
  let measures = parse_measurements(input);

  zip(measures, measures[1..])
    |&gt; count(|[a, b]| a &lt; b);
}

part_two: {
  let measures = parse_measurements(input);

  let windows = zip(measures, measures[1..], measures[2..])
    |&gt; map(sum);

  zip(windows, windows[1..])
    |&gt; count(|[a, b]| a &lt; b);
}

test: {
  input: &#34;199\n200\n208\n210\n200\n207\n240\n269\n260\n263&#34;
  part_one: 7
  part_two: 5
}
</code></pre><p>Within the above solution to <a href=https://adventofcode.com/2021/day/1 rel="external noopener" target=_blank>day 1</a> of the 2021 calendar, you can see the use of function composition (<code>>></code>), <code>let</code> bindings, named function definitions, and list slicing.</p><pre tabindex=0><code>input: read(&#34;aoc://2015/1&#34;)

part_one: {
  input |&gt; fold(0) |floor, direction| {
    if direction == &#34;(&#34; { floor + 1 } else { floor - 1 };
  }
}

part_two: {
  zip(1.., input) |&gt; fold(0) |floor, [index, direction]| {
    let next = if direction == &#34;(&#34; { floor + 1 } else { floor - 1 };
    if next &lt; 0 { break index } else { next };
  }
}

test: {
  input: &#34;()())&#34;
  part_one: -1
  part_two: 5
}
</code></pre><p>Within the above solution to <a href=https://adventofcode.com/2015/day/1 rel="external noopener" target=_blank>day 1</a> of the 2015 calendar, you can see the use of infinite ranges, <a href=https://kotlinlang.org/docs/lambdas.html#passing-trailing-lambdas rel="external noopener" target=_blank>trailing Lambdas</a>, <code>if</code> expressions, and short-circuiting a fold operation early (inspired by <a href=https://clojuredocs.org/clojure.core/reduced rel="external noopener" target=_blank>Clojure&rsquo;s</a> capability).</p><p>For more examples, check out the TypeScript implementation&rsquo;s <a href=https://github.com/eddmann/santa-lang-ts#readme rel="external noopener" target=_blank>README</a> and <a href=https://github.com/eddmann/santa-lang-ts/tree/main/examples rel="external noopener" target=_blank>examples</a> directory.
One example of note is the re-implementation of <a href=https://github.com/eddmann/santa-lang-ts/blob/main/examples/map-filter-fold-reduce.santa rel="external noopener" target=_blank>map, filter, fold, and reduce</a> within the language itself - effectively highlighting the use of pattern matching.</p><h3 id=the-cli-runtime>The CLI Runtime</h3><p>Once I had built the <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang rel="external noopener" target=_blank>core language</a> and <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang/src/runner rel="external noopener" target=_blank>runner</a>, a lot of time was then focused on developing the <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/cli rel="external noopener" target=_blank>CLI</a> runtime.
This was to ensure that I had the correct level of abstraction for what would be required as a runtime (CLI, Web) and core language/runner responsibility.</p><p>The resulting CLI is compiled into a single JavaScript artefact using <a href=https://esbuild.github.io/ rel="external noopener" target=_blank>esbuild</a>, and then subsequently packaged into a <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/cli/pkg.json rel="external noopener" target=_blank>binary</a> distribution (using <a href=https://github.com/vercel/pkg rel="external noopener" target=_blank>pkg</a>) and a <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/cli/Dockerfile rel="external noopener" target=_blank>Docker image</a>.
The inclusion of a Docker image provides me with the ability to easily run the <a href=https://github.com/eddmann/advent-of-code/blob/master/.github/workflows/2018-santa-lang-test.yml rel="external noopener" target=_blank>test suite</a> within my GitHub Action CI environment, in line with other calendar solutions.</p><p><picture><source type=image/webp srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_5cbf91d1041bcfc.webp 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_5c5edb8f3cb0ceab.webp 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_3f6caf84f5832546.webp 1384w"><source type=image/jpeg srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_378248f734e0aea6.jpg 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_12d85d7e074e4b0f.jpg 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_7504e7977d5cc6c1.jpg 1384w"><img src=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime_hu_12d85d7e074e4b0f.jpg alt="CLI runtime" loading=lazy></picture></p><p>With the optional <code>-t</code> flag, we are able to switch between exercising and validating the test input and the real input.
Additionally, input and output (per runtime) are abstracted away from the core language.
In the case of the <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/cli/src/io.ts rel="external noopener" target=_blank>CLI</a>, I was able to optionally download (and locally cache) the user&rsquo;s puzzle input with the inclusion of a <code>SANTA_CLI_SESSION_TOKEN</code> environment variable.</p><p><picture><source type=image/webp srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_930cacdd9a46ce45.webp 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_2edda346b87cce9c.webp 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_4929939c1599c5ce.webp 1384w"><source type=image/jpeg srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_fde9465448f033c3.jpg 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_abb8708ca94ad371.jpg 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_e5c2bdf7ebd6c26c.jpg 1384w"><img src=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/cli-runtime-error_hu_abb8708ca94ad371.jpg alt="CLI runtime error" loading=lazy></picture></p><p>One of my design goals was to ensure that it was easy to locate and determine errors found at runtime.
Aided by the error details the core language emits, I was able to present errors and the source location in a concise manner.</p><h3 id=the-web-runtime>The Web Runtime</h3><p>With the CLI runtime built, I then moved on to developing the <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/web rel="external noopener" target=_blank>Web</a> runtime equivalent.</p><p><a href=https://eddmann.com/santa-lang-ts/><picture><source type=image/webp srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_c112a10dcee7ffe9.webp 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_92dd6e29893e7d10.webp 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_3640d1582844f526.webp 1400w"><source type=image/jpeg srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_4f7cafe7de8ada6d.jpg 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_7490b0e13fc9b1fb.jpg 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_be69487dbab8c0cf.jpg 1400w"><img src=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/web-runtime_hu_7490b0e13fc9b1fb.jpg alt="Web runtime" loading=lazy></picture></a></p><p>I opted to use <a href=https://nextjs.org/ rel="external noopener" target=_blank>Next.js</a> (purely out of interest, as <a href=https://reactjs.org/docs/create-a-new-react-app.html rel="external noopener" target=_blank>CRA</a> would have sufficed) and <a href=https://esbuild.github.io/ rel="external noopener" target=_blank>esbuild</a> to compile and package the resulting artefact.
Unlike the CLI, which only required source file location input, this version also needed a means for the user to enter a given solution.
For this, I employed <a href=https://codemirror.net/ rel="external noopener" target=_blank>CodeMirror</a>, which has a great library with React bindings.
Upon solution execution, to avoid blocking the user&rsquo;s main browser thread, the language runtime is evaluated within a dedicated <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/web/worker.ts rel="external noopener" target=_blank>web worker</a>.</p><h3 id=the-bonus-aws-lambda-runtime>The (Bonus) AWS Lambda Runtime</h3><p>After developing the language and initial CLI and Web runtimes, I took a little time off to focus on my annual <a href=/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/>allocating Secret Santas</a> challenge.
This year, I decided to combine every supported Lambda runtime into a Step Function workflow (because&mldr; why not?!).
One such runtime was <code>provided.al2</code>, which provides a means of executing your own custom runtime.
With this project in mind, I thought - wouldn&rsquo;t it be cool to be able to run <em>santa-lang</em> within Lambda?
As such, I went about building a <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lambda rel="external noopener" target=_blank>Lambda</a> runtime that used a defined <em>section</em> to handle the given request.</p><p><picture><source type=image/webp srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_6df0e33cd24251fd.webp 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_2fcde6704b775aed.webp 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_80ab46c2186ad7cc.webp 1400w"><source type=image/jpeg srcset="/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_38caca87d96b8935.jpg 350w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_60f7a423ca048a75.jpg 700w, /posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_debab6eedb358382.jpg 1400w"><img src=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/lambda-runtime_hu_60f7a423ca048a75.jpg alt="Lambda runtime" loading=lazy></picture></p><p>The runtime itself was packaged in a similar manner to the CLI binary distribution (using <em>pkg</em>), except it honoured the <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/lambda/src/index.ts rel="external noopener" target=_blank>Custom Runtime API</a> contract laid out for AWS Lambda.
This highlighted the language&rsquo;s versatility - not only for solving Advent of Code puzzles (by way of the <em>runner</em>), but also as a general-purpose language.</p><h2 id=conclusion>Conclusion</h2><p>Upon reflection, I am very happy with how this project has evolved!
I feel the choice to build the initial implementation in TypeScript was invaluable, as throughout development and endless refinement stages (which are still ongoing), it has been a frictionless experience.
With the inclusion of libraries such as <a href=https://immutable-js.com/ rel="external noopener" target=_blank>Immutable.js</a>, I have been able to delegate a lot of the ancillary <em>heavy lifting</em> and focus on the core problem at hand.
The one caveat to this decision, however, is that choosing such a high-level host language comes at the cost of performance.
But as performance was not a key design goal of this project (favouring readability and correctness), I feel this trade-off is acceptable.</p><p>Another takeaway from this experience is how the building blocks that compose the final language and runtime can all be built and tested at each isolated level.
For example, the <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang/src/lexer rel="external noopener" target=_blank>lexer</a>, <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang/src/parser rel="external noopener" target=_blank>parser</a>, <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang/src/evaluator rel="external noopener" target=_blank>evaluator</a>, and subsequent AoC <a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lang/src/runner rel="external noopener" target=_blank>runner</a> are all separate concerns, built on top of the base formed by previous responsibilities.
I found that <a href=https://interpreterbook.com/ rel="external noopener" target=_blank>the book</a> laid this concept out very well, and I borrowed a lot of inspiration from it.</p><p>On top of this, I have been able to define the specification and intended language behaviour entirely through the included tests.
This provides me not only with confidence in my current implementation but also with a blueprint to implement the language again (i.e. in another host language ðŸ˜‰).</p><h3 id=whats-next>What&rsquo;s Next&mldr;</h3><p>December is fast approaching, and that can only mean one thing - another <a href=https://adventofcode.com/2022 rel="external noopener" target=_blank>Advent of Code calendar</a> is about to commence!
This year, I wish to use <em>santa-lang</em> as my primary language in solving as many of the calendar&rsquo;s puzzles as possible.
In the new year, I hope to reflect on this experience with a <a href=/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/>future article</a> detailing how it went.</p><p>Until next year! ðŸ‘‹</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/typescript>typescript</a></li><li><a href=/archive/tag/santa-lang>santa-lang</a></li><li><a href=/archive/tag/advent-of-code>advent-of-code</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/advent-of-code-2015-day-25-let-it-snow/>Advent of Code 2015 - Day 25 - Let It Snow</a></li><li><a href=/posts/advent-of-code-2015-day-24-it-hangs-in-the-balance/>Advent of Code 2015 - Day 24 - It Hangs in the Balance</a></li><li><a href=/posts/advent-of-code-2015-day-23-opening-the-turing-lock/>Advent of Code 2015 - Day 23 - Opening the Turing Lock</a></li><li><a href=/posts/advent-of-code-2015-day-22-wizard-simulator-20xx/>Advent of Code 2015 - Day 22 - Wizard Simulator 20XX</a></li><li><a href=/posts/advent-of-code-2015-day-21-rpg-simulator-20xx/>Advent of Code 2015 - Day 21 - RPG Simulator 20XX</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>