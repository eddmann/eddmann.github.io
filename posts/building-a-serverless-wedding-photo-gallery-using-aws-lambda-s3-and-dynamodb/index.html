<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB - Edd Mann</title>
<meta name=description content="Explore how to build a serverless wedding photo gallery using AWS Lambda, S3, and DynamoDB, enabling guests to share high-quality photos effortlessly."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB"><meta itemprop=description content="Whilst documenting how I structured the infrastructure used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern. In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day. So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place. I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting. In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB. The final implementation can be found in this GitHub repository."><meta itemprop=datePublished content="2022-10-31T00:00:00+00:00"><meta itemprop=dateModified content="2022-10-31T00:00:00+00:00"><meta itemprop=wordCount content="843"><meta itemprop=keywords content="Aws,Lambda,S3,Dynamodb,Serverless"><meta property="og:url" content="https://eddmann.com/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB"><meta property="og:description" content="Whilst documenting how I structured the infrastructure used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern. In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day. So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place. I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting. In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB. The final implementation can be found in this GitHub repository."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-10-31T00:00:00+00:00"><meta property="article:modified_time" content="2022-10-31T00:00:00+00:00"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Lambda"><meta property="article:tag" content="S3"><meta property="article:tag" content="Dynamodb"><meta property="article:tag" content="Serverless"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB"><meta name=twitter:description content="Whilst documenting how I structured the infrastructure used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern. In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day. So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place. I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting. In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB. The final implementation can be found in this GitHub repository."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6c18b9cbfe138a24784e64860eaa9d70076170f03c68d8be3b3f1ae99e51df9f.css integrity="sha256-bBi5y/4TiiR4TmSGDqqdcAdhcPA8aNi+Oz8a6Z5R358="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x3x.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB</h1><time class=post__time>Oct 31, 2022</time></header><main class=prose><p>Whilst <a href=https://github.com/eddmann/our-wedding-infra#stage-applications rel="external noopener" target=_blank>documenting</a> how I structured the <a href=https://github.com/eddmann/our-wedding-infra rel="external noopener" target=_blank>infrastructure</a> used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern.
In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day.
So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place.
I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting.
In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB.
The final implementation can be found in <a href=https://github.com/eddmann/our-wedding-gallery rel="external noopener" target=_blank>this GitHub repository</a>.</p><p><picture><source type=image/webp srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/diagram_hu_a4d0e97db1ada3a6.webp><source type=image/jpeg srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/diagram_hu_2f681160d3eccec0.jpg><img src=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/diagram_hu_2f681160d3eccec0.jpg alt="The AWS architecture diagram" loading=lazy></picture></p><h2 id=the-api>The API</h2><p>For the backend API, I opted to use the Node 16 (<code>nodejs16.x</code>) supported Lambda runtime, conforming to the RESTful Hypertext Application Language (HAL) standard.
Like in previous projects, I used the <a href=https://www.serverless.com/ rel="external noopener" target=_blank>Serverless Framework</a> to manage deploying the transient application while leaving the foundational building blocks for Terraform.
Each API endpoint&rsquo;s functionality is split into individually packaged artefacts using <a href=https://www.serverless.com/plugins/serverless-esbuild rel="external noopener" target=_blank>esbuild</a> for bundling and transpilation.
This provides smaller artefacts that only contain the dependencies (such as Sharp, AWS-SDK) which are actually required within each of the desired endpoints.</p><h3 id=persistence>Persistence</h3><p><picture><source type=image/webp srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/nosql-workbench_hu_38fe47abe349c064.webp><source type=image/jpeg srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/nosql-workbench_hu_9c85f04bb9aef27.jpg><img src=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/nosql-workbench_hu_9c85f04bb9aef27.jpg alt="The DynamoDB table schema" loading=lazy></picture></p><p>For storing the photo metadata and gallery listing (used for infinite scroll), I opted to use a <a href=https://www.alexdebrie.com/posts/dynamodb-single-table/ rel="external noopener" target=_blank>Single-Table Design</a> DynamoDB table.
This uses the <code>PK</code>/<code>SK</code> and <code>GSI*PK</code>/<code>GSI*SK</code> partition/sort key pattern found in Single-Table Design, allowing optimal data retrieval based on predefined access patterns.</p><p>The <code>GSI1PK</code> is used as a <em>hot key</em> 😬 for listing the gallery photos in sorted processed timestamp order, using the last evaluated key as a marker to progressively provide the <em>next</em> batch of gallery photos to the client.
Using a <em>hot key</em> is not best practice, but based on this usage pattern and load, it suffices for this use case.</p><p>In its current form, the use of a <em>Single-Table Design</em> may seem unnecessary since the application lacks multiple access patterns and concerns.
However, there is future scope to better showcase the idea with additional functionality, such as photo comments.</p><h3 id=photo-upload-and-resizing>Photo Upload and Resizing</h3><p>Uploaded photos are stored within an initial <em>upload</em> S3 bucket using pre-signed <a href=https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html rel="external noopener" target=_blank>form POST requests</a>, which are generated by the API based on a pre-request supplied by the client.
Upon successful photo upload, the resulting <code>s3:ObjectCreated</code> event triggers a Lambda function responsible for moving the photo to the <em>persistent</em> S3 bucket and generating resized web and thumbnail variants in WebP (using <a href=https://sharp.pixelplumbing.com/ rel="external noopener" target=_blank>Node.js Sharp</a>).
At the end of this process, a record with the photo&rsquo;s metadata is stored in the DynamoDB table for inclusion in the gallery response.
The initial <em>upload</em> S3 bucket uses a lifecycle rule to clean up any failed photo uploads after seven days.</p><h3 id=local-development>Local Development</h3><p>As stated above, one of my goals was to have local feature parity for development purposes.
Thanks to a combination of <a href=https://www.serverless.com/plugins/serverless-offline rel="external noopener" target=_blank>Serverless Offline</a>, <a href=https://www.serverless.com/plugins/serverless-dynamodb-local rel="external noopener" target=_blank>Serverless DynamoDB Local</a>, and <a href=https://www.serverless.com/plugins/serverless-s3-local rel="external noopener" target=_blank>Serverless S3 Local</a>, I was able to achieve just that 🎉.
I was pleasantly surprised at how easy it was to replicate both pre-signing S3 POST requests and handling S3 event triggers thanks to <a href=https://github.com/jamhall/s3rver rel="external noopener" target=_blank>s3rver</a>.
Doing this allowed me to have greater confidence in my implementation before deploying it to AWS.</p><h2 id=the-client>The Client</h2><p><picture><source type=image/webp srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/gallery_hu_f6170484b1020138.webp><source type=image/jpeg srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/gallery_hu_b8572a6f726a5730.jpg><img src=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/gallery_hu_b8572a6f726a5730.jpg alt="The lazy-loaded photo gallery" loading=lazy>
</picture><picture><source type=image/webp srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/lightbox_hu_a72504fc0928398f.webp><source type=image/jpeg srcset=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/lightbox_hu_6cde34b9e6c0d849.jpg><img src=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/lightbox_hu_6cde34b9e6c0d849.jpg alt="The photo lightbox" loading=lazy></picture></p><p>The client is developed as a Single-Page Application (SPA) using React and Create React App.
I used this project as an opportunity to explore <a href=https://tailwindcss.com/ rel="external noopener" target=_blank>Tailwind CSS</a> for presentational concerns.
The client is built statically within the <a href=https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows rel="external noopener" target=_blank>build pipeline</a>, distributed via S3, and fronted by CloudFront.
To ensure only authorised users have access to the gallery, a <a href=https://github.com/eddmann/our-wedding-infra/blob/main/stage/apps/gallery/resources/viewer-request.js rel="external noopener" target=_blank>CloudFront function</a> enforces that shared HTTP Basic Authentication credentials are supplied.
As the same CloudFront distribution is used to front the client, API, and S3 buckets, we can be certain that all requests are protected by these security measures.</p><h3 id=photo-lazy-loading-and-lightbox>Photo Lazy Loading and Lightbox</h3><p>The gallery is presented as an <a href=https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/PhotoGallery.js rel="external noopener" target=_blank>infinite scrollable list</a>, which progressively (lazily) requests the <em>next</em> available batch of photos.
When a photo is clicked on, a full-screen <a href=https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/Lightbox.js rel="external noopener" target=_blank>lightbox variant</a> is displayed, providing the ability to visually swipe back and forth (on mobile devices) between photos.
Effectively handling touch events, with graceful desktop mouse click fallback, was an interesting challenge using React Hooks.</p><h2 id=conclusion>Conclusion</h2><p>I really enjoyed the chance to add additional functionality that could be hosted within the infrastructure project I had set up for our wedding website.
Being able to replicate all the behaviour within a local setting was very satisfying, enabling a quick REPL for API/client development.
I was also very happy with the decision to structure both the client and API in a <a href=https://en.wikipedia.org/wiki/Monorepo rel="external noopener" target=_blank>monorepo</a>, with independent <a href=https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows rel="external noopener" target=_blank>build pipelines</a> for any changes that are pushed.</p><p>Finally, after seeing how this gallery has been used in practice, I feel the addition of handling video media would be a great future improvement.
Using <a href=https://aws.amazon.com/mediaconvert/ rel="external noopener" target=_blank>AWS Elemental MediaConvert</a> as a possible means to process uploaded video media could provide similar <em>elastic compute</em> functionality that Node.js Sharp, hosted on Lambda, does for photos.</p></main><footer class=post__tags><a href=/archive/tag/aws>aws</a><a href=/archive/tag/lambda>lambda</a><a href=/archive/tag/s3>s3</a><a href=/archive/tag/dynamodb>dynamodb</a><a href=/archive/tag/serverless>serverless</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>