<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Data-Structures on Edd Mann</title><link>https://eddmann.com/archive/tag/data-structures/</link><description>Recent content in Data-Structures on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Wed, 27 Jan 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/data-structures/index.xml" rel="self" type="application/rss+xml"/><item><title>Implementing a Compound Set in TypeScript</title><link>https://eddmann.com/posts/implementing-a-compound-set-in-typescript/</link><pubDate>Wed, 27 Jan 2021 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-compound-set-in-typescript/</guid><description>&lt;p>Since being introduced to Advent of Code, one feature missing from JavaScript that I have seen available in other languages (such as Python and Clojure) is Sets that handle &lt;a href="https://www.oreilly.com/library/view/javascript-design/0735711674/0735711674_ch03lev1sec3.html" rel="external noopener" target="_blank">Compound data-types&lt;/a>.
To focus each puzzle solution on the problem at hand and not &lt;em>re-invent the wheel&lt;/em>, I decided to implement a &lt;code>CompoundSet&lt;/code> data structure to fill this void.&lt;/p></description></item><item><title>AVL Trees in Clojure</title><link>https://eddmann.com/posts/avl-trees-in-clojure/</link><pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/avl-trees-in-clojure/</guid><description>An AVL tree is a self-balancing binary search tree, whereby the height of a node&amp;rsquo;s children differs by at most one. In the event that this property is violated, a rebalancing process takes place.</description></item><item><title>Creating a IPersistentSet compatible Binary Tree in Clojure</title><link>https://eddmann.com/posts/creating-a-ipersistentset-compatible-binary-tree-in-clojure/</link><pubDate>Wed, 27 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/creating-a-ipersistentset-compatible-binary-tree-in-clojure/</guid><description>Following on from my post on Binary Search Trees last week, I decided to explore how I could use types and interfaces to implement the glue required to make the Binary Tree implementation compatible with the &lt;code>clojure.lang.IPersistentSet&lt;/code> interface.</description></item><item><title>Binary Search Trees in Clojure</title><link>https://eddmann.com/posts/binary-search-trees-in-clojure/</link><pubDate>Wed, 20 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/binary-search-trees-in-clojure/</guid><description>&lt;p>This weekend I was able to spend some more time exploring Clojure.
I decided that it would be interesting to reimplement some of the &lt;a href="https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/">Binary Search Tree work&lt;/a> I had previously done in PHP.
We start by creating a simple record definition which describes the contents of a Node.&lt;/p></description></item><item><title>Insertion, Removal and Inversion Operations on Binary (Search) Trees in PHP</title><link>https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/</link><pubDate>Wed, 22 Jul 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/</guid><description>&lt;p>Recently Max Howell (creator of &lt;a href="http://brew.sh/" rel="external noopener" target="_blank">Homebrew&lt;/a>) posted an interesting &lt;a href="https://twitter.com/mxcl/status/608682016205344768" rel="external noopener" target="_blank">tweet&lt;/a> in regard to Google&amp;rsquo;s interview process.
In this tweet he mentioned how one of the proposed questions was to white-board a solution to invert a binary tree.
Over the past couple of years I have been interested in exploring fundamental computer science data structures and algorithms.
As a result, I thought it would be interesting to explore this structure and its associated operations in more depth - using immutable and mutable PHP implementations to clearly highlight the benefits garnered from each approach.&lt;/p></description></item><item><title>Implementing Streams in PHP</title><link>https://eddmann.com/posts/implementing-streams-in-php/</link><pubDate>Fri, 16 Jan 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-streams-in-php/</guid><description>Typically, when we think about a list of elements we assume there is both a start and a finite end. In this example the list has been precomputed and stored for subsequent traversal and transformation. If instead, we replaced the finite ending with a promise to return the next element in the sequence, we would have the architecture to provide infinite lists.</description></item><item><title>Cons Lists and Folds in PHP</title><link>https://eddmann.com/posts/cons-lists-and-folds-in-php/</link><pubDate>Fri, 02 Jan 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/cons-lists-and-folds-in-php/</guid><description>Cons cells are used to (cons)truct a data object which represents an ordered pair. The elements in this pair can be identified as &amp;lsquo;car&amp;rsquo; and &amp;lsquo;cdr&amp;rsquo; accordingly. Using this simple representation, we are able not only to hold ordered pairs but also to create more complex data structures, such as a List.</description></item><item><title>Tuples in PHP</title><link>https://eddmann.com/posts/tuples-in-php/</link><pubDate>Thu, 17 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/tuples-in-php/</guid><description>&lt;p>Since exploring languages such as Scala and Python which provide the tuple data structure, I have been keen to experiment with how to clearly map it into a PHP solution.
Tuples are simply a finite, ordered sequence of elements - usually with good language support to both pack (construction) and unpack (deconstruction) the values.
I have found that many use cases of the commonplace array structure in PHP could be better suited to n-tuples.
Familiar examples such as coordinate pairs (points) and records from a relational database (e.g. a user id and name) could succinctly take advantage of the structure.&lt;/p></description></item><item><title>Implementing a Dynamic Vector (Array) in C</title><link>https://eddmann.com/posts/implementing-a-dynamic-vector-array-in-c/</link><pubDate>Mon, 20 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-dynamic-vector-array-in-c/</guid><description>&lt;p>An array (vector) is a commonplace data type, used to hold and describe a collection of elements.
These elements can be fetched at runtime by one or more indices (identifying keys).
A distinguishing feature of an array compared to a list is that arrays allow constant-time random access, unlike lists which provide sequential access.
Resizable arrays allow for an unspecified upper bound of collection elements at runtime, and are conceptually similar to lists.&lt;/p></description></item><item><title>Implementing a Doubly Linked List in C</title><link>https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/</link><pubDate>Fri, 03 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/</guid><description>&lt;p>Following on from the discussion on implementing a &lt;a href="https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/">singly linked list&lt;/a> in C, a logical follow-up data structure is the doubly linked list.&lt;/p></description></item><item><title>Implementing a XOR Doubly Linked-List in C</title><link>https://eddmann.com/posts/implementing-a-xor-doubly-linked-list-in-c/</link><pubDate>Fri, 03 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-xor-doubly-linked-list-in-c/</guid><description>&lt;p>This post examines the implementation of a XOR doubly linked-list in C.
It provides a detailed explanation of how pointer arithmetic combined with the XOR operation can reduce memory usage in a linked list.
The discussion covers both the benefits and the challenges of managing memory at a low level in C.&lt;/p></description></item><item><title>Implementing a Singly Linked-List in C</title><link>https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/</link><pubDate>Mon, 30 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-singly-linked-list-in-c/</guid><description>&lt;p>Over the past couple of days I have become very interested in brushing up on my limited C knowledge.
As I discussed in my previous &lt;a href="https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/">post&lt;/a> on using the XOR swap method, everyday languages are becoming very high-level, and as a result taking away some of the fun.
In the next couple of posts I wish to implement some of the commonplace data structures found in development, but unlike previous attempts, these will be in straight C.&lt;/p></description></item><item><title>Implementing a Queue in Java using Arrays and Linked Lists</title><link>https://eddmann.com/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/</link><pubDate>Tue, 24 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/</guid><description>&lt;p>Following on from my previous post on implementing a &lt;a href="https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/">stack&lt;/a> in Java, I now wish to discuss the equally important queue data structure.
Similar to the restrictions placed upon the stack implementation, the queue only allows mutation via two methods.
Addition (enqueue) occurs at the end of the collection, and removal (dequeue) from the beginning, resulting in a FIFO (First-In-First-Out) structure.
Queues are typically used as buffers to store data, objects, and events that are to be held for future sequential processing.
As discussed in the post on stacks, you are more than likely never going to have to implement such a data structure in practical use cases, as the language libraries will already include such an implementation (i.e. &lt;a href="http://www.cplusplus.com/reference/queue/queue/" rel="external noopener" target="_blank">C++ STL&lt;/a> and &lt;a href="http://www.php.net/manual/en/class.splqueue.php" rel="external noopener" target="_blank">PHP SplQueue&lt;/a>).&lt;/p></description></item><item><title>Implementing a Stack in Java using Arrays and Linked Lists</title><link>https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/</link><pubDate>Sun, 22 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/</guid><description>&lt;p>The stack is a fundamental data structure used extensively in algorithm design and program implementation.
At an abstract level, it can be described very simply, as it only allows for the addition (pushing) of new elements and the removal (popping) of existing elements from the top of the stack.
This description can be abbreviated to LIFO, which stands for Last-In-First-Out.
Although you will most likely not have to implement such a structure for practical use cases, it can be very useful to &amp;rsquo;look under the hood&amp;rsquo; to gain a better understanding of what is going on.
Doing so will make you more aware of when this data structure can be best used.&lt;/p></description></item></channel></rss>