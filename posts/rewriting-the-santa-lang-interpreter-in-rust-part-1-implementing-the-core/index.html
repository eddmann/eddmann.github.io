<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core - Edd Mann</title>
<meta name=description content="This blog series details my experience rewriting the santa-lang interpreter in Rust. In this post, I delve into how I organised the project and built the core language."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core"><meta itemprop=description content="After implementing santa-lang in TypeScript (Node), I wanted to explore rewriting the tree-walking interpreter in a lower-level systems language for efficiency and performance gains. My goal was to be able to run the entire Advent of Code 2022 calendar quicker than the Node variant. I settled on using Rust due to its blend of high and low-level constructs, its vibrant package registry (Cargo), memory management model, and previous enjoyable experience using the language. In this first post within the series, I will document how I went about organising the project and rewriting the core language within Rust."><meta itemprop=datePublished content="2023-08-05T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-05T00:00:00+00:00"><meta itemprop=wordCount content="1812"><meta itemprop=keywords content="Rust,Santa-Lang,Interpreter,Santa-Lang-in-Rust-Series"><meta property="og:url" content="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core"><meta property="og:description" content="After implementing santa-lang in TypeScript (Node), I wanted to explore rewriting the tree-walking interpreter in a lower-level systems language for efficiency and performance gains. My goal was to be able to run the entire Advent of Code 2022 calendar quicker than the Node variant. I settled on using Rust due to its blend of high and low-level constructs, its vibrant package registry (Cargo), memory management model, and previous enjoyable experience using the language. In this first post within the series, I will document how I went about organising the project and rewriting the core language within Rust."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-05T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-05T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Santa-Lang"><meta property="article:tag" content="Interpreter"><meta property="article:tag" content="Santa-Lang-in-Rust-Series"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core"><meta name=twitter:description content="After implementing santa-lang in TypeScript (Node), I wanted to explore rewriting the tree-walking interpreter in a lower-level systems language for efficiency and performance gains. My goal was to be able to run the entire Advent of Code 2022 calendar quicker than the Node variant. I settled on using Rust due to its blend of high and low-level constructs, its vibrant package registry (Cargo), memory management model, and previous enjoyable experience using the language. In this first post within the series, I will document how I went about organising the project and rewriting the core language within Rust."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.4c8b66c005db4efc68625e4ceed190f2dc110d342d05ffb19ba924cc13c3ef15.css integrity="sha256-TItmwAXbTvxoYl5M7tGQ8twRDTQtBf+xm6kkzBPD7xU="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.da71ac9c7b8bd4e644618df0ab735aed1393aad3cb5e5c57e5adc300fe7c8209.js integrity="sha256-2nGsnHuL1OZEYY3wq3Na7ROTqtPLXlxX5a3DAP58ggk=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li><li><a href=/cv.html>CV</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core>Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core</h1><time datetime=2023-08-05T00:00:00Z class=published-at>Aug 5, 2023</time></header><main class=u-prose><p>After implementing santa-lang in <a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/>TypeScript (Node)</a>, I wanted to explore rewriting the tree-walking interpreter in a lower-level systems language for efficiency and performance gains.
My goal was to be able to run the entire <a href=https://adventofcode.com/2022 rel="external noopener" target=_blank>Advent of Code 2022 calendar</a> <em>quicker</em> than the Node variant.
I settled on using Rust due to its blend of high and low-level constructs, its vibrant package registry (Cargo), memory management model, and previous <a href=/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/>enjoyable experience using the language</a>.
In this first post within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>, I will document how I went about organising the project and rewriting the core language within Rust.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_534716efdd84dee5.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_c970fea05e68d715.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_dff387258a8eda6b.webp 869w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_406b55cbd55d7351.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_91ac4c5711f2ec4f.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_ddd8662e1f4342b4.jpg 869w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/logo_hu_91ac4c5711f2ec4f.jpg alt=santa-lang loading=lazy></picture></p><p>I decided to organise the project using <a href=https://doc.rust-lang.org/cargo/reference/workspaces.html rel="external noopener" target=_blank>Cargo workspaces</a>, with the language and each (delivery) runtime being colocated in the same monorepo as separate packages.
This provided a good level of modularity and structure to the project.
Within the language library itself, I broke up each of the individual layers into subdirectory modules, with tests colocated with the specific layer.</p><pre tabindex=0><code>├── Cargo.toml
├── runtime
│   └── cli
│       └── Cargo.toml
└── lang
    ├── Cargo.toml
    └── src
        ├── evaluator
        ├── lexer
        ├── parser
        └── runner
</code></pre><p>To implement the core, I used the TypeScript test suite as documented behaviour I wished to provide.
This proved to be a very rewarding experience, whereby investing the time in making a solid test suite for the initial implementation made it somewhat trivial to follow this time around.
Due to the manner in which each layer (<a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/#lexer>Lexer</a>, <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/#parser>Parser</a>, <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/#evaluator>Evaluator</a>) is built on top of each other, I was able to work my way up the stack, garnering confidence at each level.
Whilst building out the testing framework within Rust, I stumbled upon <a href=https://docs.rs/expect-test/latest/expect_test/ rel="external noopener" target=_blank>expect_test</a>, which uses macros to provide a frictionless means to validate (and automatically update) test assertions.
For data structure-centric outputs such as the Lexer and Parser, this was ideal.</p><h2 id=lexer>Lexer</h2><p>Within the Lexer, I decided to implement the tokenizer as an <code>Iterator</code>, which the Parser could consume.
I additionally used a <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/lexer/token.rs#L118-L177 rel="external noopener" target=_blank>macro</a> (shown below) to express the Lexer tokens in an <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/lexer/mod.rs#L44 rel="external noopener" target=_blank>easier-to-read</a> form than the <code>Token</code> enumeration itself.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#75715e>#[macro_export]</span>
</span></span><span style=display:flex><span>macro_rules<span style=color:#f92672>!</span> T {
</span></span><span style=display:flex><span>    [<span style=color:#66d9ef>INT</span>] <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>$crate</span>::lexer::TokenKind::Integer };
</span></span><span style=display:flex><span>    [<span style=color:#f92672>+</span>]   <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>$crate</span>::lexer::TokenKind::Plus };
</span></span><span style=display:flex><span>    [<span style=color:#f92672>||</span>]  <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>$crate</span>::lexer::TokenKind::PipePipe };
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ..
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><h2 id=parser>Parser</h2><p>With the Lexer implemented and tested, the generated tokens were then used to construct an Abstract Syntax Tree (AST) by way of the Parser.
Several interesting choices were made due to using Rust as the implementation language.</p><p>In this case, an error was handled using an explicit <code>Result</code> type, as opposed to throwing an exception.
Upon a parser error being found, a <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/parser/mod.rs#L26 rel="external noopener" target=_blank><code>ParserErr</code></a> would be returned with a detailed message and the source location.
To avoid <em>indentation hell</em>, I appreciated how we could express an <code>Err</code>, short-circuiting execution using the <a href=https://doc.rust-lang.org/rust-by-example/std/result/question_mark.html rel="external noopener" target=_blank>question mark operator</a>.
For example, <code>self.expect(T![ID])?</code> ensures that the next token consumed is an <em>identifier</em>, else it short-circuits and returns the <code>Err</code> type.
This syntax also works for <code>Option</code> types.</p><p>As discussed before, we were able to use the macro tokens that were defined within the Lexer to clearly describe the translation to a meaningful AST.
One such example of this was while parsing an <em>if expression</em>, combining the representation of the tokens as expected santa-lang syntax along with short-circuiting upon a <code>ParserErr</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span><span style=color:#66d9ef>fn</span> <span style=color:#a6e22e>parse_if_expression</span>(<span style=color:#f92672>&amp;</span><span style=color:#66d9ef>mut</span> self) -&gt; <span style=color:#a6e22e>RExpression</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> start <span style=color:#f92672>=</span> self.expect(T![<span style=color:#66d9ef>IF</span>])<span style=color:#f92672>?</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    self.consume_if(T![<span style=color:#e6db74>&#39;(&#39;</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> condition <span style=color:#f92672>=</span> Box::new(self.parse_expression(Precedence::Lowest)<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>    self.consume_if(T![<span style=color:#e6db74>&#39;)&#39;</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> consequence <span style=color:#f92672>=</span> Box::new(self.parse_block_statement()<span style=color:#f92672>?</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> alternative <span style=color:#f92672>=</span> <span style=color:#66d9ef>if</span> self.consume_if(T![<span style=color:#66d9ef>ELSE</span>]) {
</span></span><span style=display:flex><span>        Some(Box::new(self.parse_block_statement()<span style=color:#f92672>?</span>))
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        None
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Ok(Expression {
</span></span><span style=display:flex><span>        kind: <span style=color:#a6e22e>ExpressionKind</span>::If { condition, consequence, alternative },
</span></span><span style=display:flex><span>        source: <span style=color:#a6e22e>start</span>.source_range(<span style=color:#f92672>&amp;</span>self.current_token),
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>It was also during Parser development that I became very familiar with the concept of a <code>Box</code>.
This type stores a value on the <em>heap</em> rather than the <em>stack</em>, with the size of the smart pointer known at compile time and the value it points to being of indeterminate size until runtime.
As we are allocating the value onto the <em>heap</em>, this does incur performance penalties.
However, it also provides us with the ability to define recursive types, which is required when building up the AST.
For example, in the case of <code>Box&lt;Expression></code>, we do not know the exact type/size of <code>Expression</code> at compile time, as we are required to parse the santa-lang source code provided at runtime to discern this.</p><h2 id=evaluator>Evaluator</h2><p>The largest undertaking was evaluating the parsed AST.
In this step, I opted to use the concept of <code>Frames</code> to model the stacked computation.
Represented as an <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/mod.rs#L42C10-L60 rel="external noopener" target=_blank>enumeration</a>, it allowed me to trivially express and destructure the different states.</p><p>Like the TypeScript implementation, trying to break up the evaluation behaviour into manageable-sized chunks was an important task.
To achieve this, I decided to break up key behaviours into separate functions (located in separate files).
To ensure that there was no performance penalty or unnecessary function invocation for this decision, I used <a href=https://nnethercote.github.io/perf-book/inlining.html rel="external noopener" target=_blank>inline annotations</a>, which will be discussed more in a <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/>future post</a> within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>.
Some behaviours that I separated out were language <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/function.rs rel="external noopener" target=_blank>function invocation</a> (user-land, memoized, closures, external and built-in), <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/infix.rs rel="external noopener" target=_blank>infix operations</a>, and santa-lang&rsquo;s <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/matcher.rs rel="external noopener" target=_blank>match expressions</a>.</p><h3 id=rcrefcellt>Rc&lt;RefCell&lt;T>></h3><p>Similar to the Parser, as the size of certain values is not known at compile-time, some work has to be delegated to runtime.
As evaluation of the santa-lang source code could lead to shared ownership and mutation of given values, we could not rely on Rust&rsquo;s compile-time memory management.
It was here that I was introduced to <code>Rc&lt;RefCell&lt;T>></code>.
The <code>Rc</code> keeps track of how many references exist to a given value, deallocating it when the count reaches zero.
The <code>RefCell</code> provides us with the ability to borrow a mutable value even when the type is deemed immutable.
Combined, this allows multiple parts of the program to have read-only access to the same value, whilst allowing parts to mutate it when necessary.
This results in runtime errors over our preferred compile-time errors.
It should also be noted that this combination only works for single-threaded applications.
There are alternative means of solving this for multithreaded applications (i.e. using <code>Arc</code>).</p><p>I have a love-hate relationship with this concept.
On the one hand, it allows me to trivially handle many <code>Object</code>s being passed around and mutated throughout the evaluator&rsquo;s lifetime.
However, on the other hand, it does not feel very Rust-like, losing the compile-time memory management guarantees that we hold so dear.
After reviewing several interpreter implementations in Rust, I noticed that they all used this concept.
I would like to revisit it to explore alternative approaches that reduce reliance on this moving forward.</p><h3 id=lazy-sequences>Lazy Sequences</h3><p>In the previous implementation, I had made extensive use of the <a href=https://immutable-js.com/ rel="external noopener" target=_blank>ImmutableJS</a> library, not only for immutable data structures but also for the lazy operations that could be applied to them.
However, when it came to the Rust implementation, there was no such library that offered both behaviours.
Fortunately, I was able to use the <a href=https://github.com/bodil/im-rs rel="external noopener" target=_blank>im-rs</a> library, which provided performant immutable data structures (of which I found <a href=https://github.com/eddmann/im-rs/commit/90092043778c5812c0b236d61c70acdb3acaa584 rel="external noopener" target=_blank>one gotcha bug</a>).
Regarding the lazy sequences, I had to implement these myself.</p><p>It was an interesting challenge (especially with Rust&rsquo;s borrow checker) to handle such computation.
Similar to the Lexer, I built my own custom <code>Iterator</code>, which handled resolving the underlying lazy value and applying operations that had been defined (<code>maps</code>, <code>filters</code>, etc.).
I was happy with the resulting behaviour but still feel that this implementation could do with some attention.
It still does not feel very Rust-like to me (I wonder what a true <em>Rustacean</em> would think of it).</p><h3 id=standard-library>Standard Library</h3><p>A large part of the santa-lang evaluator is the standard library that it provides.
As the language is dynamically typed, each function call can be passed many arguments (of differing types) and needs to be able to handle them accordingly.
Upon researching a means to handle this within Rust, I could see there were two options: dynamic dispatch (via <code>Object</code> type traits) and in-place invocation (via pattern matching).
I had used <a href=https://www.shuttle.rs/blog/2024/04/18/using-traits-generics-rust#object-traits-and-dynamic-dispatch rel="external noopener" target=_blank>dynamic dispatch</a> within the TypeScript implementation.
Although highly readable and extendable, it was going to result in runtime performance penalties I was not willing to incur.
As such, I was only left with in-place invocation.</p><p>Taking inspiration from the <a href=https://docs.rs/enum_dispatch/latest/enum_dispatch/ rel="external noopener" target=_blank>enum_dispatch</a> crate, I decided to build my own <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/builtins/macros.rs rel="external noopener" target=_blank><code>builtin!</code></a> function suite of macros.
This allowed me to remove the boilerplate of choosing inline invocation whilst keeping a clean DSL for defining the many different functions the language had to offer.
A good example of this is how the <code>map</code> function is defined, whereby we are able to co-locate the different mapping behaviours based on type.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>builtin! {
</span></span><span style=display:flex><span>    map(mapper, collection) [evaluator, source] <span style=color:#66d9ef>match</span> {
</span></span><span style=display:flex><span>        (Object::Function(mapper), Object::List(list)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (Object::Function(mapper), Object::Set(set)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (Object::Function(mapper), Object::Dictionary(map)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (Object::Function(mapper), Object::LazySequence(sequence)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>        (Object::Function(mapper), Object::String(string)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Additionally, it catered for <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/evaluator/builtins/collection.rs#L835 rel="external noopener" target=_blank>multi-arity arguments</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-rust data-lang=rust><span style=display:flex><span>builtin! {
</span></span><span style=display:flex><span>    zip(collection, <span style=color:#f92672>..</span>collections) [evaluator, source] <span style=color:#66d9ef>match</span> {
</span></span><span style=display:flex><span>        (_, Object::List(collections)) <span style=color:#f92672>=&gt;</span> { <span style=color:#75715e>// .. }
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This DSL is one of the areas I am most proud of within the Rust rewrite of the language.
It allows me to clearly define a function&rsquo;s parameters and implement pattern-matched behaviours based on the parsed-in arguments.</p><h3 id=external-functions>External Functions</h3><p>Along with providing built-in functions defined within the core language, the TypeScript implementation included a means of adding external functions, which are defined during evaluator instantiation.
These external functions can be used to provide runtime-specific behaviour, for example, implementing I/O concerns such as <code>puts</code> and <code>read</code>.
To implement this capability within the interpreter, I was required to use a <code>dyn Fn</code> <a href=https://doc.rust-lang.org/std/keyword.dyn.html rel="external noopener" target=_blank>trait object</a> definition over basic function pointers.
This provides the ability to pass <em>Closures</em> as external functions, which was a requirement when building the WASM runtime (discussed in the <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/>next post</a>).
There are some performance disadvantages to modelling it this way due to extra indirection via the <em>vtable</em> lookup.
However, it should be noted that a heap allocation is not required if the trait object it is storing has zero size, which is the case for functions and Closures that do not capture any variables.</p><h2 id=runner>Runner</h2><p>Finally, I was able to build the Advent of Code Runner, which was used to parse the <em>AoC</em> file format and execute the solutions (with provided tests).
At this step, I enjoyed building a <a href=https://github.com/eddmann/santa-lang-comet/blob/ec9a5ecc795ea9a67844d0c5d3720e960a8bd31b/lang/src/runner/mod.rs#L82-L84 rel="external noopener" target=_blank><code>Time</code></a> trait, which was used for runtimes to specify how they determined the current time, as we could not rely solely on a <a href=https://en.wikipedia.org/wiki/POSIX rel="external noopener" target=_blank>POSIX</a> implementation (i.e. WASM).
I also encapsulated the internal Parser and Runtime errors into a type that is publicly accessible to the runtimes using the <code>From</code> trait (<code>From&lt;RuntimeErr> for RunErr</code>).
This ensured that the internal error types remained private and were not leaked out of the <em>core domain</em>.</p><h2 id=whats-next>What&rsquo;s Next&mldr;</h2><p>With the core language library now implemented and tested, it was time to move on to the different runtimes.
In the <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/>next post</a> within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>, I will document how I went about integrating the core language library into the (delivery) runtimes.</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/rust>rust</a></li><li><a href=/archive/tag/santa-lang>santa-lang</a></li><li><a href=/archive/tag/interpreter>interpreter</a></li><li><a href=/archive/tag/santa-lang-in-rust-series>santa-lang-in-rust-series</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/>Solving the Advent of Code 2022 calendar using my own programming language, santa-lang</a></li><li><a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/>Designing santa-lang, a language for solving Advent of Code puzzles</a></li><li><a href=/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/>Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime</a></li><li><a href=/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/>Building a Rubik's Cube Solver using Rust/WASM and Three.js/React</a></li><li><a href=/posts/building-an-optimal-pocket-cube-solver-using-rust-wasm-threejs-and-react/>Building an optimal Pocket Cube (2x2x2) Solver using Rust/WASM and Three.js/React</a></li></ul></div></footer></article><div class="podcast-ad u-overlay-wrapper"><div class=podcast-ad__artwork><img src=https://compiledconversations.com/album-art.jpg alt="Compiled Conversations podcast album art" class=podcast-ad__artwork-image></div><div class=podcast-ad__content><h3 class=podcast-ad__title>Compiled Conversations</h3><p class=podcast-ad__description>Podcast I host, featuring conversations with the people shaping software and technology.</p><div class=podcast-ad__link>Check out the show</a></div><a class=u-overlay href=https://compiledconversations.com target=_blank>Listen to Compiled Conversations</a></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2026, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>