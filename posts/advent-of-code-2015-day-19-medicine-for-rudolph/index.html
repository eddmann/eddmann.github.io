<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Solving the Advent of Code 2015 Day 19 puzzle using TypeScript">

    <title>
        
            Advent of Code 2015 - Day 19 - Medicine for Rudolph &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Advent of Code 2015 - Day 19 - Medicine for Rudolph</h1>
    <time datetime="2021-02-12T00:00:00+00:00" class="post-date">12 Feb 2021</time>
    <p>On the nineteenth day of Advent of Code 2015 Rudolph is sick and we have been tasked to help develop the <em>custom-made</em> medicine required.</p>



<h3 id="part-1">Part 1</h3>

<p>We are tasked with helping calibrate the machine that is capable of constructing any Red-Nosed Reindeer molecule required to make the medicine.
As input we are provided an initial medicine molecule and list of replacements of which we need to apply.
For part one, we need to work out how many distinct molecules can be created using the replacements provided.
We begin as always by parsing this input into a form we can work with.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Replacement</span> <span class="o">=</span> <span class="p">[</span><span class="k">from</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">to</span><span class="p">:</span> <span class="kr">string</span><span class="p">];</span>
<span class="kd">type</span> <span class="nx">Molecule</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">parseReplacementsAndMolecule</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">input</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="p">{</span> <span class="nl">replacements</span><span class="p">:</span> <span class="nx">Replacement</span><span class="p">[];</span> <span class="nl">molecule</span><span class="p">:</span> <span class="nx">Molecule</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n\n</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">replacements</span><span class="p">:</span> <span class="nx">replacements</span>
      <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> =&gt; </span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="nx">Replacement</span><span class="p">),</span>
    <span class="nx">molecule</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>With a listing of all the replacements and the initial molecule now available we can use these values in determining all the possible molecule variants.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getMoleculeVariants</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span>
  <span class="nx">m</span><span class="p">:</span> <span class="nx">Molecule</span><span class="p">,</span>
  <span class="p">[</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">]:</span> <span class="nx">Replacement</span>
<span class="p">):</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">Molecule</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="dl">'</span><span class="s1">g</span><span class="dl">'</span><span class="p">);</span>

  <span class="kd">let</span> <span class="na">o</span><span class="p">:</span> <span class="nx">RegExpExecArray</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="nx">o</span> <span class="o">=</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">m</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">index</span><span class="p">)</span> <span class="o">+</span> <span class="nx">to</span> <span class="o">+</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">index</span> <span class="o">+</span> <span class="k">from</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Given the molecule and desired replacement we return a Generator which provides the callee with all the possible variants (based on individual occurrences) within the string.
This allows us to maintain the current position within the Generator and not muddle this logic into the callees responsibility.</p>

<p>We can then combine these two function and determine how many distinct molecule variants there are ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">parseReplacementsAndMolecule</span><span class="p">(</span>
    <span class="nx">input</span>
  <span class="p">);</span>

  <span class="kd">const</span> <span class="na">variants</span><span class="p">:</span> <span class="nx">Molecule</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">replacements</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">molecules</span><span class="p">,</span> <span class="nx">replacement</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span>
      <span class="p">...</span><span class="nx">molecules</span><span class="p">,</span>
      <span class="p">...</span><span class="nx">getMoleculeVariants</span><span class="p">(</span><span class="nx">molecule</span><span class="p">,</span> <span class="nx">replacement</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="p">[]</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="nx">Molecule</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">variants</span><span class="p">).</span><span class="nx">size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I initially used a Set within the reduction, but due to the ease of combining arrays within JavaScript I felt it more readable to first get all possible variants and then return the Set (the deduplication process) at the end.</p>

<h3 id="part-2">Part 2</h3>

<p>For part two, with the machine now calibrated we are required to help with the fabrication process.
Molecule fabrication always begins with just a single electron, <em>e</em>, and applying replacements one at a time, just like the ones during calibration.
We are required to work out how many steps it will take to go from <em>e</em> to the provided molecule.</p>

<p>My initial thought for this was to begin at <em>e</em> and apply all the possible variants until we landed on the desired molecule (like the problem states).
However, the distinct amount of possabilities grows too fast and as such this is not a viable solution.
After alittle thought, I decided to instead flip this problem around and based on the molecule provideed decern how many replacements would be required to get back to <em>e</em>.
I opted for a <em>greedy approach</em>, sorting the replacements by descending length order.
In doing so we can then count the steps required and return the desired total to answer part two ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">parseReplacementsAndMolecule</span><span class="p">(</span>
    <span class="nx">input</span>
  <span class="p">);</span>
  <span class="kd">const</span> <span class="nx">replacementsByLength</span> <span class="o">=</span> <span class="nx">replacements</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span>
    <span class="p">([,</span> <span class="nx">x</span><span class="p">],</span> <span class="p">[,</span> <span class="nx">y</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">);</span>

  <span class="kd">let</span> <span class="nx">variant</span> <span class="o">=</span> <span class="nx">molecule</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">variant</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">]</span> <span class="k">of</span> <span class="nx">replacementsByLength</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">r</span> <span class="k">of</span> <span class="nx">getMoleculeVariants</span><span class="p">(</span><span class="nx">variant</span><span class="p">,</span> <span class="p">[</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">variant</span> <span class="o">=</span> <span class="nx">r</span><span class="p">;</span>
        <span class="nx">steps</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">steps</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The input has been constructed in such a way that there is no possibility for ambiguity, with only one path back to <em>e</em>.
An interesting optimisation I made was that in a previous solution I broke out of both the variant and replacement loops upon finding a match.
This would ensure that we were performing the largest replacement possible every step.
However, I experimented with what we now have above and instead allow it to continue on to the next possible replacement.
This looks to have speeded up the solution and returns the same answer.</p>

<p>I really enjoyed todays challenge and would highly recommend you check out the discussion on the <a href="https://www.reddit.com/r/adventofcode/comments/3xflz8/day_19_solutions/">/r/adventofcode</a> subreddit which details some interesting ways in which people and solved the problem by-hand!</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
