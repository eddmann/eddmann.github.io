<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime - Edd Mann</title>
<meta name=description content="Documents my exploration into the many available Lambda runtimes, by way of orchestrating a Step Function workflow for allocating Secret Santas."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime"><meta itemprop=description content="Over the past several years, I have taken the opportunity of allocating Secret Santas for members of my family as an excuse to explore different programming languages and technologies. This year has been no different, with me opting to over-engineer the problem of allocating and notifying participants by diving into AWS Step Functions and the many runtimes available on Lambda. In this post, I wish to document how I went about designing the Step Function workflow and breaking up the problem into many specific-purpose Lambda behaviours. The final implementation can be found in this GitHub repository."><meta itemprop=datePublished content="2022-11-01T00:00:00+00:00"><meta itemprop=dateModified content="2022-11-01T00:00:00+00:00"><meta itemprop=wordCount content="894"><meta itemprop=keywords content="Aws,Lambda,Step-Function,Santa-Lang"><meta property="og:url" content="https://eddmann.com/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime"><meta property="og:description" content="Over the past several years, I have taken the opportunity of allocating Secret Santas for members of my family as an excuse to explore different programming languages and technologies. This year has been no different, with me opting to over-engineer the problem of allocating and notifying participants by diving into AWS Step Functions and the many runtimes available on Lambda. In this post, I wish to document how I went about designing the Step Function workflow and breaking up the problem into many specific-purpose Lambda behaviours. The final implementation can be found in this GitHub repository."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-11-01T00:00:00+00:00"><meta property="article:modified_time" content="2022-11-01T00:00:00+00:00"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Lambda"><meta property="article:tag" content="Step-Function"><meta property="article:tag" content="Santa-Lang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime"><meta name=twitter:description content="Over the past several years, I have taken the opportunity of allocating Secret Santas for members of my family as an excuse to explore different programming languages and technologies. This year has been no different, with me opting to over-engineer the problem of allocating and notifying participants by diving into AWS Step Functions and the many runtimes available on Lambda. In this post, I wish to document how I went about designing the Step Function workflow and breaking up the problem into many specific-purpose Lambda behaviours. The final implementation can be found in this GitHub repository."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6349357a7c7c5fccfe48c11ed795a2d71fd809d82eefa5bc95dddd1002c18057.css integrity="sha256-Y0k1enx8X8z+SMEe15Wi1x/YCdgu76W8ld3dEALBgFc="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Allocating Secret Santas using an AWS Step Function workflow and every available Lambda runtime</h1><time class=post__time>Nov 1, 2022</time></header><main class=prose><p>Over the past several years, I have taken the opportunity of allocating Secret Santas for members of my family as an excuse to explore different <a href=/posts/allocating-and-notifying-secret-santas-via-email-using-clojure/>programming languages</a> and <a href=/posts/building-a-secret-santa-allocator-and-sms-sender-using-a-raspberry-pi-pico-micropython-and-sim800l-module/>technologies</a>.
This year has been no different, with me opting to <em>over-engineer</em> the problem of allocating and notifying participants by diving into <a href=https://aws.amazon.com/step-functions/ rel="external noopener" target=_blank>AWS Step Functions</a> and the many runtimes available on Lambda.
In this post, I wish to document how I went about designing the Step Function workflow and breaking up the problem into many specific-purpose Lambda behaviours.
The final implementation can be found in <a href=https://github.com/eddmann/step-function-secret-santa rel="external noopener" target=_blank>this GitHub repository</a>.</p><p>I should reiterate that this is heavily over-engineered for solving the problem at hand, with the main driver being to provide me with enough of a problem domain to explore the many different features/states (i.e. Map, Choice, Parallel) of Step Functions and runtimes available on Lambda.</p><h2 id=step-function-workflows>Step Function Workflows?</h2><p>I have had the opportunity to explore employing a Step Function workflow for several personal projects over the years, providing a high level of orchestration/durability between task/state transitions.
One of the key elements I have found is knowing when to model such decisions/executions at the workflow level or leave them within the code itself.
Fortunately, this problem could be broken up into several logically separate problems (parsing, allocating, notifying), which allowed me to experiment with handling <a href=https://docs.aws.amazon.com/step-functions/latest/dg/concepts-error-handling.html rel="external noopener" target=_blank>failure</a> and <a href=https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-map-state.html rel="external noopener" target=_blank>mapping</a> input in <a href=https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-parallel-state.html rel="external noopener" target=_blank>parallel</a> with <a href=https://docs.aws.amazon.com/step-functions/latest/dg/amazon-states-language-choice-state.html rel="external noopener" target=_blank>choice</a> branching.</p><h2 id=lambda-runtimes>Lambda Runtimes?</h2><p>I am a big proponent of Lambda, but due to the languages and runtimes I have been exposed to in the past, I have not had the opportunity to explore many of the available runtimes Lambda has to offer.
Breaking up this problem into many Lambda behaviours felt like a great opportunity to change that.</p><p>However, with the availability of the <a href=https://docs.aws.amazon.com/lambda/latest/dg/runtimes-custom.html rel="external noopener" target=_blank>Custom Runtime API</a>, the list of <em>available</em> runtimes is <strong>endless</strong>.
As such, I decided to limit the scope to all six distinct <a href=https://docs.aws.amazon.com/lambda/latest/dg/lambda-runtimes.html rel="external noopener" target=_blank>supported runtimes</a> AWS has to offer, along with a single custom runtime hosted on <code>provided.al2</code>.
This gave me the chance to experience and implement functionality in each language runtime using more than just a simple <em>Hello World</em> example.</p><h3 id=custom-runtime>Custom Runtime</h3><p>Instead of using a pre-built custom runtime, I opted to additionally take the opportunity of integrating my <a href=https://github.com/eddmann/santa-lang-ts rel="external noopener" target=_blank>own personal language</a>, which I have been developing over the year, into a Lambda context.
I am sure I will be discussing my experience developing this language more in later posts, but at a high level, it is a tree-walking interpreted programming language that is targeted primarily at solving Advent of Code problems.
The current working implementation is hosted on Node.js.
Due to this, I was able to garner inspiration from other custom runtime <a href=https://github.com/lambci/node-custom-lambda/blob/master/v12.x/bootstrap.js rel="external noopener" target=_blank>bootstrap processes</a> and how they handle the Lambda request lifecycle.
I was able to package up the <a href=https://github.com/eddmann/santa-lang-ts/blob/main/src/lambda/src/index.ts rel="external noopener" target=_blank>bootstrap</a> into a single executable thanks to <a href=https://www.npmjs.com/package/pkg rel="external noopener" target=_blank>pkg</a> and distribute it as a <a href=https://github.com/eddmann/santa-lang-ts/blob/main/Makefile#L50 rel="external noopener" target=_blank>layer</a> for my workflow to use.</p><p>This <em>side project</em> provided me with a great appreciation for the Custom Runtime API that AWS has developed, using HTTP as the common denominator for communication between the desired execution and host Lambda environment.</p><h2 id=the-workflow>The Workflow</h2><p>For managing and deploying the workflow, I opted to use the <a href=https://www.serverless.com/ rel="external noopener" target=_blank>Serverless Framework</a> and the de facto <a href=https://www.serverless.com/plugins/serverless-step-functions rel="external noopener" target=_blank>Serverless Step Functions</a> plugin.
This allowed me to co-locate the workflow and Lambda definitions, which I felt was very beneficial.</p><p>The resulting allocation and notification process was built up as follows:</p><p><a href=https://github.com/eddmann/step-function-secret-santa rel="external noopener" target=_blank><img src=workflow.svg alt="The Step Function workflow"></a></p><table><thead><tr><th>Function</th><th>Purpose</th><th>Language</th></tr></thead><tbody><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/parse-participants/ rel="external noopener" target=_blank>Parse Participants</a></td><td>Converts the CSV input supplied by the client&rsquo;s API Gateway request into a JSON form used throughout the workflow.</td><td>C# <code>dotnet6</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/validate-participants/ rel="external noopener" target=_blank>Validate Participants</a></td><td>Ensures that all supplied participant data is present and valid.</td><td>JavaScript <code>nodejs16.x</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/allocate/ rel="external noopener" target=_blank>Allocate</a></td><td>Allocates each participant to a random recipient.</td><td><a href=https://github.com/eddmann/santa-lang-ts/tree/main/src/lambda rel="external noopener" target=_blank>santa-lang</a> <code>provided.al2</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/validate-allocations/ rel="external noopener" target=_blank>Validate Allocations</a></td><td>Ensures that the supplied allocations are valid, taking into consideration participant exclusions.</td><td>Java <code>java11</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/store-allocations/ rel="external noopener" target=_blank>Store Allocations</a></td><td>Stores the allocations within a plain-text file S3 object for review.</td><td>Go <code>go1.x</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/notify-email/ rel="external noopener" target=_blank>Notify Email</a></td><td>Sends an email (via Mailgun) to the given participant with their allocated recipient&rsquo;s name.</td><td>Python <code>python3.9</code></td></tr><tr><td><a href=https://github.com/eddmann/step-function-secret-santa/tree/main/src/notify-sms/ rel="external noopener" target=_blank>Notify SMS</a></td><td>Sends an SMS (via Twilio) to the given participant with their allocated recipient&rsquo;s name.</td><td>Ruby <code>ruby2.7</code></td></tr></tbody></table><p>Many of the runtimes required their own specific packaging steps, either for pulling down dependencies and/or compilation.
As such, I opted to define/document these within <a href=https://github.com/eddmann/step-function-secret-santa/blob/main/Makefile rel="external noopener" target=_blank>Makefile targets</a>, which use Docker as the primary means of providing the required execution environment to deterministically package the artefacts.</p><h2 id=conclusion>Conclusion</h2><p>I really enjoyed building out this behaviour using AWS Step Functions and Lambda runtimes.
In the timeframe I gave myself, I was unable to develop a sufficient local execution environment to test the workflow using <a href=https://docs.aws.amazon.com/step-functions/latest/dg/sfn-local.html rel="external noopener" target=_blank>Step Functions Local</a>, but in future projects, I hope to explore this further.</p><p>The more I explored Step Functions and the available features/integrations, the more I realised that much of the behaviour I wished to achieve could be developed using high-level integrations that are already provided instead of relying solely on Lambda.
For example, I could instead possibly store the allocations within S3 using the built-in <a href=https://docs.aws.amazon.com/step-functions/latest/dg/supported-services-awssdk.html rel="external noopener" target=_blank>AWS SDK support</a> and send the SMS and emails via SNS and SES alike.</p><p>As the intent of this project was a combination of exploring Step Functions and Lambda runtimes, leaning on Lambda and a runtime to achieve these tasks felt right.
However, in a future incarnation, perhaps the goal could be to just leverage Step Functions altogether.
There is always next year&mldr; ðŸ˜‰</p></main><footer class=post__tags><a href=/archive/tag/aws>aws</a><a href=/archive/tag/lambda>lambda</a><a href=/archive/tag/step-function>step-function</a><a href=/archive/tag/santa-lang>santa-lang</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>