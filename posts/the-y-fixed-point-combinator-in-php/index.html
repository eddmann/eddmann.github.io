<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>The Y (Fixed-Point) Combinator in PHP - Edd Mann</title>
<meta name=description content="Discover how to implement the Y-combinator in PHP to achieve elegant recursion, memoization, and closure bindings for functional programming."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="The Y (Fixed-Point) Combinator in PHP"><meta itemprop=description content="A combinator is a type of higher-order function that can be used to express functions without the explicit use of variables. A fixed point is a value that remains unchanged by a function, satisfying the equation which can be found here. Using the Y-combinator allows us to essentially convert non-recursive code into a recursive counterpart (without directly using named recursion or iteration). To work its magic, the recursive function is computed as the fixed point of the non-recursive function."><meta itemprop=datePublished content="2014-04-01T00:00:00+00:00"><meta itemprop=dateModified content="2014-04-01T00:00:00+00:00"><meta itemprop=wordCount content="626"><meta itemprop=keywords content="Php,Functional-Programming"><meta property="og:url" content="https://eddmann.com/posts/the-y-fixed-point-combinator-in-php/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="The Y (Fixed-Point) Combinator in PHP"><meta property="og:description" content="A combinator is a type of higher-order function that can be used to express functions without the explicit use of variables. A fixed point is a value that remains unchanged by a function, satisfying the equation which can be found here. Using the Y-combinator allows us to essentially convert non-recursive code into a recursive counterpart (without directly using named recursion or iteration). To work its magic, the recursive function is computed as the fixed point of the non-recursive function."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-04-01T00:00:00+00:00"><meta property="article:modified_time" content="2014-04-01T00:00:00+00:00"><meta property="article:tag" content="Php"><meta property="article:tag" content="Functional-Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="The Y (Fixed-Point) Combinator in PHP"><meta name=twitter:description content="A combinator is a type of higher-order function that can be used to express functions without the explicit use of variables. A fixed point is a value that remains unchanged by a function, satisfying the equation which can be found here. Using the Y-combinator allows us to essentially convert non-recursive code into a recursive counterpart (without directly using named recursion or iteration). To work its magic, the recursive function is computed as the fixed point of the non-recursive function."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/the-y-fixed-point-combinator-in-php/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>The Y (Fixed-Point) Combinator in PHP</h1><time class=post__time>Apr 1, 2014</time></header><main class=prose><p>A combinator is a type of higher-order function that can be used to express functions without the explicit use of variables.
A fixed point is a value that remains unchanged by a function, satisfying the equation which can be found <a href=http://en.wikipedia.org/wiki/Fixed-point_combinator#Y_combinator rel="external noopener" target=_blank>here</a>.
Using the Y-combinator allows us to essentially convert non-recursive code into a recursive counterpart (without directly using named recursion or iteration).
To work its magic, the recursive function is computed as the fixed point of the non-recursive function.</p><p>You may be asking yourself why this is at all relevant in an imperative language such as PHP?
Well, with the introduction of Closures (since PHP 5.3) the language has slowly started to embrace many functional concepts.
One such concept, however, still requires some work to correctly implement in practice, namely recursive closures.
In a previous memoization <a href=/posts/implementing-and-using-memoization-in-php/>post</a> I highlighted a factorial implementation using such an approach, which required some PHP reference hackery to pass in the closure variable, as this would not typically be available in the function scope.
With a little research I stumbled upon the concept of Haskell&rsquo;s &lsquo;fix&rsquo; function which is generally known by the name &lsquo;Y-combinator&rsquo;.
I was keen to provide a thought experiment into how this could be implemented in the PHP language along with some interesting example use cases.</p><h2 id=basic-implementation>Basic Implementation</h2><p>Below is my first attempt at implementing the Y combinator in PHP, cheating a little by temporarily storing the fixed-point function in a variable to remove code duplication.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Y</span>($F)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    $x <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>($f) <span style=color:#66d9ef>use</span> ($F)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $F(<span style=color:#66d9ef>function</span>() <span style=color:#66d9ef>use</span> ($f)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>call_user_func_array</span>($f($f), <span style=color:#a6e22e>func_get_args</span>());
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $x($x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>This function can then be applied to solve the Fibonacci sequence, as shown below.
As you can see, the implementation provides us with the ability to reference the function by parameter instead of name (call-by-name), which in (typed) lambda calculus is not possible.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$fibonacci <span style=color:#f92672>=</span> <span style=color:#a6e22e>Y</span>(<span style=color:#66d9ef>function</span>($fib)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>($n) <span style=color:#66d9ef>use</span> ($fib)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>?</span> $fib($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> $fib($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> $n;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=adding-memoization>Adding Memoization</h2><p>With the basic concept now implemented, we can simply expand on this example to include the ability to memoize function call results.
Providing an initial empty cache, we first check to see if the hashed function call arguments have already been processed in the past; if so, we skip the function invocation step and return the answer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>YMemo</span>($F, $cache <span style=color:#f92672>=</span> [])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    $x <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>($f) <span style=color:#66d9ef>use</span> ($F, <span style=color:#f92672>&amp;</span>$cache)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $F(<span style=color:#66d9ef>function</span>() <span style=color:#66d9ef>use</span> ($f, <span style=color:#f92672>&amp;</span>$cache)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            $hash <span style=color:#f92672>=</span> <span style=color:#a6e22e>md5</span>(<span style=color:#a6e22e>serialize</span>(<span style=color:#a6e22e>func_get_args</span>()));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span> <span style=color:#a6e22e>isset</span>($cache[$hash])) {
</span></span><span style=display:flex><span>                $cache[$hash] <span style=color:#f92672>=</span> <span style=color:#a6e22e>call_user_func_array</span>($f($f, $cache), <span style=color:#a6e22e>func_get_args</span>());
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> $cache[$hash];
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $x($x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>As the added memoization is an implementation detail, the user-facing API has not changed and the function can again be expressed in the same manner as before (now with significant run-time speed increases).</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$fibonacci <span style=color:#f92672>=</span> <span style=color:#a6e22e>YMemo</span>(<span style=color:#66d9ef>function</span>($fib)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>($n) <span style=color:#66d9ef>use</span> ($fib)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>            <span style=color:#f92672>?</span> $fib($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> $fib($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>            <span style=color:#f92672>:</span> $n;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=using-closure-bindings>Using Closure Bindings</h2><p>Included more for its aesthetic appeal (syntactic sugar), we can take advantage of <a href=http://www.php.net/manual/en/closure.bind.php rel="external noopener" target=_blank>Closure Bindings</a> within PHP (since 5.4) to remove the need to explicitly pass in the fixed-point function.
Although this clearly violates the properties of a true Y-combinator, we are instead able to now simply invoke <code>$this</code> with the supplied arguments, providing a more user-friendly implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>Yish</span>($F)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    $x <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>($f) <span style=color:#66d9ef>use</span> ($F)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $F<span style=color:#f92672>-&gt;</span><span style=color:#a6e22e>bindTo</span>(<span style=color:#66d9ef>function</span>() <span style=color:#66d9ef>use</span> ($f)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>call_user_func_array</span>($f($f), <span style=color:#a6e22e>func_get_args</span>());
</span></span><span style=display:flex><span>        });
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $x($x);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We can use the example of the Fibonacci sequence again, to this time make use of the closure-bound implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$fibonacci <span style=color:#f92672>=</span> <span style=color:#a6e22e>Yish</span>(<span style=color:#66d9ef>function</span>($n)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $n <span style=color:#f92672>&gt;</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> $this($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> $this($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>)
</span></span><span style=display:flex><span>        <span style=color:#f92672>:</span> $n;
</span></span><span style=display:flex><span>});
</span></span></code></pre></div><h2 id=resources>Resources</h2><ul><li><a href=http://en.wikibooks.org/wiki/Haskell/Fix_and_recursion rel="external noopener" target=_blank>Haskell - Fix and Recursion</a></li><li><a href=http://php100.wordpress.com/2009/04/13/php-y-combinator/ rel="external noopener" target=_blank>Y-Combinator in PHP</a></li><li><a href=http://matt.might.net/articles/implementation-of-recursive-fixed-point-y-combinator-in-javascript-for-memoization/ rel="external noopener" target=_blank>Fixed-point combinators in JavaScript</a></li></ul></main><footer class=post__tags><a href=/archive/tag/php>php</a><a href=/archive/tag/functional-programming>functional-programming</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>