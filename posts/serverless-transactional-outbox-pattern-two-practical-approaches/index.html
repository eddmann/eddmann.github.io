<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Serverless Transactional Outbox Pattern: Two Practical Approaches - Edd Mann</title>
<meta name=description content="Explore two serverless implementations of the Transactional Outbox pattern using AWS technologies like DynamoDB Streams, EventBridge, and Fargate. Learn how to ensure reliable, atomic event publishing in distributed systems built on microservices and service-oriented architecture (SOA)."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Serverless Transactional Outbox Pattern: Two Practical Approaches"><meta itemprop=description content="In this post, I explore how to implement the Transactional Outbox pattern using serverless technologies. I compare two practical approaches: one using DynamoDB Streams for event publishing, and the other using a relational database with a polling worker. Each approach has trade-offs, but both ensure atomicity between data changes and event publication."><meta itemprop=datePublished content="2024-06-14T00:00:00+00:00"><meta itemprop=dateModified content="2024-06-14T00:00:00+00:00"><meta itemprop=wordCount content="1495"><meta itemprop=keywords content="Serverless,Aws,Microservices"><meta property="og:url" content="https://eddmann.com/posts/serverless-transactional-outbox-pattern-two-practical-approaches/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Serverless Transactional Outbox Pattern: Two Practical Approaches"><meta property="og:description" content="In this post, I explore how to implement the Transactional Outbox pattern using serverless technologies. I compare two practical approaches: one using DynamoDB Streams for event publishing, and the other using a relational database with a polling worker. Each approach has trade-offs, but both ensure atomicity between data changes and event publication."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-14T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-14T00:00:00+00:00"><meta property="article:tag" content="Serverless"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Microservices"><meta name=twitter:card content="summary"><meta name=twitter:title content="Serverless Transactional Outbox Pattern: Two Practical Approaches"><meta name=twitter:description content="In this post, I explore how to implement the Transactional Outbox pattern using serverless technologies. I compare two practical approaches: one using DynamoDB Streams for event publishing, and the other using a relational database with a polling worker. Each approach has trade-offs, but both ensure atomicity between data changes and event publication."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.a18bbea58d05187498ffb7d6a33b580609df2e92b988055a4b51e41596cc934e.css integrity="sha256-oYu+pY0FGHSY/7fWoztYBgnfLpK5iAVaS1HkFZbMk04="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/serverless-transactional-outbox-pattern-two-practical-approaches/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.da71ac9c7b8bd4e644618df0ab735aed1393aad3cb5e5c57e5adc300fe7c8209.js integrity="sha256-2nGsnHuL1OZEYY3wq3Na7ROTqtPLXlxX5a3DAP58ggk=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:serverless-transactional-outbox-pattern-two-practical-approaches>Serverless Transactional Outbox Pattern: Two Practical Approaches</h1><time datetime=2024-06-14T00:00:00Z class=published-at>Jun 14, 2024</time></header><main class=u-prose><p>If you&rsquo;ve ever wrestled with getting reliable, atomic event publishing out of your service-oriented architecture - especially in a serverless context - you&rsquo;ll know it&rsquo;s challenging.
I recently found myself pondering the classic <a href=https://microservices.io/patterns/data/transactional-outbox.html rel="external noopener" target=_blank>Transactional Outbox pattern</a>, and set out to explore how it might be implemented using modern serverless tooling.</p><p>In this post, I&rsquo;ll walk through two hands-on approaches:</p><ul><li>Using DynamoDB Streams for Change Data Capture (CDC)</li><li>Leveraging a Relational Database with a polling worker</li></ul><p>Both methods aim to ensure that state changes and their corresponding events are committed atomically - no more &ldquo;Oops, the write succeeded but the event didn&rsquo;t publish!&rdquo; moments.
You can find both of these implementations on <a href=https://github.com/eddmann/serverless-transactional-outbox-pattern rel="external noopener" target=_blank>GitHub</a>.</p><p>Let&rsquo;s dive in!</p><h2 id=why-transactional-outbox->Why Transactional Outbox? ðŸ¤”</h2><p>In service-oriented architectures (like microservices), publishing domain events reliably is essential for loosely coupled, event-driven systems.
But distributed transactions are notoriously tricky and can lead to all sorts of hair-pulling scenarios - like double-publishing or missing events if your database write succeeds but the event bus call fails (or vice versa).</p><p>The Transactional Outbox pattern sidesteps this by writing the event as data within the same transaction as your business entity.
Later, a separate process reads (or listens for) new events and publishes them to your event bus (e.g., <a href=https://aws.amazon.com/eventbridge/ rel="external noopener" target=_blank>AWS EventBridge</a>).
This ensures your state and events are always in sync.</p><h2 id=approach-1-dynamodb-streams--change-data-capture>Approach 1: DynamoDB Streams â€“ Change Data Capture</h2><p>I decided to start with DynamoDB, as it&rsquo;s a natural fit for serverless architectures.
My aim was to atomically create a product and an associated event, then let <a href=https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/Streams.html rel="external noopener" target=_blank>DynamoDB Streams</a> trigger the actual event publishing.</p><h3 id=how-it-works>How It Works</h3><ol><li><strong>Create Product Lambda:</strong> Uses a DynamoDB <a href=https://docs.aws.amazon.com/amazondynamodb/latest/APIReference/API_TransactWriteItems.html rel="external noopener" target=_blank>TransactWrite</a> to insert both the product and the outbox event atomically.</li><li><strong>Outbox Event Table:</strong> Dedicated DynamoDB table for storing outbox events.</li><li><strong>Event-Publishing Lambda:</strong> Subscribed to the outbox table&rsquo;s stream; publishes new events to EventBridge.</li></ol><h4 id=1-atomic-write-with-transactwrite>1. Atomic Write with TransactWrite</h4><p>Here&rsquo;s the core of <code>create-product.js</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>DynamoDBClient</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-sdk/client-dynamodb&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>DynamoDBDocumentClient</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>TransactWriteCommand</span>,
</span></span><span style=display:flex><span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-sdk/lib-dynamodb&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>randomUUID</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;crypto&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span>.<span style=color:#a6e22e>handle</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>randomUUID</span>(); <span style=color:#75715e>// Just for demo purposes
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>specversion</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;1.0&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>source</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;product&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;product.created&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>title</span> },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>time</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Date().<span style=color:#a6e22e>toISOString</span>(),
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dataschema</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>correlationid</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>dynamo</span>.<span style=color:#a6e22e>send</span>(
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>TransactWriteCommand</span>({
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>TransactItems</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Put</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>TableName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>PRODUCT_TABLE_NAME</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Item</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(), <span style=color:#a6e22e>title</span> },
</span></span><span style=display:flex><span>          },
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>          <span style=color:#a6e22e>Put</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>TableName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>EVENT_OUTBOX_TABLE_NAME</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Item</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(), <span style=color:#a6e22e>event</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>event</span>) },
</span></span><span style=display:flex><span>          },
</span></span><span style=display:flex><span>        },
</span></span><span style=display:flex><span>      ],
</span></span><span style=display:flex><span>    })
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>statusCode</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>201</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({ <span style=color:#a6e22e>title</span> }, <span style=color:#66d9ef>null</span>, <span style=color:#ae81ff>2</span>),
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>What&rsquo;s happening here?</strong>
I&rsquo;m using DynamoDB&rsquo;s cross-table transaction support to ensure that both the product and its event are written together.
Either both succeed, or neither does - a lovely property!</p><h4 id=2-event-outbox-table-with-streams>2. Event Outbox Table with Streams</h4><p>The DynamoDB table for the outbox is configured with a stream:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>EventOutboxTable</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>Type</span>: <span style=color:#ae81ff>AWS::DynamoDB::Table</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Properties</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>AttributeDefinitions</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>AttributeName</span>: <span style=color:#ae81ff>id</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>AttributeType</span>: <span style=color:#ae81ff>S</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>KeySchema</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>AttributeName</span>: <span style=color:#ae81ff>id</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>KeyType</span>: <span style=color:#ae81ff>HASH</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>BillingMode</span>: <span style=color:#ae81ff>PAY_PER_REQUEST</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>StreamSpecification</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>StreamViewType</span>: <span style=color:#ae81ff>NEW_IMAGE</span>
</span></span></code></pre></div><p>We specify <code>NEW_IMAGE</code> in the stream configuration because weâ€™re only interested in the new version of the item that was just inserted into the outbox table.
In this use case, we don&rsquo;t need to compare the new and old versions of the record - only the new event payload matters for publishing.</p><h4 id=3-lambda-publisher>3. Lambda Publisher</h4><p><code>event-outbox.js</code> listens to the outbox table&rsquo;s stream and pushes new events to EventBridge:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>EventBridgeClient</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>PutEventsCommand</span>,
</span></span><span style=display:flex><span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-sdk/client-eventbridge&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span>.<span style=color:#a6e22e>handle</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> <span style=color:#a6e22e>streamEvent</span> =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>record</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>streamEvent</span>.<span style=color:#a6e22e>Records</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>eventName</span> <span style=color:#f92672>!==</span> <span style=color:#e6db74>&#39;INSERT&#39;</span>) <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>parse</span>(<span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>dynamodb</span>.<span style=color:#a6e22e>NewImage</span>.<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>S</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>send</span>(
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PutEventsCommand</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Entries</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>EventBusName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>EVENT_BUS_ARN</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Source</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>source</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>DetailType</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>type</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Detail</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>record</span>.<span style=color:#a6e22e>dynamodb</span>.<span style=color:#a6e22e>NewImage</span>.<span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>S</span>,
</span></span><span style=display:flex><span>          },
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p><strong>Nice and simple:</strong> the Lambda is only triggered for new inserts, which represent new events needing to be published.</p><p>An added benefit of this approach is that we donâ€™t need to manage any continuously running polling task.
Instead, we get to leverage AWSâ€™s event-driven model, where the Lambda is automatically invoked when changes occur - similar to how SQS-triggered Lambdas work.
This reduces operational overhead and aligns well with serverless best practices.</p><h2 id=approach-2-relational-database--polling-worker>Approach 2: Relational Database â€“ Polling Worker</h2><p>For those of us still happily running Postgres or similar, I wanted to see how the outbox pattern could be realised with a traditional relational database - again, with serverless in mind.</p><h3 id=how-it-works-1>How It Works</h3><ol><li><strong>Create Product Lambda:</strong> Inserts both a product and an outbox event in a single transaction.</li><li><strong>Outbox Table:</strong> Holds the events to be published, with a <code>published_at</code> marker.</li><li><strong>Polling Worker:</strong> Runs in Fargate, periodically checks for unpublished events, and publishes them to EventBridge.</li></ol><h4 id=1-atomic-write-in-postgres>1. Atomic Write in Postgres</h4><p>Here&rsquo;s the gist of <code>create-product.js</code>:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>Pool</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;pg&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>randomUUID</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;crypto&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>pool</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Pool</span>({ <span style=color:#a6e22e>connectionString</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>DATABASE_URL</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>module</span>.<span style=color:#a6e22e>exports</span>.<span style=color:#a6e22e>handle</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>event</span>, <span style=color:#a6e22e>context</span>) =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>context</span>.<span style=color:#a6e22e>callbackWaitsForEmptyEventLoop</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>client</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>pool</span>.<span style=color:#a6e22e>connect</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#39;BEGIN&#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>title</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>randomUUID</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#39;INSERT INTO product (title) VALUES ($1)&#39;</span>, [<span style=color:#a6e22e>title</span>]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>specversion</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;1.0&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>source</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;product&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;product.created&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> { <span style=color:#a6e22e>title</span> },
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>time</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Date().<span style=color:#a6e22e>toISOString</span>(),
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>dataschema</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>correlationid</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#39;INSERT INTO event_outbox (event) VALUES ($1)&#39;</span>, [
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>event</span>),
</span></span><span style=display:flex><span>    ]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>query</span>(<span style=color:#e6db74>&#39;COMMIT&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> { <span style=color:#a6e22e>statusCode</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>201</span>, <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>({ <span style=color:#a6e22e>title</span> }, <span style=color:#66d9ef>null</span>, <span style=color:#ae81ff>2</span>) };
</span></span><span style=display:flex><span>  } <span style=color:#66d9ef>finally</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>release</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Both inserts happen within a single transaction - so we&rsquo;re safe from partial failures.</p><h4 id=2-polling-worker>2. Polling Worker</h4><p>The outbox worker (run as a Fargate task) keeps an eye on the outbox table, grabbing and publishing any unpublished events.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>EventBridgeClient</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>PutEventsCommand</span>,
</span></span><span style=display:flex><span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-sdk/client-eventbridge&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>Client</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;pg&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>async</span> () =&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>db</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Client</span>({ <span style=color:#a6e22e>connectionString</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>DATABASE_URL</span> });
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>connect</span>();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>eb</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>EventBridgeClient</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>while</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>result</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>query</span>(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;SELECT id, event FROM event_outbox WHERE published_at IS NULL LIMIT 1 FOR UPDATE&#39;</span>
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>rowCount</span> <span style=color:#f92672>===</span> <span style=color:#ae81ff>0</span>) {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>console</span>.<span style=color:#a6e22e>log</span>(<span style=color:#e6db74>&#39;.&#39;</span>);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>await</span> <span style=color:#66d9ef>new</span> Promise(<span style=color:#a6e22e>res</span> =&gt; <span style=color:#a6e22e>setTimeout</span>(<span style=color:#a6e22e>res</span>, <span style=color:#ae81ff>10_000</span>));
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>continue</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> { <span style=color:#a6e22e>id</span>, <span style=color:#a6e22e>event</span> } <span style=color:#f92672>=</span> <span style=color:#a6e22e>result</span>.<span style=color:#a6e22e>rows</span>[<span style=color:#ae81ff>0</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>eb</span>.<span style=color:#a6e22e>send</span>(
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PutEventsCommand</span>({
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Entries</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>          {
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>EventBusName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>EVENT_BUS_ARN</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Source</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>source</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>DetailType</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>type</span>,
</span></span><span style=display:flex><span>            <span style=color:#a6e22e>Detail</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>event</span>),
</span></span><span style=display:flex><span>          },
</span></span><span style=display:flex><span>        ],
</span></span><span style=display:flex><span>      })
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>await</span> <span style=color:#a6e22e>db</span>.<span style=color:#a6e22e>query</span>(
</span></span><span style=display:flex><span>      <span style=color:#e6db74>&#39;UPDATE event_outbox SET published_at = CURRENT_TIMESTAMP WHERE id = $1&#39;</span>,
</span></span><span style=display:flex><span>      [<span style=color:#a6e22e>id</span>]
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>})();
</span></span></code></pre></div><p><strong>A few thoughts:</strong></p><p>The worker is designed to only pick up events that havenâ€™t yet been published, as indicated by the <code>published_at IS NULL</code> condition.
After a successful publish to EventBridge, it marks the event as published by setting the <code>published_at</code> timestamp.
This simple approach ensures that each event is processed only once.</p><p>To safely support concurrent workers, the solution relies on PostgreSQLâ€™s <code>FOR UPDATE</code> clause.
This mechanism locks the selected rows during processing, so only one worker can claim and publish a given event at a time.
It effectively prevents duplicate or conflicting work without needing additional coordination infrastructure.</p><p>One important trade-off with this approach is that it requires a continuously running process.
This characteristic diverges from the typical &ldquo;scale to zero&rdquo; model associated with serverless compute options like AWS Lambda.
However, since the polling worker runs in a Fargate-managed container, it retains many of the serverless benefits - such as no infrastructure management and automatic scaling - even if the process itself does not scale down to zero.</p><h4 id=database-table-setup>Database Table Setup</h4><p>For reference, here&rsquo;s the SQL I used:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sql data-lang=sql><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> event_outbox (
</span></span><span style=display:flex><span>  id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  event JSONB <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>,
</span></span><span style=display:flex><span>  published_at <span style=color:#66d9ef>TIMESTAMP</span>
</span></span><span style=display:flex><span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>INDEX</span> event_outbox_unpublished_index <span style=color:#66d9ef>ON</span> event_outbox (id) <span style=color:#66d9ef>WHERE</span> (published_at <span style=color:#66d9ef>IS</span> <span style=color:#66d9ef>NULL</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>CREATE</span> <span style=color:#66d9ef>TABLE</span> product (
</span></span><span style=display:flex><span>  id SERIAL <span style=color:#66d9ef>PRIMARY</span> <span style=color:#66d9ef>KEY</span>,
</span></span><span style=display:flex><span>  title TEXT <span style=color:#66d9ef>NOT</span> <span style=color:#66d9ef>NULL</span>
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><h2 id=reflections--next-steps>Reflections & Next Steps</h2><p>As is often the case, I found the devil was in the details - especially around atomicity and failure recovery.
Both approaches have their quirks:</p><ul><li><strong>DynamoDB Streams</strong> are great for a full serverless experience, but you need to be mindful of stream retention and error handling.</li><li><strong>Polling Workers</strong> offer more control and visibility (and fit well with existing RDBMS investments), but introduce operational overhead.</li></ul><p>Regardless of the approach, it&rsquo;s important to ensure that your downstream consumers are <strong>idempotent</strong> - able to handle duplicate events gracefully.
While the polling worker leverages PostgreSQL&rsquo;s <code>FOR UPDATE</code> to prevent duplicate processing at the producer level, the event bus itself (such as EventBridge) does not guarantee deduplication or ordering.
These concerns should be addressed within each consumer to maintain robustness.</p><p>Beyond the two discussed implementations, there are several other viable approaches I feel would be worth exploring:</p><ul><li><strong>Relational Database - Lambda Trigger</strong>: Within Postgres, we could use <code>LISTEN</code>/<code>NOTIFY</code> to invoke a <a href=https://docs.aws.amazon.com/AmazonRDS/latest/UserGuide/PostgreSQL-Lambda.html rel="external noopener" target=_blank>Lambda function</a> once the transaction has been successfully committed, publishing the event to EventBridge.</li><li><strong>Single-Table DynamoDB Streams - Change Data Capture</strong>: A single-table DynamoDB design could store an <code>event</code> field within each inserted or updated record.
The stream processor would inspect this field and publish the appropriate event.</li></ul><p>It was rewarding to get both approaches working hands-on, and I&rsquo;m keen to explore the additional proposed approaches in the future.
If you&rsquo;re experimenting yourself, I recommend checking out <a href=https://neon.tech/ rel="external noopener" target=_blank>neon.tech</a> for quick Postgres setups, and reviewing AWS&rsquo;s <a href=https://docs.aws.amazon.com/prescriptive-guidance/latest/cloud-design-patterns/transactional-outbox.html rel="external noopener" target=_blank>prescriptive guidance</a> for broader architectural insights.</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/serverless>serverless</a></li><li><a href=/archive/tag/aws>aws</a></li><li><a href=/archive/tag/microservices>microservices</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/>Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB</a></li><li><a href=/posts/managing-long-running-aws-fargate-ecs-tasks-within-your-serverless-project/>Managing long-running AWS Fargate ECS tasks within your Serverless project</a></li><li><a href=/posts/separating-out-the-lambda-bref-runtime-from-your-projects-composer-dependencies/>Separating out the Lambda Bref runtime from your project's Composer dependencies</a></li><li><a href=/posts/mince-pie-challenge-viewing-and-removing-mince-pies-with-amazon-dynamodb/>Mince Pie Challenge: Viewing and Removing Mince Pies with Amazon DynamoDB</a></li><li><a href=/posts/mince-pie-challenge-adding-and-listing-mince-pies-with-amazon-dynamodb/>Mince Pie Challenge: Adding and Listing Mince Pies with Amazon DynamoDB</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>