<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution - Edd Mann</title>
<meta name=description content="This blog series details my experience rewriting the santa-lang interpreter in Rust. In this post, I delve into how the language and runtimes were built, tested, and distributed using a custom CI/CD pipeline."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution"><meta itemprop=description content="Now that the interpreter’s performance concerns had been addressed, it was time to decide how each of the available runtimes would be packaged and distributed. In the final post within the series, I will document how the language and runtimes were built, tested, and distributed using a custom CI/CD pipeline."><meta itemprop=datePublished content="2023-08-08T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-08T00:00:00+00:00"><meta itemprop=wordCount content="744"><meta itemprop=keywords content="Rust,Santa-Lang,Interpreter,Santa-Lang-in-Rust-Series"><meta property="og:url" content="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution"><meta property="og:description" content="Now that the interpreter’s performance concerns had been addressed, it was time to decide how each of the available runtimes would be packaged and distributed. In the final post within the series, I will document how the language and runtimes were built, tested, and distributed using a custom CI/CD pipeline."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-08T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-08T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Santa-Lang"><meta property="article:tag" content="Interpreter"><meta property="article:tag" content="Santa-Lang-in-Rust-Series"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution"><meta name=twitter:description content="Now that the interpreter’s performance concerns had been addressed, it was time to decide how each of the available runtimes would be packaged and distributed. In the final post within the series, I will document how the language and runtimes were built, tested, and distributed using a custom CI/CD pipeline."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.baab6396a366fd74d3313a1564d960d606740e4ac77db11beb667cfa8dbf5b25.css integrity="sha256-uqtjlqNm/XTTMToVZNlg1gZ0DkrHfbEb62Z8+o2/WyU="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.c886797fe1c76f3a5cace46b687d1d56b58c9e0df4f37c62bffbcda7eb40fce8.js integrity="sha256-yIZ5f+HHbzpcrORraH0dVrWMng3083xiv/vNp+tA/Og=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution>Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution</h1><time datetime=2023-08-08T00:00:00Z class=time>Aug 8, 2023</time></header><main class=u-prose><p>Now that the interpreter&rsquo;s performance concerns had been addressed, it was time to decide how each of the available runtimes would be packaged and distributed.
In the final post within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>, I will document how the language and runtimes were built, tested, and distributed using a custom CI/CD pipeline.</p><h2 id=pipeline>Pipeline</h2><p>As documented in a <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/>previous post</a>, the project has been structured as a monorepo Cargo workspace, with the language and runtimes being separated into different packages.
This allows the packages to be built and tested in isolation from one another.
To provide a deterministic build and release process, I created a <a href=https://github.com/eddmann/santa-lang-rs/tree/d175c6a692265d2b66355e17e7cbe2f51f36b3d1/.github rel="external noopener" target=_blank>CI/CD pipeline</a> using <a href=https://docs.github.com/en/actions/using-workflows rel="external noopener" target=_blank>GitHub Action workflows</a>.
I also opted to add a GitHub Action called <a href=https://github.com/release-drafter/release-drafter rel="external noopener" target=_blank>Release Drafter</a> to the project.
This provides automatic collection and creation of relevant release notes and semantic versioning based on merged GitHub pull requests (and tags).</p><p>I thought the best way to describe this pipeline was visually.
Below is a diagram depicting the journey of a change that has been merged into the <code>main</code> branch, being built, tested, and distributed to relevant external package managers:</p><p><a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline.png><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_99059595c91c8391.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_9e0ca57dd4f0cf20.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_4d3b49c616fe7328.webp 1400w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_332dc4d0c49dd22b.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_adaa1ae27198db60.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_24055354078ef74a.jpg 1400w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/pipeline_hu_adaa1ae27198db60.jpg alt="CI/CD Pipeline" loading=lazy></picture></a></p><ol><li>Once a development branch is <em>passing</em>, it can be merged into the <code>main</code> branch. Once merged, the test suite is run (again), and the <code>draft-release</code> branch is updated to point to this merged commit.</li><li>Upon changes appearing in the <code>draft-release</code> branch, the draft GitHub release notes and version are created/updated using Release Drafter. From here, the runtime binary artefacts are built and attached to the draft GitHub release.</li><li>With the draft GitHub release now updated, the associated artefacts can be downloaded for local testing/validation.</li><li>When happy with the draft release, it can then be published. Upon publishing the release, it in turn publishes all the relevant artefacts to the external package managers (i.e. Docker Hub, NPM, and AWS Lambda layers).</li></ol><p>I am very happy with the resulting CI/CD pipeline, with all the build steps being broken out into separate <a href=https://github.com/eddmann/santa-lang-rs/tree/d175c6a692265d2b66355e17e7cbe2f51f36b3d1/.github/workflows rel="external noopener" target=_blank>workflow files</a> for readability.
These <code>build-*.yml</code> workflows require a supplied <em>release version</em> argument to correctly build the specific runtime artefact.</p><p>I had hoped to be able to keep all the build steps as deterministic Docker entries within the Makefile.
However, I had issues with compiling the macOS and WASM binaries using this route.
As such, the CLI and WASM both use the native GitHub Action runners&rsquo; environment.
The CLI uses a workflow <a href=https://github.com/eddmann/santa-lang-rs/blob/d175c6a692265d2b66355e17e7cbe2f51f36b3d1/.github/workflows/build-cli.yml#L45 rel="external noopener" target=_blank>job matrix</a> to compile and package the binary artefacts per target operating system.</p><p>With this pipeline now in place, easing the future process of making reliable changes to the project, it was time to step back and reflect on the project as a whole.</p><h2 id=conclusion>Conclusion</h2><p>What a fun project!
What was originally planned to take up to a month ended up being a multi-month personal project, where I was able to delve into not only the Rust language but also many aspects of performance benchmarking and profiling in general.</p><p>I am very happy with the resulting interpreter and the many different runtimes I was able to build along the way.
Being able to leverage Cargo&rsquo;s rich package ecosystem played a big part in making this as enjoyable as it was.
I also found that linting the code with <a href=https://doc.rust-lang.org/clippy/ rel="external noopener" target=_blank>Clippy</a> and formatting it with <a href=https://github.com/zBaitu/rsfmt rel="external noopener" target=_blank>rsfmt</a> greatly helped the development process.
Upon reflection, it would be good to revise the amount of <code>Rc&lt;RefCell&lt;T>></code> usage within the Evaluator, along with refactoring parts of the Lazy Sequence implementation.
These are areas I would like to revisit after gaining more experience with Rust in future projects.</p><p>I also really enjoyed <a href=https://eddmann.com/santa-lang/>documenting</a> the language and runtimes using MkDocs, being able to provide executable examples throughout, thanks to the WASM runtime.
It sounds a little odd, but having documentation such as this makes it feel more like a &lsquo;real&rsquo; language.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_e2a2013bcc4886b3.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_1e4e863138e9b43b.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_34c41f200b77cb83.webp 1400w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_4744f7710e043e84.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_f213b655306ef6d1.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_4b1f518e4a425dbc.jpg 1400w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/documentation_hu_f213b655306ef6d1.jpg alt=Documentation loading=lazy></picture></p><p>Although I managed to achieve considerable performance gains, I still think there is plenty more that can be done!
Evaluation is still performed using a tree-walking interpreter, and there is only so much that can be achieved using this model of execution.
If I were to delve further into performance, I would perhaps look at <a href=https://blog.cloudflare.com/building-fast-interpreters-in-rust/#dynamic-dispatch-and-closures-to-the-rescue rel="external noopener" target=_blank>compiling to closures</a>, the addition of a JIT, and even implementing a full-blown virtual machine.
One thing I have realised since jumping into language design and evaluation is the sheer number of options and considerations at play, all coming with their own complexities and trade-offs.</p><p>To conclude, I look forward to using this version of santa-lang in Advent of Code calendars to come!</p></main><footer class=post__tags><a href=/archive/tag/rust>rust</a><a href=/archive/tag/santa-lang>santa-lang</a><a href=/archive/tag/interpreter>interpreter</a><a href=/archive/tag/santa-lang-in-rust-series>santa-lang-in-rust-series</a></footer></article><div class="related-posts u-prose"><h3>Related Posts</h3><ul><li><a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/>Rewriting the santa-lang Interpreter in Rust, Part 3 - Performance</a></li><li><a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/>Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes</a></li><li><a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/>Rewriting the santa-lang Interpreter in Rust, Part 1 - Implementing the Core</a></li><li><a href=/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/>Solving the Advent of Code 2022 calendar using my own programming language, santa-lang</a></li><li><a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/>Designing santa-lang, a language for solving Advent of Code puzzles</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>