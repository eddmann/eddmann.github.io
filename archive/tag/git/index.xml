<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Git on Edd Mann</title><link>https://eddmann.com/archive/tag/git/</link><description>Recent content in Git on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Wed, 08 Apr 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/git/index.xml" rel="self" type="application/rss+xml"/><item><title>Simplify Git commit fixes using fixup and auto-squash</title><link>https://eddmann.com/posts/simplify-git-commit-fixes-using-fixup-and-auto-squash/</link><pubDate>Wed, 08 Apr 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/simplify-git-commit-fixes-using-fixup-and-auto-squash/</guid><description>&lt;p>Throughout a project I will typically make commits that could be categorised as fixes to previous commits.
To help highlight such commits I would follow the pattern of starting the message with &amp;lsquo;fix: &amp;hellip;&amp;rsquo;, making the final rebase step (before merging into master) easier.
However, as time passed, it became more challenging to determine which fix commits were related to previous commits.&lt;/p></description></item><item><title>The Internals of Git</title><link>https://eddmann.com/posts/the-internals-of-git/</link><pubDate>Sat, 27 Dec 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/the-internals-of-git/</guid><description>&lt;p>I have been using Git for the past couple of years, and I remember how long it took me to get my head around the workflow.
Throughout the past couple of months, thanks to a couple of &lt;a href="http://ftp.newartisans.com/pub/git.from.bottom.up.pdf" rel="external noopener" target="_blank">well&lt;/a> &lt;a href="http://mrchlblng.me/2014/09/practical-git-introduction/" rel="external noopener" target="_blank">timed&lt;/a> &lt;a href="http://episodes.gitminutes.com/" rel="external noopener" target="_blank">findings&lt;/a>, I have gained an interest in how Git works internally.
In this post I hope to explain how Git uses well-designed, composed low-level commands to create the high-level actions we use on a day-to-day basis.&lt;/p></description></item><item><title>Move Last Git Commit to New or Existing Branch</title><link>https://eddmann.com/posts/move-last-git-commit-to-new-or-existing-branch/</link><pubDate>Fri, 24 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/move-last-git-commit-to-new-or-existing-branch/</guid><description>&lt;p>Sometimes you may begin work on a specific branch (say &amp;lsquo;master&amp;rsquo;) and realise that it would be better off to move these commits into a separate branch.
This can be simply achieved using Git, either to a brand new branch or an existing branch.&lt;/p></description></item><item><title>Changing the Timestamp of a Previous Git Commit</title><link>https://eddmann.com/posts/changing-the-timestamp-of-a-previous-git-commit/</link><pubDate>Sat, 14 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/changing-the-timestamp-of-a-previous-git-commit/</guid><description>&lt;p>Git has two different types of timestamp associated with a commit.
Although both typically hold the same value, they are used in subtly different ways.
The author (GIT_AUTHOR_DATE) is the user who originally created the work (i.e. a patch), whereas the committer (GIT_COMMITTER_DATE) is the user who last applied the work (i.e. applied patch or rebase).
The author date is the one displayed when the log is accessed.
However, the commit date is used when applying the &lt;code>--since&lt;/code> and &lt;code>--until&lt;/code> filter options, which seems a little odd.
To avoid confusion, you can include the committer date within your log display by setting the &lt;code>--format&lt;/code> option.&lt;/p></description></item><item><title>Personal Git Server with Gitolite</title><link>https://eddmann.com/posts/personal-git-server-with-gitolite/</link><pubDate>Mon, 25 Nov 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/personal-git-server-with-gitolite/</guid><description>&lt;p>Github and Bitbucket are great, however, there may come a time when you wish to set up a personal Git server.
There are many reasons for this, you may legally not be permitted to host the repository externally, or you want to have more control over access privileges.
&lt;a href="http://gitolite.com/gitolite/index.html" rel="external noopener" target="_blank">Gitolite&lt;/a> is here to help remedy this desire, allowing you to simply set up Git hosting on a central server with fine-grained access control capabilities.&lt;/p></description></item><item><title>Making Gitflow the way you want it to</title><link>https://eddmann.com/posts/making-gitflow-the-way-you-want-it-to/</link><pubDate>Sun, 26 Aug 2012 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/making-gitflow-the-way-you-want-it-to/</guid><description>&lt;p>I have been a part-time Git user for a little over a year now.
Before this, I had dabbled with using &lt;a href="http://subversion.apache.org/" rel="external noopener" target="_blank">Subversion&lt;/a> but never for anything too serious.
I say &amp;lsquo;part-time&amp;rsquo; because, throughout the year, I never fully got to grips with all the ideologies and tools available to support my development lifecycle process.
This was particularly evident with regard to branching.&lt;/p></description></item></channel></rss>