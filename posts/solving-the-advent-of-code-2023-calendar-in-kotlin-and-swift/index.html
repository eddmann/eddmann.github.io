<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Solving the Advent of Code 2023 calendar in Kotlin and Swift - Edd Mann</title>
<meta name=description content="This post documents my experience solving the Advent of Code 2023 calendar using both Kotlin and Swift."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Solving the Advent of Code 2023 calendar in Kotlin and Swift"><meta itemprop=description content="Another year, another Advent of Code, another excuse to explore new languages. After my recent exploration into PWAs this past year, I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development. Before delving into the mobile domain, I wanted to see what each language had to offer. In this post, I will document my experience completing the Advent of Code 2023 calendar in both Kotlin and Swift."><meta itemprop=datePublished content="2024-01-15T00:00:00+00:00"><meta itemprop=dateModified content="2024-01-15T00:00:00+00:00"><meta itemprop=wordCount content="2438"><meta itemprop=keywords content="Advent-of-Code,Swift,Kotlin"><meta property="og:url" content="https://eddmann.com/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Solving the Advent of Code 2023 calendar in Kotlin and Swift"><meta property="og:description" content="Another year, another Advent of Code, another excuse to explore new languages. After my recent exploration into PWAs this past year, I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development. Before delving into the mobile domain, I wanted to see what each language had to offer. In this post, I will document my experience completing the Advent of Code 2023 calendar in both Kotlin and Swift."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-01-15T00:00:00+00:00"><meta property="article:modified_time" content="2024-01-15T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Swift"><meta property="article:tag" content="Kotlin"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solving the Advent of Code 2023 calendar in Kotlin and Swift"><meta name=twitter:description content="Another year, another Advent of Code, another excuse to explore new languages. After my recent exploration into PWAs this past year, I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development. Before delving into the mobile domain, I wanted to see what each language had to offer. In this post, I will document my experience completing the Advent of Code 2023 calendar in both Kotlin and Swift."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.6d190498ff3baf1368714fe1529fcd878be7d3fe03d6a837007b47c1a5dbe5b7.css integrity="sha256-bRkEmP87rxNocU/hUp/Nh4vn0/4D1qg3AHtHwaXb5bc="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.c886797fe1c76f3a5cace46b687d1d56b58c9e0df4f37c62bffbcda7eb40fce8.js integrity="sha256-yIZ5f+HHbzpcrORraH0dVrWMng3083xiv/vNp+tA/Og=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift>Solving the Advent of Code 2023 calendar in Kotlin and Swift</h1><time datetime=2024-01-15T00:00:00Z class=time>Jan 15, 2024</time></header><main class=u-prose><p>Another year, another <a href=https://adventofcode.com/2023 rel="external noopener" target=_blank>Advent of Code</a>, another excuse to explore new languages.
After my recent exploration into <a href=/posts/building-a-secret-santa-draw-pwa-in-react-and-typescript/>PWAs</a> this past year, I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development.
Before delving into the mobile domain, I wanted to see what each language had to offer.
In this post, I will document my experience completing the Advent of Code 2023 calendar in both <a href=https://github.com/eddmann/advent-of-code/tree/master/2023/kotlin rel="external noopener" target=_blank>Kotlin</a> and <a href=https://github.com/eddmann/advent-of-code/tree/master/2023/swift rel="external noopener" target=_blank>Swift</a>.</p><p><picture><source type=image/webp srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_eecea8f4065310f9.webp 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_aa2a53c76a6ec471.webp 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_f717cdd8203a1c1e.webp 1400w"><source type=image/jpeg srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_d4b9283c04685e76.jpg 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_82a45d14d42cfbe8.jpg 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_1c3c977b9ba9eed9.jpg 1400w"><img src=/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs_hu_82a45d14d42cfbe8.jpg alt="Kotlin vs Swift" loading=lazy></picture></p><h2 id=first-impressions>First Impressions</h2><p>From the outset, I found that both languages were very comparable in syntax and style - both modelling problems using similar paradigms: OO with a blend of functional primitives.
Both also follow suit in that the language developer also provides the <em>de facto</em> IDE in which to work; for Kotlin (created by JetBrains), it is <a href=https://www.jetbrains.com/idea/ rel="external noopener" target=_blank>IntelliJ IDEA</a>, and for Swift (created by Apple), it is <a href=https://developer.apple.com/xcode/ rel="external noopener" target=_blank>Xcode</a>.
Throughout the month, I found myself much more productive within IntelliJ than Xcode.
I should caveat that I have been using JetBrains&rsquo; suite of IDEs (PHPStorm in particular) for many years.
However, I found that Xcode would randomly crash on me (not what you want from an IDE), even in my limited time using it.
I remember watching a <a href=https://frontendmasters.com/courses/swift-ios/ rel="external noopener" target=_blank>video series</a> on iOS development last year, which mentioned that this was deemed to be <em>expected behaviour</em> when working in Xcode ðŸ˜¬.</p><h3 id=starter-templates>Starter Templates</h3><p>Both language developers have (rather handily) published Advent of Code starter templates (<a href=https://github.com/kotlin-hands-on/advent-of-code-kotlin-template rel="external noopener" target=_blank>Kotlin</a>, <a href=https://github.com/apple/swift-aoc-starter-example rel="external noopener" target=_blank>Swift</a>), which provide a convenient means of getting started tackling each daily problem.
It is good to see language developers investing time in this, as Advent of Code is a great tool to help advertise a language - it is the time developers typically get to explore different languages (me being a case in point).
I found the REPL provided by the Kotlin starter template to be better.
Having the ability to run each day from within the IDE (using the gutter <em>play</em> button) was very useful, and it felt as though, during problem-solving, it was quicker to compile (perhaps due to incremental compilation?).
I had initially looked at using <a href=https://developer.apple.com/swift-playgrounds/ rel="external noopener" target=_blank>Swift Playgrounds</a> to iterate on the solutions within Xcode but found that it was very unperformant due to the way it has to instrument the code ðŸ˜”.
After some research, I found there were some <em>tricks</em> to make it more performant, but I did not want to rewrite the code to appease the IDE.</p><h2 id=today-i-learned>Today I learned&mldr;</h2><p>Each day, I wrote down my learnings and insights into each language as I went about solving the problems.
Below, I have documented these findings, paying close attention to the use of the language itself over the actual problems they were trying to solve.</p><h3 id=day-1-trebuchet>Day 1: Trebuchet?!</h3><p>From the outset, I decided to add extension methods within both languages to help parse the input.
This included <code>lines</code>, <code>ints</code>, and <code>longs</code> (in the case of Kotlin).
Having to explicitly specify longs (64-bit values) within Kotlin felt like it was one overflow away from being a problem.
This must be due to being hosted on the JVM.</p><p>In addition to this, I also found that tuple declaration (<code>Pair</code>) within Kotlin seemed a little verbose, and the subsequent infix <code>to</code> syntax was odd.
I understand that this is most likely due to not wanting to add additional syntax to the language.
However, Swift tuples are much more readable.</p><h3 id=day-2-cube-conundrum>Day 2: Cube Conundrum</h3><p>I found that Kotlin had a far richer standard library, which, when solving problems such as Advent of Code, can come in very handy!
It was also interesting clicking through on a given method and seeing that the supporting code was all readable Kotlin.
It was cool to see how the language had bootstrapped itself.
For example, there was no built-in <code>sum</code> method within Swift, something which you are required to include using an <a href=https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/Utils.swift rel="external noopener" target=_blank>extension method</a>.</p><h3 id=day-3-gear-ratios>Day 3: Gear Ratios</h3><p>I found that structures (in Swift) and <a href=https://kotlinlang.org/docs/data-classes.html rel="external noopener" target=_blank>data classes</a> (within Kotlin) are a very concise means of creating data objects.
Kotlin additionally provides capabilities to compare and copy instances of such classes, which removes a lot of boilerplate.</p><h3 id=day-4-scratchcards>Day 4: Scratchcards</h3><p>I had fun creating an infix operator within Kotlin and Swift to calculate the power of a given number, opting to use the same <code>**</code> operator that Python does.
I found that it was incredibly cheap to add such powerful capabilities.
However, it did make me start to worry about how easy it could be to abuse (<em>cough</em> Scala <em>cough</em>).</p><h3 id=day-5-if-you-give-a-seed-a-fertilizer>Day 5: If You Give A Seed A Fertilizer</h3><p>This day provided me with a perfect excuse to explore both languages&rsquo; concurrency capabilities.
They both follow similar asynchronous execution models (<code>async</code>, <code>await</code>), which provide an ideal level of abstraction.
Within part two, there was an <em>intelligent</em> way to solve the problem and a brute-force means.
Splitting up the required work led to a great use case for solving the problem in parallel.</p><p>Swift has come on leaps and bounds from the time I remember having to use <a href=https://en.wikipedia.org/wiki/Grand_Central_Dispatch rel="external noopener" target=_blank>Grand Central Dispatch</a>.
Having explored Kotlin&rsquo;s concurrency model first and finding Java&rsquo;s <code>parallelStream</code>, I decided to implement a similar abstraction within Swift (<code>parallelMap</code>) using a generic <em>Sequence</em> extension method.
It was very cool to see all my machine&rsquo;s cores being utilised with very little code.</p><h3 id=day-6-wait-for-it>Day 6: Wait For It</h3><p>Something that I knew I wanted to include in <em>santa-lang</em> (borrowed from Kotlin and Swift) was trailing Lambda expression/Closures syntax.
I used this syntax heavily throughout the month, and building function APIs that took advantage of this syntax provides for a very readable DSL.</p><p>In addition to this, explicitly having to define Swift&rsquo;s arguments during invocation (unless explicitly declaring not to) was initially odd to me.
However, the parameter names being part of the method/function signature brought with it increased expressiveness in the code.</p><h3 id=day-7-camel-cards>Day 7: Camel Cards</h3><p>This day allowed me to use Kotlin&rsquo;s and Swift&rsquo;s advanced pattern-matching capabilities within <code>switch</code> and <code>when</code> expressions, respectively.
I was able to pattern match on lists, including values found within the data structure itself.
On top of this, I was also able to abstract out the concept of a <code>Hand</code> into a type that could encapsulate how it was compared in both languages.
This led to a very concise solution whereby the input was passed into <code>Hand</code>s and then sorted before performing several collection operations on the output.</p><h3 id=day-8-haunted-wasteland>Day 8: Haunted Wasteland</h3><p>I found that the arguments of a Lambda expression/Closure appearing after the curly brace grew on me.
I was initially opposed to this when designing <em>santa-lang</em>, but I can see how it aids in parsing the syntax whilst maintaining readability.</p><h3 id=day-9-mirage-maintenance>Day 9: Mirage Maintenance</h3><p>As explained before, Kotlin has a very rich standard library and provides the ability to generate an <em>infinite</em> sequence.
Along with this, it includes functions (e.g. <code>zipWithNext</code> and <code>takeIf</code>) that feel like they have been added just for Advent of Code?!
This day&rsquo;s Kotlin solution was by far my favourite solution for the entire calendar.</p><h3 id=day-10-pipe-maze>Day 10: Pipe Maze</h3><p>I built up the solution using a composition of several smaller functions.
I was able to use the <code>let</code> function within Kotlin to achieve the desired composition that I had become accustomed to within <em>santa-lang</em>.
However, Swift did not provide such functionality, but never fear - this was another good excuse to implement another operator (<code>>>></code>).</p><h3 id=day-11-cosmic-expansion>Day 11: Cosmic Expansion</h3><p>This day highlighted more of Kotlin&rsquo;s extensive standard library, including <code>mapIndexedNotNull</code>, <code>mapNotNull</code>, <code>all</code>, and <code>count</code>.</p><h3 id=day-12-hot-springs>Day 12: Hot Springs</h3><p>I found that Kotlin had better support for treating composed data structures as values.
For example, I was able to make a <code>Pair&lt;String, List&lt;Int>></code> a <em>hashable</em> map key, whereas in Swift, I had to implement the <code>Hashable</code> protocol, which was a pain.</p><p>I was also a big fan of the <code>if let</code> syntax within Swift and felt this would be a welcome addition to Kotlin.
Combined with <code>Optional</code> typing constructs, this provided an easy means of unwrapping values with scoped variables.</p><h3 id=day-13-point-of-incidence>Day 13: Point of Incidence</h3><p>I found that number ranges are very expressive.
I liked how Kotlin provided <code>downTo</code> to declare a decreasing range.
This also provided an opportune place to experiment with Kotlin&rsquo;s syntax support for omitting the function invocation from the call (i.e. <code>10.downTo(1)</code> being equivalent to <code>10 downTo 1</code>).</p><h3 id=day-14-parabolic-reflector-dish>Day 14: Parabolic Reflector Dish</h3><p>Type aliases are awesome!
They allow you to cheaply declare data types using the language of the problem domain.
For example, I was able to define a generic <code>Matrix&lt;T></code> (<code>List&lt;List&lt;T>></code>) type and compose a <code>Dish</code> (<code>Matrix&lt;Char></code>) type in this day&rsquo;s solution.</p><h3 id=day-15-lens-library>Day 15: Lens Library</h3><p>I found that Kotlin provides better overall immutable data structure support.
I was initially impressed with Swift&rsquo;s use of <code>var</code>/<code>let</code> declarations to dictate whether the data structure itself was immutable or not.
However, I fell into a problem regarding nested mutable data structure definitions.
The means to overcome this problem was rather ugly.</p><h3 id=day-16-the-floor-will-be-lava>Day 16: The Floor Will Be Lava</h3><p>Apple provides a <a href=https://github.com/apple/swift-collections rel="external noopener" target=_blank>Collections</a> library, which includes many useful data structures that come in handy when solving Advent of Code problems.
One such collection was a double-ended queue (Deque), which I was able to make use of on this day.</p><h3 id=day-17-clumsy-crucible>Day 17: Clumsy Crucible</h3><p>It was fun being able to use Java&rsquo;s <a href=https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html rel="external noopener" target=_blank>Priority Queue</a> implementation within Kotlin.
One of the advantages of being hosted on the JVM is that you can use libraries that are already available.
The syntax for interacting with these libraries is also very clean.
For example, you can provide a Kotlin lambda expression for the comparator.
Sadly, Swift does not provide such a data structure, so I had to go about building a heap-backed <a href=https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/PriorityQueue.swift rel="external noopener" target=_blank>Priority Queue</a>, which was fun.</p><h3 id=day-18-lavaduct-lagoon>Day 18: Lavaduct Lagoon</h3><p>I originally had written down how I wished that Swift had <code>switch</code>/<code>if</code> expression support, similar to Kotlin.
However, upon writing this post, I have seen that Swift 5.9 has <a href=https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md rel="external noopener" target=_blank>support</a> for it, so I just need to upgrade from 5.8!</p><h3 id=day-19-aplenty>Day 19: Aplenty</h3><p>I had fun building out an enumerated <code>Workflow</code> type and being able to destructure the type using a <code>switch</code> statement in Swift.
There was also more internal debate about Kotlin&rsquo;s standard library - Kotlin&rsquo;s <code>mapIndexed</code> vs Swift&rsquo;s <code>enumerated().map()</code>.
The purist in me likes the latter.
However, the developer who is already akin to the language and just wants to solve the problem likes the ease of the former. ðŸ¤”</p><h3 id=day-20-pulse-propagation>Day 20: Pulse Propagation</h3><p>I cannot believe it took me until day 20 to find <code>buildMap</code> within Kotlin.
This provides the ability to construct a <code>Map</code> in a mutable/imperative manner, with the resulting value being returned to the caller as an immutable data structure.
I am a big fan of this explicit mutation, all thanks to implicit lambda contexts for providing access to the data structure methods.</p><h3 id=day-21-step-counter>Day 21: Step Counter</h3><p>Now that I had found <code>buildMap</code>, it was time to use <code>buildSet</code> within Kotlin as well!</p><h3 id=day-22-sand-slabs>Day 22: Sand Slabs</h3><p>The ability to add extension methods to existing data types plays a big role in both languages.
Although I refrained from using them too frequently throughout the calendar (excluding utility methods), there were some days when I felt they aided in expressing the solution.
One such example of this was in today&rsquo;s <code>Set&lt;T>.canDrop</code> definition.</p><h3 id=day-23-a-long-walk>Day 23: A Long Walk</h3><p>Some syntactic sugar that Kotlin could adopt from Swift would be the ability to omit verbose enumeration definitions.
The compiler is aware of the type that is required.
As such, omitting the enumerated class and only providing the value aids readability - for example, <code>.NORTH</code> instead of <code>Point.NORTH</code>.</p><h3 id=day-24-never-tell-me-the-odds>Day 24: Never Tell Me The Odds</h3><p>Part two was a tough maths problem, and I sadly had to reach out to the subreddit for help.
It did, however, provide me with a reason to explore interacting with third-party libraries within both languages by running the <a href=https://github.com/Z3Prover/z3 rel="external noopener" target=_blank>Z3 problem solver</a>.
There are official Z3 Java bindings, which, thanks to Kotlin&rsquo;s interop, I was able to use seamlessly.
Fortunately, within Swift, someone had worked on building a <a href=https://github.com/LuizZak/swift-z3 rel="external noopener" target=_blank>wrapper</a> that exposed a great Swift interface for this C library.</p><h3 id=day-25-snowverload>Day 25: Snowverload</h3><p>Today was the day I attempted to explore implementing a generic solution to using a tuple as a hash value within Swift - so worth it on the last day&mldr;
Regarding the Kotlin solution, along with implementing Karger&rsquo;s algorithm, I decided to try solving it using a Graphviz visualisation, which I thought would make for a cool diagram to include in this article.</p><p><picture><source type=image/webp srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_5a42689976291f3f.webp 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_671c36f80d3b2ce7.webp 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_942d26bb643ae6b8.webp 957w"><source type=image/jpeg srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_a8aa51d489159a49.jpg 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_9f22456e8e30d80b.jpg 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_1401fd39bc233bb7.jpg 957w"><img src=/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25_hu_9f22456e8e30d80b.jpg alt="Day 25 Graphviz Solution" loading=lazy></picture></p><h2 id=santa-lang-dsl-in-kotlin>santa-lang DSL in Kotlin</h2><p>As an additional exploration, I wished to look into Kotlin&rsquo;s <a href=https://kotlinlang.org/docs/type-safe-builders.html rel="external noopener" target=_blank>type-safe builders</a>, which provide you with a means to implement your own DSL on top of the language.
I felt that it could be possible to implement the <a href=https://eddmann.com/santa-lang/runner/>day solution structure</a> I had designed for <em>santa-lang</em> within Kotlin itself.</p><pre tabindex=0><code>fun main() = solution {
    fun calibrate(values: List&lt;String&gt;) = values.sumOf { value -&gt;
        val digits = value.replace(Regex(&#34;\\D&#34;), &#34;&#34;)
        &#34;${digits.first()}${digits.last()}&#34;.toInt()
    }

    input {
        readInput(&#34;Day01&#34;)
    }

    partOne {
        calibrate(input.lines())
    }

    partTwo {
        val translations = mapOf(
            &#34;one&#34; to &#34;o1e&#34;,
            &#34;two&#34; to &#34;t2o&#34;,
            &#34;three&#34; to &#34;t3e&#34;,
            &#34;four&#34; to &#34;4&#34;,
            &#34;five&#34; to &#34;5e&#34;,
            &#34;six&#34; to &#34;6&#34;,
            &#34;seven&#34; to &#34;7n&#34;,
            &#34;eight&#34; to &#34;e8t&#34;,
            &#34;nine&#34; to &#34;n9e&#34;,
        )

        val values = input.lines().map { value -&gt;
            translations.entries.fold(value) { acc, (from, to) -&gt;
                acc.replace(from, to)
            }
        }

        calibrate(values)
    }

    test {
        input { &#34;...&#34; }
        partOne { 142 }
    }

    test {
        input { &#34;...&#34; }
        partTwo { 281 }
    }
}
</code></pre><p>It was amazing to see what can be achieved with the language&rsquo;s support of lambda expression contexts.
Overall, the experience was very easy.
However, I did find <a href=https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/ rel="external noopener" target=_blank>DSL markers</a> a little confusing to get my head around.
Similar to infix operators and extension methods, this is another language feature that provides great power.
A part of me again fears how developers could overuse or exploit it (i.e. not everything needs its own DSL!).</p><p><picture><source type=image/webp srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_e1dae336b918bbfa.webp 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_79a512991f051690.webp 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_1c48398b222d7d9d.webp 1400w"><source type=image/jpeg srcset="/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_17977ee1c11c959e.jpg 350w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_e73c78e7e86d99ef.jpg 700w, /posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_ed20e923a26c0ac2.jpg 1400w"><img src=/posts/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl_hu_e73c78e7e86d99ef.jpg alt="santa-lang DSL in Kotlin" loading=lazy></picture></p><h2 id=conclusion>Conclusion</h2><p>There were some very interesting days in this year&rsquo;s calendar, along with some very complex maths-related problems that I am happy to see the back of.
I really enjoyed working in both Kotlin and Swift to solve these puzzles, and, as per my initial thoughts, I was able to model the problems in a similar manner most of the time.
Reflecting on the experience, I feel as though Kotlin (surprisingly to me) is my preferred language going forward.
Throughout the month, I have had the opportunity to explore almost all of the touted features in both languages, and at each hurdle, Kotlin tips Swift.
Going forward, I hope to expand upon this and delve into building native mobile applications using both languages.
Perhaps that may sway things Swift&rsquo;s way?</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/swift>swift</a><a href=/archive/tag/kotlin>kotlin</a></footer></article><div class="related-posts u-prose"><h3>Related Posts</h3><ul><li><a href=/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/>Solving the Advent of Code 2022 calendar using my own programming language, santa-lang</a></li><li><a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/>Designing santa-lang, a language for solving Advent of Code puzzles</a></li><li><a href=/posts/solving-the-advent-of-code-2021-calendar-on-a-raspberry-pi-pico/>Solving the Advent of Code 2021 calendar on a Raspberry Pi Pico</a></li><li><a href=/posts/solving-the-advent-of-code-2021-calendar-using-c-in-under-half-a-second/>Solving the Advent of Code 2021 calendar using C in under half-a-second</a></li><li><a href=/posts/advent-of-code-2016-day-11-radioisotope-thermoelectric-generators/>Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>