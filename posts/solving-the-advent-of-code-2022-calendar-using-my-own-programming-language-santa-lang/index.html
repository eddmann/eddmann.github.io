<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Discover how I tackled the Advent of Code 2022 calendar using my own programming language, santa-lang - detailing its strengths, challenges, and improvements made along the way.">

    <title>
        
            Solving the Advent of Code 2022 calendar using my own programming language, santa-lang &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Solving the Advent of Code 2022 calendar using my own programming language, santa-lang</h1>
    <time datetime="2023-01-28T00:00:00+00:00" class="post-date">28 Jan 2023</time>
    <p>December has come and gone, and the dust has settled on completing the Advent of Code 2022 calendar.
As highlighted in my <a href="https://eddmann.com/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/">previous post</a>, I wanted to complete this yearâ€™s puzzles using my own programming language, santa-lang, which I have tailored to help aid in solving such problems.
In this article, I want to discuss this experience, how the language aided in solution development, and where additions or changes were made to improve it along the way.</p>



<h2 id="where-we-left-off">Where We Left Off</h2>

<p>The design of the language had been formed based on my previous experience in solving <a href="https://github.com/eddmann/advent-of-code">several yearsâ€™ worth</a> of Advent of Code calendars in multiple different languages.
During the development phase, I had employed regular checkpoints to re-solve previous calendar puzzles in santa-lang to validate the path I was taking.
The 2022 calendar would be the first set of unknown puzzles that the language would have faced.
More so, it would be the first time primarily using the language to solve these puzzles.
I was initially wary of not being capable of completing each day in the language, perhaps even having to resort to another one.</p>

<p>Fortunately, this was not the case, and the <em>TL;DR</em> of this article would be that I was able to successfully implement each puzzle solution using santa-lang as my primary language ðŸŽ‰.
Throughout the calendar, I made a conscious effort to note down interesting aspects of the experience, which I have since categorised and wish to present below.</p>

<h2 id="the-journey">The Journey</h2>

<p>As an aside, no discussion of the Advent of Code 2022 calendar would be complete without sharing my <a href="https://www.reddit.com/r/adventofcode/comments/zsct8w/comment/j17pijh/">day 22 cube</a>!</p>

<p><img src="/uploads/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube.jpg" alt="Day 22 Cube" /></p>

<p>Now that is out of the way, we can beginâ€¦</p>

<h3 id="running-with-the-runner">Running with the Runner</h3>

<p>Most of this articleâ€™s discussion will no doubt be centred around the language and standard library.
Upon reviewing my notes, I realised that I had not given much thought towards <a href="https://eddmann.com/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/#the-aoc-runner">the runner</a> itself ðŸ˜¢.
In hindsight, I think the reason for this was probably the biggest compliment I could give - it just worked!
I spent the majority of my time using the CLI runtime, and with the combination of the test runner and in-built means of downloading the puzzle input, I was able to get <em>up nâ€™ problem-solving</em> very quickly each day.
The <em>REPL</em> developed over the course of the calendar, from developing each partâ€™s solution to validating both the test and puzzle input, was a frictionless experience.
As a consequence, I did not need to revise it, which, in turn, meant I did not write many notes about it.
It is for this reason that I want to highlight this success first!</p>

<h3 id="sometimes-you-need-mutation">Sometimes You Need Mutation</h3>

<p>One of the design goals for the language was - <em>No mutation, opting for readability and correctness over outright speed</em>.
Throughout the course of completing the calendar, there arose certain situations where readability would be negatively impacted if I did not employ some form of mutation ðŸ˜±.
This need was only directed at the ability to re-define <code class="language-plaintext highlighter-rouge">let</code> bindings, as opposed to providing a means to mutate data structures.
I did go back and forth on the idea of including such a feature, balancing the purity of the language over its practical nature to help solve puzzles.
I ended up being reassured, however, based on how Clojure handles <a href="https://clojure.org/reference/transients">transient data structures</a>.</p>

<blockquote>
  <p>If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutable return value, is that ok?</p>
</blockquote>

<p>Mutation as a whole is not a <em>bad thing</em>; in fact, it is an incredibly useful tool.
Although this statement is directed at data structures, the rationale that location and scope play a significant role in its viability is very apt.
Typically, concerns with mutation arise when its use occurs (often implicitly) across a large scope.
As such, if we keep the mutation scope small, we can harness the benefits it gives us without being hindered by the negatives.</p>

<p>One such example of its use was in solving <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day19.santa">day 19</a> while employing the <a href="https://en.wikipedia.org/wiki/Branch_and_bound">Branch and Bound</a> algorithm design paradigm.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let collect_max_geodes = |minutes, blueprint| {
  let mut max_geodes = 0;

  let recur = |state| {
    max_geodes = max(max_geodes, state["geodes"]);
    next_robot_states(blueprint, state)
      |&gt; filter(|next_state| estimate_geode_collection(blueprint, next_state) &gt; max_geodes)
      |&gt; each(recur);
  };

  // ..

  max_geodes;
}
</code></pre></div></div>

<p>You can see that the mutable <code class="language-plaintext highlighter-rouge">let</code> binding is local (co-located) to the pure function in which it resides.
It has a very small, focused scope, which only spans several lines of code and aids in the overall readability of the solution.</p>

<p>Another important consideration I made when deciding to add this feature to the language was to ensure that its intent was explicit.
In contrast to C-like languages of the past, I favoured immutability by default and explicitly (using the <code class="language-plaintext highlighter-rouge">mut</code> keyword) <em>â€˜opted inâ€™</em> to mutation.
This helps instruct the reader that its use is a <em>special case</em> and different from the conventional immutable behaviour.</p>

<p>Finally, I feel like a saying that comes up in the Python world a lot - <em><a href="https://docs.python-guide.org/writing/style/#we-are-all-responsible-users">â€˜We are all responsible usersâ€™</a></em> - is a compelling point to reflect upon.
A language is a tool, with certain syntax and runtime-level guardrails devised to assist in solving problems.
But at the end of the day, it is up to the code author to be responsible with the functionality that is available to them.
Any language, no matter how <em>strict</em> or <em>pure</em>, can be abused if the code author does not make responsible choices.</p>

<h3 id="recursion-over-stateful-loops">Recursion Over Stateful Loops</h3>

<p>As I had intentionally omitted standard loop constructs (<code class="language-plaintext highlighter-rouge">for</code>, <code class="language-plaintext highlighter-rouge">while</code>) from the language (which are inherently mutable), I found myself leaning heavily on recursion to provide the same means to an end.
The calendar had many maze puzzles, in which we were required to find (in varying masqueraded forms) the <em>shortest path</em> between two states; this meant employing the <a href="https://en.wikipedia.org/wiki/Breadth-first_search">breadth-first search</a> (BFS) algorithm.
Unlike <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search</a> (DFS), which is inherently recursive by nature (taking advantage of call stack properties), BFS <em>work</em> is stored in a FIFO queue.
Below is a snippet of my <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day24.santa">day 24</a> solution, which documents the key characteristics of the BFS algorithm and how recursion is used as a looping construct.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let recur = |queue, seen| {
  let [time, position] = first(queue);

  if position == end {
    return time;
  }

  let next_positions = [[0, 1], [0, -1], [-1, 0], [1, 0], [0, 0]]
    // ..
    |&gt; map(|bounded_position| [time + 1, bounded_position])
    |&gt; filter(|next_position| seen `excludes?` next_position);

  recur(
    rest(queue) + next_positions,
    seen + next_positions
  );
};

recur([[initial_time, start]], {});
</code></pre></div></div>

<p><strong>Note:</strong> I have been lazy within this implementation and excluded the base case that the queue is empty, assuming that the algorithm will eventually find the end position before exhausting the queue.</p>

<p>As you can see, this follows what you would typically see in a conventional looping implementation.
We dequeue an item, check if it matches our desired end state, find the next unseen items to be visited, and repeat.</p>

<p>When developing the initial solution that employed this algorithm (<a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day12.santa">day 12</a>), I found upon running it on a sufficiently large input set, I was faced with a host language (JavaScript) <code class="language-plaintext highlighter-rouge">Maximum call stack size exceeded</code> exception.
This introduced me to the world of <em>tail-call optimisation</em>, which can be defined as:</p>

<blockquote>
  <p>Tail-call optimisation is where you are able to avoid allocating a new stack frame for a function because the calling function will simply return the value that it gets from the called function.
The most common use is tail recursion, where a recursive function written to take advantage of tail-call optimisation can use constant stack space.</p>
</blockquote>

<p>Looking at the BFS implementation above, you can see this follows the described pattern, in which we are doing no other work within the current stack frame before returning the recursive invocation.
As such, we can optimally reuse the same stack frame for the next recursive call without incurring any performance penalty.
It was here that I put aside my calendar solution and headed to the language evaluator to implement <em>tail-call optimisation</em>.
This was a lot of fun to do, and it highlighted how the evaluator itself could be improved to help significantly speed up the code written in the subject language without any modification.</p>

<h3 id="functions-functions-functions">Functions, Functions, Functions</h3>

<p>When reviewing my notes, one topic I knew I could not miss was touching upon the desired goal of having <em>cheap functions</em>.
Opting for a syntax similar to how Rust defines functions was an ideal choice.
The syntax itself is lightweight and readable, which in turn makes it <em>cheap</em> to use.
An example of this would be defining the identity function like so: <code class="language-plaintext highlighter-rouge">|a| a</code>.</p>

<p>I did not know how much traction infix function invocation would get throughout the course of the calendar.
Turns out, I used it a lot!
Although you have the option to invoke functions like <code class="language-plaintext highlighter-rouge">vec_add(a, b)</code>, some expressions read better when defined in infix form, like <code class="language-plaintext highlighter-rouge">a `vec_add` b</code>.
The ability to do this with user-land/standard library functions and not only special operators was especially powerful.</p>

<p>Placeholder syntax is something I had been introduced to through Scala several years back and had greatly enjoyed.
This functionality gave the ability to succinctly express the <em>open</em> argument positions.
For example, combined with infix function invocation: <code class="language-plaintext highlighter-rouge">includes?(collection)</code> vs <code class="language-plaintext highlighter-rouge">collection `includes?` _</code>, or <code class="language-plaintext highlighter-rouge">_ `includes?` 2</code>.
Additionally, I was able to use placeholder arguments within conventional function calls like <code class="language-plaintext highlighter-rouge">get(_, collection)</code>, when it improved readability.
This syntax is very concise and feels more like a custom DSL for the given puzzle problem as opposed to a function definition.</p>

<p>With the formation of these <em>cheap functions</em>, I was subsequently able to compose <code class="language-plaintext highlighter-rouge">&gt;&gt;</code> and thread <code class="language-plaintext highlighter-rouge">|&gt;</code> them together to complete the puzzle problem at hand.
Again, I was unsure how much usage function composition would get, as the puzzles were very specific.
However, I was able to treat much of the standard library as building blocks for <em>cheaply</em> composing higher-level functionality.
This can be seen many times throughout the course of the calendar, especially when parsing the puzzle input.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// aoc2022_day01.santa
let parse_inventories = split("\n\n") &gt;&gt; map(ints &gt;&gt; sum);

// aoc2022_day20.santa
let parse_numbers = |decryption_key| {
  ints &gt;&gt; map(_ * decryption_key) &gt;&gt; zip(0.., _);
}
</code></pre></div></div>

<p>Finally, function threading was something introduced to me by Clojure whilst solving the <a href="https://github.com/eddmann/advent-of-code/tree/master/2020/clojure">2020 calendar</a>, and I relied heavily on it in this calendar too.
It is pure syntactic sugar over nested function invocations, but the conciseness and readability benefits it adds are undeniable.
I could show many, many examples of its use, but one place where it played a key role was in solving <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day24.santa">day 24</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ..
let trip = travel(blizzards, boundary);
trip(start, end, 0) |&gt; trip(end, start) |&gt; trip(start, end);
</code></pre></div></div>

<p>Threading combined with partial application provided a crisp means in which to define the problemâ€™s intent - <em>travelling</em> from the start to the end, back to the start, and then finally to the end again.</p>

<h3 id="dont-sleep-on-lazy-sequences">Donâ€™t Sleep on Lazy Sequences</h3>

<p>Lazy sequences allow you to express a class of problems very succinctly.
I had included the concept of infinite lazy ranges (<code class="language-plaintext highlighter-rouge">1..</code>) in the initial language design, but a pattern soon emerged where I wished to perform some form of operation multiple times (dependent on the previous output) and compute the <em>nth-term</em>.
It was for this that I decided to add the <code class="language-plaintext highlighter-rouge">iterate</code> function to the language, inspired by Clojureâ€™s <a href="https://clojuredocs.org/clojure.core/iterate">implementation</a> of the same name.
Defining a <a href="https://en.wikipedia.org/wiki/Referential_transparency">referentially transparent</a> function (input and output) for handling a single operation, we can supply this to <em>iterate</em> and expand it to however many <em>iterations</em> we wish to achieve, either until a certain <em>nth-term</em> (<code class="language-plaintext highlighter-rouge">get</code>) or a term predicate holds true (<code class="language-plaintext highlighter-rouge">find</code>).
Its use is documented widely throughout the calendar, none more so than in <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day09.santa">day 9</a>.
Here we were required to perform a single <code class="language-plaintext highlighter-rouge">knot_tail</code> operation in part 1 and then expand upon this to find the <em>9th term</em> in part 2.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>part_one: {
  parse_motions(input)
    |&gt; knot_head
    |&gt; knot_tail
    |&gt; visits;
}

part_two: {
  parse_motions(input)
    |&gt; knot_head
    |&gt; iterate(knot_tail)
    |&gt; get(9)
    |&gt; visits;
}
</code></pre></div></div>

<p>In <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day14.santa">day 14</a>, we were asked to apply a <em>pour</em> operation until some predicate held true based on the current term (in this case <code class="language-plaintext highlighter-rouge">sand</code>).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>part_one: {
  // ..
  iterate(pour(top, rock + void), {})
    |&gt; find(|sand| lowest_height(sand) == lowest_height(rock))
}

part_two: {
  // ..
  iterate(pour(top, rock + floor), {})
    |&gt; find(_ `includes?` top)
}
</code></pre></div></div>

<p>Another form of lazy sequence that was added during the month was <code class="language-plaintext highlighter-rouge">cycle</code>.
There were several problems that required <em>cycling</em> through a defined finite list.
In a typical stateful implementation, you would pass along the list and current index, which is subsequently <em>modulo</em> to cycle back through the list upon exhaustion.
Employing <code class="language-plaintext highlighter-rouge">cycle</code>, however, abstracts away these requirements, whereby we can use conventional <code class="language-plaintext highlighter-rouge">first</code>/<code class="language-plaintext highlighter-rouge">rest</code> collection primitives to consume the list as we desire.
Below is one such use case in <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day17.santa">day 17</a>, where we were required to perform a Tetris-style simulation based on rock/jet patterns.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let parse_jet_pattern = split("") &gt;&gt; map(|d| if d == "&lt;" { [0, -1] } else { [0, 1] }) &gt;&gt; cycle;
</code></pre></div></div>

<h3 id="removing-boilerplate-with-sequence-transformations">Removing Boilerplate with Sequence Transformations</h3>

<p>One aspect of the initial language design phase was the importance of <code class="language-plaintext highlighter-rouge">map</code>, <code class="language-plaintext highlighter-rouge">filter</code>, <code class="language-plaintext highlighter-rouge">fold</code>, and <code class="language-plaintext highlighter-rouge">reduce</code> to transform sequences due to the omission of typical stateful looping constructs.
I rely heavily on these primitives in daily development, and how they abstract away boilerplate code and the intricacies of looping and branching into commonly agreed/understood behaviours.
The ability to perform such transformations over both finite and infinite sequences was very useful.</p>

<p>Whilst working my way through the calendar, I noticed several transformation patterns that later were distilled down into their own constructs.
The first was the concept of <em>mapping</em> and then immediately <em>filtering</em> over the transformed collection.
Instead of having to chain these two operations together, I took inspiration from Rust and added a <code class="language-plaintext highlighter-rouge">filter_map</code> function, which includes <em>truthy</em> mapped values in the resulting sequence.
This again can be seen in my <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day17.santa">day 17</a> solution, which required us to find a state cycle within the Tetris-style simulation.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let cycle_state = iterate(drop_rock, [jets, rocks, {}])
  |&gt; filter_map(cycle_detector())
  |&gt; first;
</code></pre></div></div>

<p>In a similar manner, I noticed that I used <em>map</em> and then immediately <em>find</em> in several solutions.
This too was more succinctly written as <code class="language-plaintext highlighter-rouge">find_map</code> (again found in Rust), which performed the combination of the two.
Use of this can be seen in <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day15.santa">day 15</a>, when attempting to find the first mapped value which â€˜uncoversâ€™ x.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>parse_row(input)..
  |&gt; find_map(|y| {
    if let x = sensor_ranges(reports, y) |&gt; uncovered_x {
      [x, y]
    }
  })
  |&gt; tuning_frequency;
</code></pre></div></div>

<p>Finally, I noticed another pattern whereby I was <em>filtering</em> and then immediately returning the <em>size</em> of the given collection.
Taking inspiration from Ruby, I added a high-level <code class="language-plaintext highlighter-rouge">count</code> transformation which, based on a predicate (similar to how <code class="language-plaintext highlighter-rouge">filter</code> works), would tally up a finite sequenceâ€™s items that matched that predicate.
This can be seen in the solution for <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day04.santa">day 4</a>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>part_two: {
  parse_assignments(input)
    |&gt; count(|[[x1, y1], [x2, y2]]| max(x1, x2) &lt;= min(y1, y2));
}
</code></pre></div></div>

<h3 id="the-expressiveness-of-ranges">The Expressiveness of Ranges</h3>

<p>I had used ranges in both Rust and Python before, the former having the syntax that inspired this languageâ€™s design choice (<code class="language-plaintext highlighter-rouge">1..10</code>).
In the initial release, I had tried to simplify the specification by only including a single range <code class="language-plaintext highlighter-rouge">..</code>, which was inclusive of both the lower and upper bounds.
Throughout the calendar, however, I soon realised that having to decrement some values, especially when zero-indexed, was negatively impacting readability.
As such, I decided to additionally add <code class="language-plaintext highlighter-rouge">..=</code> which would replace my current implementation of <code class="language-plaintext highlighter-rouge">..</code>.
The <code class="language-plaintext highlighter-rouge">..</code> would now signify lower inclusive, upper exclusive - which is in keeping with how other languages define the behaviour.
This was an initial design decision that backfired on me and required amendment when spending more time within the language.
One puzzle that highlighted how useful range sequences were was in <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day15.santa">day 15</a>, when we had to deduce all possible â€˜xâ€™ positions.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let xs = sensor_ranges(reports, y)
  |&gt; map(|[start, end]| start..=end)
  |&gt; union;
</code></pre></div></div>

<p>The use of ranges was applied in many areas of the calendar.
Another common example was when producing indexed sequences.
This behaviour is found in other languages (like <code class="language-plaintext highlighter-rouge">enumerate</code> in Python), but being able to provide such functionality on top of standard library constructs was empowering.
Furthermore, the resulting index/item tuple lists could be passed to the <code class="language-plaintext highlighter-rouge">hash</code> function to produce lookup tables.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// aoc2022_day03.santa
let priorities = zip("abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ", 1..) |&gt; hash;

// aoc2022_day12.santa
let elevation = zip("SabcdefghijklmnopqrstuvwxyzE", 0..) |&gt; hash;
</code></pre></div></div>

<p>Another use of ranges was within pattern matching.
For <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day22.santa">day 22</a>â€™s infamous cube puzzle, I initially used <em>if guards</em> to handle point ranges, but again felt that the readability of the end solution was negatively impacted.
Instead, I decided to implement the ability to express ranges within pattern match statements, similar to how Rust does.
This resulted in a far more concise solution, as demonstrated in the snippet from day 22 below.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let step_3d = |facing, [y, x]| {
  match [facing, [y, x]] {
    ["N", [0, 50..100]]  { ["E", [150 + (x - 50), 0]] }
    ["N", [0, 100..150]] { ["N", [199, x - 100]] }
    ["N", [100, 0..50]]  { ["E", [50 + x, 50]] }
    ["N", _]             { ["N", [y - 1, x]] }
    // ..
  }
}
</code></pre></div></div>

<h3 id="memoization-as-a-language-keyword">Memoization as a Language Keyword?!</h3>

<p>Every AoC calendar, you can expect to see one problem that lends itself to <a href="https://en.wikipedia.org/wiki/Dynamic_programming">Dynamic Programming</a>.
These can be summarised as breaking up a larger problem into smaller sub-problems, which in turn can be used to help solve the original larger problem.
This year was no exception, and as such, I was required to invest some time in adding the ability to memoize functions within santa-lang.
For this, I added a function called <code class="language-plaintext highlighter-rouge">memoize</code>, which is a higher-order function that caches results (based on argument values) of the pure function that is supplied to it.
The inclusion of this function is not that significant, but what I really wish to highlight is how trailing lambda syntax provides for such a rich DSL, making the function invocation feel like a language construct.
This can be seen in an extract from the <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day16.santa">day 16</a> puzzle.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>let recur = memoize |valve, time, open_valves| {
  // ..
}
</code></pre></div></div>

<p>Although this simply means <code class="language-plaintext highlighter-rouge">memoize(|..| ..)</code>, the omission of the call parenthesis is very powerful.
It also lends itself well to <em>decorating</em> functions, in a similar manner to how Python provides such functionality.</p>

<h2 id="conclusion">Conclusion</h2>

<p>Having spent some time now reflecting on my experience solving the 2022 calendar in santa-lang, I am very pleased with how many of the fundamental decisions made upfront paid off.
Aside from the small additions discussed in this article, much of the language and its underlying philosophy have held up.
The one possible argument against this claim would be the inclusion of mutable <code class="language-plaintext highlighter-rouge">let</code> bindings, but after going back and forth on this decision, I feel that it has a deserved place in the language.</p>

<h3 id="possible-improvements">Possible Improvements</h3>

<p>Despite being happy with the current state of the language, there are several areas in which I feel time could be spent to improve it further.
One category of puzzle problem that we encountered in many variations this year was maze traversal.
Throughout the course of the month, I toyed with the idea of enriching the language with concepts and types that would aid in such problem-solving.
These were centred around the possible addition of a <code class="language-plaintext highlighter-rouge">Point</code> type and associated helper functions (i.e. <code class="language-plaintext highlighter-rouge">neighbours</code>, <code class="language-plaintext highlighter-rouge">bounded_neighbours</code>).
However, I could not settle on what I would deem to be the <em>best fit</em> for the language, as it would ideally cater to both 2D and 3D planes.
As such, I felt it best to omit such a concept for the time being and possibly revisit it in several months.
This would give me time to explore a more generalised approach to solving such problems, suitable for the many different AoC maze puzzles that exist.</p>

<p>Another area I feel could be improved is input parsing.
Although greatly simplified with the addition of <code class="language-plaintext highlighter-rouge">regex_*</code> helper functions (such as <code class="language-plaintext highlighter-rouge">ints</code>) and function composition, I believe a more radical change could be explored.
It would be interesting to experiment with embedding a <a href="https://en.wikipedia.org/wiki/Parser_combinator">parser combinator</a> library into the runner, which would provide a clear means of defining how to transform the input into a parsed form used for computation.
Having seen examples in other languages such as Rust using libraries like <a href="https://docs.rs/nom/latest/nom/">nom</a>, I feel there could be a place for expressing such parsing rules in an Advent of Code DSL.</p>

<h3 id="whats-next">Whatâ€™s Next?</h3>

<p>Something I did not really touch upon throughout this article was performance.
This was intentional, as it was not a fundamental goal of the language, opting instead for readability and correctness.
As such, not much work was done (other than tail-recursive calls, which were more of a necessity at the time) within language evaluation to improve this.
I did <a href="https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/benchmark.txt">benchmark</a> each solution to see how the language/runtime implementation fared, and in some cases, the solution performance was in the 5-minute range ðŸ˜¬.
I briefly explored further data structure mutation, similar to Clojure (<a href="https://clojuredocs.org/clojure.core/assoc!"><code class="language-plaintext highlighter-rouge">assoc!</code></a>, <code class="language-plaintext highlighter-rouge">update!</code>), but this did not feel like the right path to take.
In some cases, this may have been due to suboptimal solutions, but I was sure there was room within the runtime to improve this.
To validate this, I reimplemented some of these solutions in Python and JavaScript, reflecting as closely as I could on the santa-lang implementation.
Within the CPython and Node v8 runtimes, these solutions were orders of magnitude faster! ðŸ˜®</p>

<p>This brings us to the next chapter of this projectâ€¦
I now wish to take the language specification and defined standard library functions and reimplement them in a more performant, lower-level language.
For this, I have chosen Rust, as I feel it is a great fit for this purpose.
I also enjoyed using the language to build a <a href="https://eddmann.com/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/">Rubikâ€™s Cube Solver</a> several years back.</p>

<p>Along the way, I want to rethink the underlying abstractions in the TypeScript implementation, as it currently feels more like a proof of concept rather than a runtime I intend to maintain long-term.
I hope that through this process, I can improve the benchmark performance of these solutions, without changing anything about the actual solutions themselves - only the runtimes and associated internals.</p>

<p><strong>Update</strong>: You can read about this experience in the following <a href="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/">blog series</a>.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
