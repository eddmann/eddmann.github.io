<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sql on Edd Mann</title><link>https://eddmann.com/archive/tag/sql/</link><description>Recent content in Sql on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Wed, 20 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>You Should Switch to PostgreSQL: My Conversation with Adam Wathan on Full Stack Radio</title><link>https://eddmann.com/posts/you-should-switch-to-postgresql-my-conversation-with-adam-wathan-on-full-stack-radio/</link><pubDate>Wed, 20 Apr 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/you-should-switch-to-postgresql-my-conversation-with-adam-wathan-on-full-stack-radio/</guid><description>&lt;p>I recently had the pleasure of chatting with Adam Wathan on &lt;a href="https://fullstackradio.com/40" rel="external noopener" target="_blank">Full Stack Radio&lt;/a> about PostgreSQL - a technology near and dear to my heart.
During our conversation, we dove into the advantages PostgreSQL offers over MySQL, the most common obstacles teams encounter when making the switch, and how to decide whether certain tasks should be handled in the database rather than in application code.&lt;/p>
&lt;p>In addition to these topics, we covered PostgreSQL&amp;rsquo;s ACID properties and powerful features like partial indexes, JSON support, and even the possibility of using JavaScript within the database!
We also touched on the benefits of Common Table Expressions (CTEs) for more complex queries.&lt;/p></description></item><item><title>Operations on a Deck of Cards in PostgreSQL</title><link>https://eddmann.com/posts/operations-on-a-deck-of-cards-in-postgresql/</link><pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/operations-on-a-deck-of-cards-in-postgresql/</guid><description>&lt;p>Recently, I have been looking more into SQL and, in particular, how RDBMSs work under the hood.
I thought it would be interesting to use some of the lesser-known features that PostgreSQL has to offer, concentrating my efforts on operations performed on a deck of cards.&lt;/p></description></item><item><title>Using the 'IS (NOT) DISTINCT FROM' SQL Comparators</title><link>https://eddmann.com/posts/using-the-is-not-distinct-from-sql-comparators/</link><pubDate>Thu, 17 Mar 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/using-the-is-not-distinct-from-sql-comparators/</guid><description>&lt;p>In a recent SQL statement, I stumbled upon an issue regarding the handling of &lt;code>NULL&lt;/code> values within a given predicate.
Coming from languages such as PHP, which are very liberal in their type coercion (&lt;code>NULL&lt;/code> can be treated as a falsy value), I was surprised to find how the inclusion of such a value resulted in a sort of predicate short-circuiting.&lt;/p></description></item><item><title>Maintaining Invariant Constraints in PostgreSQL using Trigger Functions</title><link>https://eddmann.com/posts/maintaining-invariant-constraints-in-postgresql-using-trigger-functions/</link><pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/maintaining-invariant-constraints-in-postgresql-using-trigger-functions/</guid><description>&lt;p>Recently, a feature I was working on required me to alter a unique constraint that existed on a table column.
The invariant had now been weakened to allow storing of duplicate &lt;code>email&lt;/code> addresses, provided they shared an equivalent &lt;code>link_id&lt;/code> (excluding &lt;code>NULL&lt;/code>).
Sadly, the ease with which I had initially added the general unique constraint had disappeared.
However, I was able to take advantage of insertion/update triggers to regain these invariant reassurances.&lt;/p></description></item><item><title>Conditional Expressions in PostgreSQL</title><link>https://eddmann.com/posts/conditional-expressions-in-postgresql/</link><pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/conditional-expressions-in-postgresql/</guid><description>&lt;p>There may be a case where you need to make sure only a single row value is &lt;code>true&lt;/code> in a collection of results.
A common pattern for performing such a task is to set all values to &lt;code>false&lt;/code> in the collection, and then set the desired one to &lt;code>true&lt;/code>.&lt;/p></description></item></channel></rss>