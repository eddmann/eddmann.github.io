<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Explores creating an Enigma Machine in ClojureScript, using Property-based testing to assert its correctness">

    <title>Building an Enigma Machine in ClojureScript &middot; Edd Mann</title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Building an Enigma Machine in ClojureScript</h1>
    <time datetime="2020-11-25T00:00:00-06:00" class="post-date">25 Nov 2020</time>
    <p>The Enigma Machine is a typewriter-sized substitution encryption device used by Germany in World War 2.
It was so important to the war-time efforts that work carried out by Alan Turing at Bletchley Park to decode the resulting ciphers helped end the war.
For years I have been fascinated by this device, and thought it would be interesting to explore implementing a web-based Enigma Machine using ClojureScript.
I also thought it would be a great opportunity to explore how I can use Property-based testing to help garner confidence from the resulting implementation.</p>



<p>You can experiement with the final implementation <a href="https://eddmann.com/enigma-machine-clojurescript/">here</a>, and the source code is available in its entirety on <a href="https://github.com/eddmann/enigma-machine-clojurescript">GitHub</a> to review.</p>

<p><a href="https://eddmann.com/enigma-machine-clojurescript/"><img src="/uploads/building-an-enigma-machine-in-clojurescript/demo.png" alt="Web-based Engima Machine" /></a></p>

<h3 id="how-it-works">How it works</h3>

<p>At its most basic (as many variations appeared over the years) the machine is composed of a Keyboard, Lamp Board, three Rotors, a Reflector and a Plugboard (as pictured below).
Using a pre-shared machine configuration (Wheel order, Ring settings and Plug connections), when an operator presses a key on the Keyboard a seemingly random letter elluminates on the Lamp Board.
With these key presses forming a desired message, the resulting cipher is then sent via an agreed (often insecure) channel to interested parties.
Using a similarly configured Enigma Machine the recipient is able to follow the same process as the sender, except upon each key press the original message letter will ellumiate on the Lamp Board.
With the combination of the Rotors, Reflector and Plugboard there are a staggering <em>158,962,555,217,826,360,000</em> paths a letter can take to be substituted!</p>

<p><img src="/uploads/building-an-enigma-machine-in-clojurescript/enigma-machine.jpg" alt="Enigma Machine" /></p>

<p>I will defer to <a href="https://hackaday.com/2017/08/22/the-enigma-enigma-how-the-enigma-machine-worked/">these</a> <a href="https://www.youtube.com/watch?v=G2_Q9FoD-oQ">great</a> <a href="https://www.youtube.com/watch?v=ASfAPOiq_eQ">resources</a> of which I found very useful in helping to elaborate on the inner workings of the Enigma Machine.
With a basic understanding of how the machine works in place we can now move on to modelling this behaviour in code.</p>

<h3 id="the-machine">The Machine</h3>

<p>We will begin with what I feel is the heart of the Enigma Machine, the stepped Rotors.
Comprised of three connected Rotors, the desired pressed keys wiring forms a circuit based on the current positioning of the Rotors.
Within code we are able to represent this as <em>hash-map</em> like data-structures, where-by we rotate the given Rotor based on a specified <em>step</em> letter and position within the Rotor collection.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"ABCDEFGHIJKLMNOPQRSTUVWXYZ"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">rotors</span><span class="w">
  </span><span class="p">{</span><span class="no">:I</span><span class="w">   </span><span class="p">{</span><span class="no">:out</span><span class="w">  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"EKMFLGDQVZNTOWYHXUSPAIBRCJ"</span><span class="p">)</span><span class="w">
         </span><span class="no">:in</span><span class="w">   </span><span class="n">alphabet</span><span class="w">
         </span><span class="no">:step</span><span class="w"> </span><span class="sc">\Q</span><span class="p">}</span><span class="n">,</span><span class="w">
   </span><span class="no">:II</span><span class="w">  </span><span class="p">{</span><span class="no">:out</span><span class="w">  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"AJDKSIRUXBLHWTMCQGZNPYFVOE"</span><span class="p">)</span><span class="w">
         </span><span class="no">:in</span><span class="w">   </span><span class="n">alphabet</span><span class="w">
         </span><span class="no">:step</span><span class="w"> </span><span class="sc">\E</span><span class="p">}</span><span class="w">
   </span><span class="no">:III</span><span class="w"> </span><span class="p">{</span><span class="no">:out</span><span class="w">  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"BDFHJLCPRTXVZNYEIWGAKMUSQO"</span><span class="p">)</span><span class="w">
         </span><span class="no">:in</span><span class="w">   </span><span class="n">alphabet</span><span class="w">
         </span><span class="no">:step</span><span class="w"> </span><span class="sc">\V</span><span class="p">}})</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">step?</span><span class="w"> </span><span class="p">[</span><span class="n">rotor</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="no">:step</span><span class="w"> </span><span class="n">rotor</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="no">:in</span><span class="w"> </span><span class="n">rotor</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">rotate-rotor</span><span class="w"> </span><span class="p">[</span><span class="n">rotor</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">rotate</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">concat</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="p">[(</span><span class="nb">first</span><span class="w"> </span><span class="n">%</span><span class="p">)])]</span><span class="w">
    </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">rotor</span><span class="w">
        </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:in</span><span class="w"> </span><span class="n">rotate</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:out</span><span class="w"> </span><span class="n">rotate</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">rotate-rotors</span><span class="w"> </span><span class="p">[[</span><span class="n">one</span><span class="w"> </span><span class="n">two</span><span class="w"> </span><span class="n">three</span><span class="p">]]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">step-one?</span><span class="w"> </span><span class="p">(</span><span class="nf">step?</span><span class="w"> </span><span class="n">one</span><span class="p">)</span><span class="w">
        </span><span class="n">step-two?</span><span class="w"> </span><span class="p">(</span><span class="nf">step?</span><span class="w"> </span><span class="n">two</span><span class="p">)]</span><span class="w">
    </span><span class="p">[(</span><span class="nf">rotate-rotor</span><span class="w"> </span><span class="n">one</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">or</span><span class="w"> </span><span class="n">step-one?</span><span class="w"> </span><span class="n">step-two?</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-rotor</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w"> </span><span class="n">two</span><span class="p">)</span><span class="w">
     </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">step-two?</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-rotor</span><span class="w"> </span><span class="n">three</span><span class="p">)</span><span class="w"> </span><span class="n">three</span><span class="p">)]))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">passthrough-rotors</span><span class="w"> </span><span class="p">[</span><span class="n">rotors</span><span class="w"> </span><span class="n">letter</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
   </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">letter</span><span class="w"> </span><span class="n">rotor</span><span class="p">]</span><span class="w">
     </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">letter</span><span class="w">
          </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="p">(</span><span class="no">:out</span><span class="w"> </span><span class="n">rotor</span><span class="p">)))</span><span class="w">
          </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="p">(</span><span class="no">:in</span><span class="w"> </span><span class="n">rotor</span><span class="p">)</span><span class="w"> </span><span class="n">alphabet</span><span class="p">))))</span><span class="w">
   </span><span class="n">letter</span><span class="w">
   </span><span class="n">rotors</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Using the above code we define three of the original Rotors (with the scrambled wiring represented as <code class="language-plaintext highlighter-rouge">in</code> and <code class="language-plaintext highlighter-rouge">out</code>), providing the behaviour necessary to rotate and pass a letter through the given Rotor collection.
With the use of <em>hash-maps</em> we are able to clearly see how the machine used substitution to form the resulting cipher.</p>

<p>To complete the circuit and send the current back through the (inverted) Rotors we use a supplied Reflector.
These use simple static substitutions which can be represented as <em>hash-maps</em> like so.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">reflectors</span><span class="w">
  </span><span class="p">{</span><span class="no">:A</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"EJMZALYXVBWFCRQUONTSPIKHGD"</span><span class="p">))</span><span class="w">
   </span><span class="no">:B</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"YRUHQSLDPXNGOKMIEBFZCWVJAT"</span><span class="p">))</span><span class="w">
   </span><span class="no">:C</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="n">alphabet</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"FVPJIAOYEDRZXWGCTKUQSBNMHL"</span><span class="p">))})</span><span class="w">
</span></code></pre></div></div>

<p>From here, we can now succinctly declare how a chosen letter (key press) traverses through the machine and returned as a cipher to the operator.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">invert-rotor</span><span class="w"> </span><span class="p">[</span><span class="n">rotor</span><span class="p">]</span><span class="w">
  </span><span class="p">{</span><span class="no">:in</span><span class="w">   </span><span class="p">(</span><span class="no">:out</span><span class="w"> </span><span class="n">rotor</span><span class="p">)</span><span class="n">,</span><span class="w">
   </span><span class="no">:out</span><span class="w">  </span><span class="p">(</span><span class="no">:in</span><span class="w"> </span><span class="n">rotor</span><span class="p">)</span><span class="n">,</span><span class="w">
   </span><span class="no">:step</span><span class="w"> </span><span class="p">(</span><span class="no">:step</span><span class="w"> </span><span class="n">rotor</span><span class="p">)})</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">encode-letter</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">rotors</span><span class="w"> </span><span class="n">reflector</span><span class="w"> </span><span class="n">plugboard</span><span class="p">]}</span><span class="w"> </span><span class="n">letter</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">plug</span><span class="w">            </span><span class="o">#</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">plugboard</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="n">,</span><span class="w">
        </span><span class="n">reflect</span><span class="w">         </span><span class="o">#</span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">reflector</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w">
        </span><span class="n">inverted-rotors</span><span class="w"> </span><span class="p">(</span><span class="nb">reverse</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">invert-rotor</span><span class="w"> </span><span class="n">rotors</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="n">letter</span><span class="w">
         </span><span class="n">plug</span><span class="w">
         </span><span class="p">(</span><span class="nf">passthrough-rotors</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w">
         </span><span class="n">reflect</span><span class="w">
         </span><span class="p">(</span><span class="nf">passthrough-rotors</span><span class="w"> </span><span class="n">inverted-rotors</span><span class="p">)</span><span class="w">
         </span><span class="n">plug</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>You can see how we thread the letter through the Plugboard, passing up and down the currently configured Rotors (by way of the Reflector) and then through the Plugboard to attain the resulting cipher letter.
We will soon be able to use this function to iteratively produce a cipher of an entire message.
Before we do this however, as explained at the beginning of this post, we need a means of configuring the machine based on an agreed-upon setup.
This is achieved using the code below.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">setup-plugboard</span><span class="w"> </span><span class="p">[</span><span class="n">plugboard</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">merge</span><span class="w"> </span><span class="n">plugboard</span><span class="w"> </span><span class="p">(</span><span class="nb">map-invert</span><span class="w"> </span><span class="n">plugboard</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">setup-rotors</span><span class="w"> </span><span class="p">[</span><span class="n">rotors</span><span class="w"> </span><span class="n">positions</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">letfn</span><span class="w">
   </span><span class="p">[(</span><span class="nf">setup-rotor</span><span class="w"> </span><span class="p">[</span><span class="n">rotor</span><span class="w"> </span><span class="n">position</span><span class="p">]</span><span class="w">
      </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="no">:in</span><span class="w"> </span><span class="n">rotor</span><span class="p">))</span><span class="w"> </span><span class="n">position</span><span class="p">)</span><span class="w">
        </span><span class="n">rotor</span><span class="w">
        </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-rotor</span><span class="w"> </span><span class="n">rotor</span><span class="p">)</span><span class="w"> </span><span class="n">position</span><span class="p">)))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">setup-rotor</span><span class="w"> </span><span class="n">rotors</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">positions</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">setup-machine</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">machine</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:plugboard</span><span class="w"> </span><span class="n">setup-plugboard</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="no">:rotors</span><span class="w"> </span><span class="n">setup-rotors</span><span class="w"> </span><span class="p">(</span><span class="no">:positions</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="s">"AAA"</span><span class="p">))</span><span class="w">
      </span><span class="p">(</span><span class="nb">assoc</span><span class="w"> </span><span class="no">:cipher</span><span class="w"> </span><span class="p">[])))</span><span class="w">
</span></code></pre></div></div>

<p>With the assumption of the client code supplying us a desired machine setup, we are able to internally configure the starting positions of the chosen Rotors and Plugboard mapping for use with encoding/decoding a message.
Finally, based on a supplied machine configuration (which has been setup using the code above) we are able to <em>reduce</em> the message into its cipher counterpart.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">encode-message</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="w"> </span><span class="n">message</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w">
       </span><span class="p">(</span><span class="nb">reduce</span><span class="w">
        </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="w"> </span><span class="n">letter</span><span class="p">]</span><span class="w">
          </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="w"> </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="no">:rotors</span><span class="w"> </span><span class="n">rotate-rotors</span><span class="p">)]</span><span class="w">
            </span><span class="p">(</span><span class="nf">update</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="no">:cipher</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">conj</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="p">(</span><span class="nf">encode-letter</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">letter</span><span class="p">)))))</span><span class="w">
        </span><span class="p">(</span><span class="nf">setup-machine</span><span class="w"> </span><span class="n">machine</span><span class="p">))</span><span class="w">
       </span><span class="no">:cipher</span><span class="w">
       </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h3 id="testing">Testing</h3>

<p>Now we have modelled the behaviour of the machine we can assert its correctness by-way of testing the <em>public API</em> - the <code class="language-plaintext highlighter-rouge">encode-message</code> function.
We will first do this by performing a couple of basic assertions which centre around the inclusion and exclusion of a Plugboard mapping.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">encode-message-with-empty-plugboard</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w">
   </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"ILBDAAMTAZ"</span><span class="w">
      </span><span class="p">(</span><span class="nf">encode-message</span><span class="w">
       </span><span class="p">{</span><span class="no">:rotors</span><span class="w">    </span><span class="p">[(</span><span class="no">:III</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:II</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:I</span><span class="w"> </span><span class="n">rotors</span><span class="p">)]</span><span class="w">
        </span><span class="no">:positions</span><span class="w"> </span><span class="s">"AAA"</span><span class="w">
        </span><span class="no">:reflector</span><span class="w"> </span><span class="p">(</span><span class="no">:B</span><span class="w"> </span><span class="n">reflectors</span><span class="p">)</span><span class="w">
        </span><span class="no">:plugboard</span><span class="w"> </span><span class="p">{}}</span><span class="w">
       </span><span class="s">"HELLOWORLD"</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">deftest</span><span class="w"> </span><span class="n">encode-message-with-plugboard</span><span class="w">
  </span><span class="p">(</span><span class="nf">is</span><span class="w">
   </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="s">"ILADBBMTBZ"</span><span class="w">
      </span><span class="p">(</span><span class="nf">encode-message</span><span class="w">
       </span><span class="p">{</span><span class="no">:rotors</span><span class="w">    </span><span class="p">[(</span><span class="no">:III</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:II</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:I</span><span class="w"> </span><span class="n">rotors</span><span class="p">)]</span><span class="w">
        </span><span class="no">:positions</span><span class="w"> </span><span class="s">"AAA"</span><span class="w">
        </span><span class="no">:reflector</span><span class="w"> </span><span class="p">(</span><span class="no">:B</span><span class="w"> </span><span class="n">reflectors</span><span class="p">)</span><span class="w">
        </span><span class="no">:plugboard</span><span class="w"> </span><span class="p">{</span><span class="sc">\A</span><span class="w"> </span><span class="sc">\B</span><span class="p">}}</span><span class="w">
       </span><span class="s">"HELLOWORLD"</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>We could expand upon this test-suite greatly, but fundamentally each test being static (example based) there could be no end to the possible tests we could write.
Based on this reasoning I thought it would be a very interesting exercise to employ <em>Property-based testing</em> to help garner ever-more increasing confidence in our implementation.
This form of testing methodology can be described as:</p>

<blockquote>
  <p>Property-based tests are designed to test the aspects of a property that should always be true.
They allow for a range of inputs to be programmed and tested within a single test, rather than having to write a different test for every value that you want to test.</p>
</blockquote>

<p>With this in-mind, there are a couple of distinct properties that regardless of what machine setup or message we provide should always hold true.
Using the <a href="https://clojure.org/guides/spec">spec</a> libary (which was inspired by <a href="https://hackage.haskell.org/package/QuickCheck">QuickCheck</a>) we are able to model two of these properties like so.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">gen-char-upper-alpha</span><span class="w">
  </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="nb">char</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/choose</span><span class="w"> </span><span class="mi">65</span><span class="w"> </span><span class="mi">90</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">gen-string-upper-alpa</span><span class="w">
  </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="n">clojure.string/join</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/vector</span><span class="w"> </span><span class="n">gen-char-upper-alpha</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">gen-machine</span><span class="w">
  </span><span class="p">(</span><span class="nf">gen/hash-map</span><span class="w"> </span><span class="no">:rotors</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w"> </span><span class="n">gen/elements</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/vector</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
                </span><span class="no">:positions</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="n">clojure.string/join</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/vector</span><span class="w"> </span><span class="n">gen-char-upper-alpha</span><span class="w"> </span><span class="mi">3</span><span class="p">))</span><span class="w">
                </span><span class="no">:reflector</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">vals</span><span class="w"> </span><span class="n">reflectors</span><span class="p">)</span><span class="w"> </span><span class="n">gen/elements</span><span class="p">)</span><span class="w">
                </span><span class="no">:plugboard</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">gen/vector-distinct</span><span class="w"> </span><span class="n">gen-char-upper-alpha</span><span class="w"> </span><span class="p">{</span><span class="no">:min-elements</span><span class="w"> </span><span class="mi">0</span><span class="w"> </span><span class="no">:max-elements</span><span class="w"> </span><span class="mi">26</span><span class="p">})</span><span class="w">
                                </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nf">odd?</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nb">rest</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w">
                                </span><span class="p">(</span><span class="nf">gen/fmap</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">hash-map</span><span class="w"> </span><span class="n">%</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="nf">defspec</span><span class="w"> </span><span class="n">cipher-is-same-length-as-message</span><span class="w">
  </span><span class="p">(</span><span class="nf">prop/for-all</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="w"> </span><span class="n">gen-machine</span><span class="w">
                 </span><span class="n">message</span><span class="w"> </span><span class="n">gen-string-upper-alpa</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cipher</span><span class="w"> </span><span class="p">(</span><span class="nf">encode-message</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">message</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">cipher</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="nf">defspec</span><span class="w"> </span><span class="n">encoded-cipher-matches-message</span><span class="w">
  </span><span class="p">(</span><span class="nf">prop/for-all</span><span class="w"> </span><span class="p">[</span><span class="n">machine</span><span class="w"> </span><span class="n">gen-machine</span><span class="w">
                 </span><span class="n">message</span><span class="w"> </span><span class="n">gen-string-upper-alpa</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cipher</span><span class="w"> </span><span class="p">(</span><span class="nf">encode-message</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">message</span><span class="p">)]</span><span class="w">
      </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="n">message</span><span class="w"> </span><span class="p">(</span><span class="nf">encode-message</span><span class="w"> </span><span class="n">machine</span><span class="w"> </span><span class="n">cipher</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>Providing a means of producing a valid randomly generated machine configuration - we can assert that for any given instance that the cipher message should be the same length as the plain-text message, and we should be able to encode/decode the cipher message to the original plain-text message.
We can now leave it up to the <em>spec</em> library to produce a large random selection of valid machine configurations and ensure the correctness of our propositions - garnering ever more confidence in the code upon each test run.
One of the true powers of this testing approach is how if a property does not seem to hold true for a given test assertion, the library is able to shrink the input down as best it can to the problem input.</p>

<h3 id="the-user-interface">The User Interface</h3>

<p>Having modeled and verified the correctness of the machine behaviour we can move on to providing the client with a user interface.
For this we will be using <a href="https://reagent-project.github.io/">Reagent</a>, which provides ClojureScript bindings for the React library.
So as to not overload this article with code, I have decided to intentionally omit going through the client implementation in the step-by-step fashion as done above.
Instead I ask for you to head over to the <a href="https://github.com/eddmann/enigma-machine-clojurescript/blob/master/src/enigma_machine/app.cljs"><code class="language-plaintext highlighter-rouge">app.cljs</code></a> implementation which describes how we use Reagent to interact with our machine implementation.
Below you will see how we combine all the child input components declared in <code class="language-plaintext highlighter-rouge">app.cljs</code>, into the stateful parent component which is rendered to the DOM.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">app</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">rotors</span><span class="w">    </span><span class="p">[(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"III"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"II"</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"I"</span><span class="p">)]</span><span class="w">
        </span><span class="n">reflector</span><span class="w"> </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"B"</span><span class="p">)</span><span class="w">
        </span><span class="n">plugboard</span><span class="w"> </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
        </span><span class="n">positions</span><span class="w"> </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"AAA"</span><span class="p">)</span><span class="w">
        </span><span class="n">message</span><span class="w">   </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"HELLOWORLD"</span><span class="p">)</span><span class="w">
        </span><span class="n">cipher</span><span class="w">    </span><span class="p">(</span><span class="nf">r/atom</span><span class="w"> </span><span class="s">"ILBDAAMTAZ"</span><span class="p">)</span><span class="w">
        </span><span class="n">encode</span><span class="w">    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
                    </span><span class="p">(</span><span class="nf">machine/encode-message</span><span class="w">
                     </span><span class="p">{</span><span class="no">:rotors</span><span class="w">    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">((</span><span class="nb">keyword</span><span class="w"> </span><span class="o">@</span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="n">machine/rotors</span><span class="p">)</span><span class="w"> </span><span class="n">rotors</span><span class="p">)</span><span class="w">
                      </span><span class="no">:positions</span><span class="w"> </span><span class="o">@</span><span class="n">positions</span><span class="w">
                      </span><span class="no">:reflector</span><span class="w"> </span><span class="p">((</span><span class="nb">keyword</span><span class="w"> </span><span class="o">@</span><span class="n">reflector</span><span class="p">)</span><span class="w"> </span><span class="n">machine/reflectors</span><span class="p">)</span><span class="w">
                      </span><span class="no">:plugboard</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">hash-map</span><span class="w"> </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="o">@</span><span class="n">plugboard</span><span class="w"> </span><span class="s">" "</span><span class="w"> </span><span class="s">""</span><span class="p">)))}</span><span class="w">
                     </span><span class="o">@</span><span class="n">message</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[]</span><span class="w">
      </span><span class="p">[</span><span class="no">:div</span><span class="w">
       </span><span class="p">[</span><span class="no">:div</span><span class="w">
        </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"columns"</span><span class="p">}</span><span class="w">
        </span><span class="p">(</span><span class="nb">doall</span><span class="w"> </span><span class="p">(</span><span class="nf">map-indexed</span><span class="w"> </span><span class="n">select-rotor</span><span class="w"> </span><span class="n">rotors</span><span class="p">))]</span><span class="w">
       </span><span class="p">[</span><span class="no">:div</span><span class="w">
        </span><span class="p">{</span><span class="no">:class</span><span class="w"> </span><span class="s">"columns"</span><span class="p">}</span><span class="w">
        </span><span class="p">(</span><span class="nf">select-reflector</span><span class="w"> </span><span class="n">reflector</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">positions-input</span><span class="w"> </span><span class="n">positions</span><span class="p">)</span><span class="w">
        </span><span class="p">(</span><span class="nf">plugboard-input</span><span class="w"> </span><span class="n">plugboard</span><span class="p">)]</span><span class="w">
       </span><span class="p">(</span><span class="nf">message-textarea</span><span class="w"> </span><span class="n">message</span><span class="p">)</span><span class="w">
       </span><span class="p">[</span><span class="no">:button</span><span class="w"> </span><span class="p">{</span><span class="no">:on-click</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">reset!</span><span class="w"> </span><span class="n">cipher</span><span class="w"> </span><span class="p">(</span><span class="nf">encode</span><span class="p">))}</span><span class="w"> </span><span class="s">"Encode"</span><span class="p">]</span><span class="w">
       </span><span class="p">[</span><span class="no">:pre</span><span class="w"> </span><span class="o">@</span><span class="n">cipher</span><span class="p">]])))</span><span class="w">
</span></code></pre></div></div>

<p>Making use of <a href="http://reagent-project.github.io/docs/master/reagent.ratom.html">Reagent Atoms</a> we are able to statefully store the users intended configuration and invoke the <code class="language-plaintext highlighter-rouge">encode-message</code> function when required.</p>

<h3 id="conclusion">Conclusion</h3>

<p>I found modeling this solution in a Lisp using ClojureScript to be very enjoyable.
Looking back over the code I find it amazing how a Lisp is able to so succinctly and elegantly document the behaviour of the machine.
The more I develved into the solution to this problem space the more I felt the functional approach mapped so well.
Being able to explore Property-based testing in this fashion was a great experience, and from it I am able to see how well it can fit into aspects of daily programming/problems we solve.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
