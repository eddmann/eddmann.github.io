<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2015 - Day 5 - Doesn't He Have Intern-Elves For This? - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2015 Day 5 puzzle using TypeScript."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2015 - Day 5 - Doesn't He Have Intern-Elves For This?"><meta itemprop=description content="On the fifth day of Advent of Code 2015, Santa needs help figuring out which strings in his text file are naughty or nice - a.k.a best load up a Regular Expression tester!"><meta itemprop=datePublished content="2021-01-29T00:00:00+00:00"><meta itemprop=dateModified content="2021-01-29T00:00:00+00:00"><meta itemprop=wordCount content="742"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2015,Typescript"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2015-day-5-doesnt-he-have-intern-elves-for-this/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2015 - Day 5 - Doesn't He Have Intern-Elves For This?"><meta property="og:description" content="On the fifth day of Advent of Code 2015, Santa needs help figuring out which strings in his text file are naughty or nice - a.k.a best load up a Regular Expression tester!"><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-29T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-29T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2015"><meta property="article:tag" content="Typescript"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2015 - Day 5 - Doesn't He Have Intern-Elves For This?"><meta name=twitter:description content="On the fifth day of Advent of Code 2015, Santa needs help figuring out which strings in his text file are naughty or nice - a.k.a best load up a Regular Expression tester!"><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.38ebe85b7a95b0ed5f3ec14e02666c3ac5666f40e38576814a1bdbdf87e4f477.css integrity="sha256-OOvoW3qVsO1fPsFOAmZsOsVmb0DjhXaBShvb34fk9Hc="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2015-day-5-doesnt-he-have-intern-elves-for-this/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.1052707861642a4eb63c758a2c16cbf5deb3b3ea2582f09f743a7d4c55fb9828.js integrity="sha256-EFJweGFkKk62PHWKLBbL9d6zs+olgvCfdDp9TFX7mCg=" defer></script></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1 class=transition-between-pages style=--id:advent-of-code-2015-day-5-doesnt-he-have-intern-elves-for-this>Advent of Code 2015 - Day 5 - Doesn't He Have Intern-Elves For This?</h1><time class=post__time>Jan 29, 2021</time></header><main class=prose><p>On the fifth day of Advent of Code 2015, Santa needs help figuring out which strings in his text file are <em>naughty or nice</em> - a.k.a best load up a <a href=https://regex101.com/ rel="external noopener" target=_blank>Regular Expression tester</a>!</p><h2 id=part-1>Part 1</h2><p>For part one, we are supplied with several rules which, when combined, determine whether the given string is <em>nice</em>.
String validation rules such as these lend themselves well to Regular Expression pattern matching.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part1</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>isNice</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>line</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>totalVowels</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>match</span>(<span style=color:#e6db74>/[aeiou]/g</span>)<span style=color:#f92672>?</span>.<span style=color:#a6e22e>length</span> <span style=color:#f92672>||</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hasRepeatedLetter</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/([a-z])\1/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>line</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hasRestrictedSequence</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/(ab|cd|pq|xy)/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>line</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>totalVowels</span> <span style=color:#f92672>&gt;=</span> <span style=color:#ae81ff>3</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>hasRepeatedLetter</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#f92672>!</span><span style=color:#a6e22e>hasRestrictedSequence</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;\n&#39;</span>).<span style=color:#a6e22e>filter</span>(<span style=color:#a6e22e>isNice</span>).<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>To tally up all the provided strings (separated by new lines), we define a predicate function (<code>isNice</code>) used within a filter, returning the resulting list&rsquo;s length.</p><p>The predicate function itself validates three separate rules.
The first of which tallies up all the vowels that are present within the string, ensuring that at least three are present.
For the second rule, we ensure that there exists at least one repeated letter pair (such as <code>aa</code> or <code>bb</code>).
To achieve this, we use a <a href=https://javascript.info/regexp-backreferences rel="external noopener" target=_blank>back-reference</a>, which, based on a supplied numbered group (in this case, a single letter <code>[a-z]</code>), ensures that the captured value is present in place of the back-reference location.
The final rule ensures that no restricted letter sequences are present in the string.</p><p>When we combine all these sub-rules, we can validate whether a string is indeed nice.
From here, we can filter down the listing and find the answer total we are looking for ðŸŒŸ.</p><p>We can alternatively leverage more features provided to us by Regular Expressions and solve the problem within a single pattern like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part1</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>match</span>(
</span></span><span style=display:flex><span>    <span style=color:#e6db74>/^(?=(?:.*[aeiou].*){3,})(?=.*(.)\1.*)(?!.*(?:ab|cd|pq|xy).*).*/gm</span>
</span></span><span style=display:flex><span>  ).<span style=color:#a6e22e>length</span>;
</span></span></code></pre></div><p>Using the <a href=https://javascript.info/regexp-multiline-mode rel="external noopener" target=_blank>multiline mode</a>, we change the behaviour of <code>^</code> so that instead of matching only the start of a string, it matches the start of each line.
Combined with three <a href=https://javascript.info/regexp-lookahead-lookbehind rel="external noopener" target=_blank>lookahead</a> patterns, we validate each line as follows:</p><ul><li><code>(?=(?:.*[aeiou].*){3,})</code> - We look for the presence of at least three <code>aeiou</code> character matches anywhere on the line.</li><li><code>(?=.*(.)\1.*)</code> - We ensure that a repeated letter pair appears anywhere on the line.</li><li><code>(?!.*(?:ab|cd|pq|xy).*)</code> - Finally, we ensure that none of the restricted letter sequences appear on the line (using a negative lookahead).</li></ul><p>Using lookaheads in this manner provides us with a form of <code>AND</code> logic, allowing us to evaluate the entire line multiple times.
Although this demonstrates how powerful Regular Expressions can be, I still prefer the first solution due to its readability.</p><h2 id=part-2>Part 2</h2><p>For the next part, we are asked to revise the rules that dictate how we determine a nice string and evaluate the list again.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part2</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>isNice</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>line</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hasRepeatedPairWithoutOverlap</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/([a-z]{2})[a-z]*\1/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>line</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>hasTripletWithRepeatedStartAndEnd</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>/([a-z])[a-z]\1/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>line</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>hasRepeatedPairWithoutOverlap</span> <span style=color:#f92672>&amp;&amp;</span> <span style=color:#a6e22e>hasTripletWithRepeatedStartAndEnd</span>;
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;\n&#39;</span>).<span style=color:#a6e22e>filter</span>(<span style=color:#a6e22e>isNice</span>).<span style=color:#a6e22e>length</span>;
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>We now need to harness back-references in both defined pattern matches.
In the first instance, we must ensure that at least one repeated pair sequence exists (e.g., <code>abcdeab</code>, <code>abab</code>); however, cases of overlapping must be excluded (such as <code>aaa</code> or <code>bbb</code>).
To achieve this, we capture groups of two letters and then ensure that zero or more letters appear before we see this captured group&rsquo;s value again.
The second rule requires that the string includes a letter triplet that contains the same letter at the start and end.
Again, we use a back-reference to capture the starting letter, ensure that a single letter appears in the middle, and finally validate that the captured value is present at the end.</p><p>When we combine these sub-rules, we can validate the string listing again, tallying up how many strings are now deemed nice ðŸŒŸ.</p><p>Again, we can alternatively leverage more features provided to us by Regular Expressions and solve the problem within a single pattern like so:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part2</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>match</span>(<span style=color:#e6db74>/^(?=.*(..).*\1)(?=.*(.).\2.*).*/gm</span>).<span style=color:#a6e22e>length</span>;
</span></span></code></pre></div><p>Using multiline mode, lookahead patterns, and back-references, we evaluate each line based on the given rules as follows:</p><ul><li><code>(?=.*(..).*\1)</code> - We first ensure that at least one repeated pair sequence exists somewhere within the line.</li><li><code>(?=.*(.).\2.*)</code> - We also ensure that there exists a letter triplet that contains the same letter at the start and end within the line.</li></ul><p>Combined, these patterns form our validation logic, allowing us to match and return the total number of lines that conform to the rule set.</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/advent-of-code-2015>advent-of-code-2015</a><a href=/archive/tag/typescript>typescript</a></footer></article><div class="related-posts prose"><h3>Related Posts</h3><ul><li><a href=/posts/advent-of-code-2015-day-4-the-ideal-stocking-stuffer/>Advent of Code 2015 - Day 4 - The Ideal Stocking Stuffer</a></li><li><a href=/posts/advent-of-code-2015-day-3-perfectly-spherical-houses-in-a-vacuum/>Advent of Code 2015 - Day 3 - Perfectly Spherical Houses in a Vacuum</a></li><li><a href=/posts/advent-of-code-2015-day-2-i-was-told-there-would-be-no-math/>Advent of Code 2015 - Day 2 - I Was Told There Would Be No Math</a></li><li><a href=/posts/advent-of-code-2015-day-1-not-quite-lisp/>Advent of Code 2015 - Day 1 - Not Quite Lisp</a></li><li><a href=/posts/implementing-a-compound-set-in-typescript/>Implementing a Compound Set in TypeScript</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div><button class=theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>