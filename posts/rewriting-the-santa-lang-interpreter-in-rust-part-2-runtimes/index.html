<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes - Edd Mann</title>
<meta name=description content="This blog series details my experience rewriting the santa-lang interpreter in Rust. In this post, I delve into how I integrated the core language library with the desired (delivery) runtimes."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes"><meta itemprop=description content="With the core language library now written, I could go about building the desired (delivery) runtimes. In this post within the series, I will delve into my experience integrating the core language library with these chosen runtimes, documenting some of the challenges that I faced along the way."><meta itemprop=datePublished content="2023-08-06T00:00:00+00:00"><meta itemprop=dateModified content="2023-08-06T00:00:00+00:00"><meta itemprop=wordCount content="1125"><meta itemprop=keywords content="Rust,Santa-Lang,Interpreter,Santa-Lang-in-Rust-Series"><meta property="og:url" content="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes"><meta property="og:description" content="With the core language library now written, I could go about building the desired (delivery) runtimes. In this post within the series, I will delve into my experience integrating the core language library with these chosen runtimes, documenting some of the challenges that I faced along the way."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-08-06T00:00:00+00:00"><meta property="article:modified_time" content="2023-08-06T00:00:00+00:00"><meta property="article:tag" content="Rust"><meta property="article:tag" content="Santa-Lang"><meta property="article:tag" content="Interpreter"><meta property="article:tag" content="Santa-Lang-in-Rust-Series"><meta name=twitter:card content="summary"><meta name=twitter:title content="Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes"><meta name=twitter:description content="With the core language library now written, I could go about building the desired (delivery) runtimes. In this post within the series, I will delve into my experience integrating the core language library with these chosen runtimes, documenting some of the challenges that I faced along the way."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.866f0dbf24963ef6aab7a870ac4f1e5617707e4531cb5ea08f18fc7918a154c4.css integrity="sha256-hm8NvySWPvaqt6hwrE8eVhdwfkUxy16gjxj8eRihVMQ="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1 class=transition-between-pages style=--id:rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes>Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes</h1><time class=post__time>Aug 6, 2023</time></header><main class=prose><p>With the <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/>core language library</a> now written, I could go about building the desired (delivery) runtimes.
In this post within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>, I will delve into my experience integrating the core language library with these chosen runtimes, documenting some of the challenges that I faced along the way.</p><p>The TypeScript implementation of the santa-lang interpreter included CLI, Web, and Lambda runtimes.
I decided to tackle these in this order of importance, as I required at least the CLI to begin testing the interpreter on real solutions.</p><h2 id=cli>CLI</h2><p>I intentionally decided to write the CLI with minimal package dependencies.
There are many useful <a href=https://github.com/clap-rs/clap rel="external noopener" target=_blank>crates</a> available to assist in CLI development, but I did not feel like I needed the additional features they provided at this time.
I did, however, use a <a href=https://github.com/kkawakam/rustyline rel="external noopener" target=_blank>crate</a> to provide the ability to start up an interactive shell via <em>readline</em> support.
The runtime itself included I/O <em>external functions</em> <code>puts</code> and <code>read</code>, which had feature parity with the TypeScript implementation.
This included POSIX support for reading files from disk, fetching contents from HTTP endpoints, and the AoC schema I had devised when first designing santa-lang.
I was able to provide test coverage for this delivery using the <a href=https://docs.rs/assert_cmd/latest/assert_cmd/ rel="external noopener" target=_blank>assert_cmd</a> crate.
This provided me with confidence that I had correctly integrated the library with the delivery.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_c9aba6f70a0f116d.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_5225f7e447a0d3f0.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_2bcc50662435bb5c.webp 1084w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_994937b6930a8f74.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_802966dc834345d.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_b35a8e4afe7f0bc8.jpg 1084w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-runner_hu_802966dc834345d.jpg alt="CLI Runner" loading=lazy>
</picture><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_c435f2d2c29114da.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_674f0155f3296ae7.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_fe5d914b1f55e549.webp 1084w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_20225d4bec414879.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_4253704a16d6c5df.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_1479fad66c7a5e15.jpg 1084w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/cli-repl_hu_4253704a16d6c5df.jpg alt="CLI REPL" loading=lazy></picture></p><p>To aid in performance benchmarking, I added the ability to compile the runtime with <a href=https://github.com/tikv/pprof-rs rel="external noopener" target=_blank>pprof</a> code profiling (via a <a href=https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/cli/Cargo.toml#L26 rel="external noopener" target=_blank><code>profile</code></a> feature flag).
The chosen library also allowed me to produce <a href=https://www.brendangregg.com/flamegraphs.html rel="external noopener" target=_blank>flame graphs</a>, which were used extensively throughout development to help pinpoint areas where performance could be improved.
Further discussion on performance will be documented in the <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/>next post</a> within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>.</p><h2 id=web-wasm>Web (WASM)</h2><p>The TypeScript interpreter being transpiled into JavaScript made it already well-suited for <em>Web platform</em> usage.
This required very little additional effort on my part.
To provide use of this interpreter within the <a href=https://eddmann.com/santa-lang-editor/>Web-based code editor</a> and Browsers/Node in general, I needed to leverage WebAssembly (WASM).
Having had <a href=/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/>experience</a> with this before, I was again surprised at how easy it was to achieve.
Not only was I able to trivially expose the language as a WASM library, but I could also provide the ability to include user-land JavaScript functions as external functions (similar to the TypeScript implementation), as shown below:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-ts data-lang=ts><span style=display:flex><span><span style=color:#66d9ef>import</span> { <span style=color:#a6e22e>evaluate</span> } <span style=color:#66d9ef>from</span> <span style=color:#e6db74>&#39;@eddmann/santa-lang-wasm&#39;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>evaluate</span>(<span style=color:#e6db74>&#39;[1, 2, 3] |&gt; map(_ + 1) |&gt; sum&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>evaluate</span>(<span style=color:#e6db74>&#39;puts(&#34;Hello, world&#34;)&#39;</span>, { <span style=color:#a6e22e>puts</span>: <span style=color:#66d9ef>console.log.bind</span>(<span style=color:#a6e22e>console</span>) });
</span></span></code></pre></div><p>The runtime required me to enable the <a href=https://github.com/eddmann/santa-lang-rs/blob/d56cd6748111dc22f078a6eb554c80476342d033/lang/Cargo.toml#L18 rel="external noopener" target=_blank><code>serde</code></a> feature support, which I had included within the core language library, to make it possible to represent compatible data structures between JavaScript and santa-lang.
Being enabled on a per-runtime basis ensured that any additional overheads would not impact other runtimes.
The Runner instance used the <a href=https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/wasm/src/lib.rs#L16-L21 rel="external noopener" target=_blank><code>Time</code></a> trait with a specific WASM implementation to determine the execution time of solutions.
Similar to the CLI, I was able to garner confidence in the desired behaviour by using a <a href=https://crates.io/crates/wasm-bindgen-test rel="external noopener" target=_blank>testing</a> crate, which allowed me to verify correctness of the compiled library within both Node and Chrome-browser environments.</p><p>With very <a href=https://github.com/eddmann/santa-lang-editor/blob/b27aeddc19444003cb5d39704d934e733e05bb86/worker.ts rel="external noopener" target=_blank>few changes</a>, I was then able to update the <a href=https://eddmann.com/santa-lang-editor/>Web-based code editor</a> to use this new interpreter.
On top of this, I had begun <a href=https://eddmann.com/santa-lang/>documenting</a> the language specification and features it had to offer using <a href=https://www.mkdocs.org/ rel="external noopener" target=_blank>MkDocs</a>.
I decided to additionally add <a href=https://github.com/eddmann/santa-lang/blob/f55c6d085118bc9ae6a269e2f57ef415b57b96eb/runner/runner.js rel="external noopener" target=_blank>executable examples</a> using this library, which exercised the runtime in a different context.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_c112a10dcee7ffe9.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_92dd6e29893e7d10.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_3640d1582844f526.webp 1400w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_4f7cafe7de8ada6d.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_7490b0e13fc9b1fb.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_be69487dbab8c0cf.jpg 1400w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/web-editor_hu_7490b0e13fc9b1fb.jpg alt="Web Editor" loading=lazy></picture></p><h2 id=lambda>Lambda</h2><p>I had initially developed the Lambda runtime in TypeScript for use within last year&rsquo;s <a href=/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/>Secret Santa Allocation</a> project.
I wanted to provide feature parity and implement such a runtime in Rust.
To achieve this, I borrowed ideas from the <a href=https://github.com/eddmann/santa-lang-ts/blob/aa0a2a53d6dab80e844d4c87183a1f3936d1a7f5/src/lambda/src/index.ts rel="external noopener" target=_blank>Node version</a>, conforming to the <a href=https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html rel="external noopener" target=_blank>Lambda runtime API</a> and expected request/response lifecycle.
I used the lightweight <a href=https://crates.io/crates/ureq/0.9.0 rel="external noopener" target=_blank>ureq</a> crate to handle HTTP transport between the compiled <em>bootstrap</em> and the Lambda runtime environment.
Due to Lambda&rsquo;s heavy reliance on JSON for transport, I again enabled the <code>serde</code> feature support (similar to the WASM runtime) that had been added to the core language library to handle converting santa-lang data structures to and from their JSON equivalents.
I was pleasantly surprised at how performant this runtime was in practice, with very little overhead and a small binary size.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_1d9f5f93df98b467.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_60a48eb56b1a1e8.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_c6b2ab67c3a10242.webp 1400w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_4ab1d0ec32f6f27.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_b9d1d97e790b335f.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_ef6681676b41e6c8.jpg 1400w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/lambda-runtime_hu_b9d1d97e790b335f.jpg alt="Lambda Runtime" loading=lazy></picture></p><h2 id=php-extension>PHP Extension</h2><p>One evening, I spotted an interesting <a href=https://github.com/davidcole1340/ext-php-rs rel="external noopener" target=_blank>crate</a>, which provided an abstraction around creating PHP extensions within Rust.
As all I had been thinking about over the past several months was santa-lang, the first thing that came into my mind was: could I make a runtime for it?!
So, I set about creating a <a href=https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/php-ext/src/lib.rs rel="external noopener" target=_blank>simple extension</a> that provided user-land PHP with the ability to evaluate santa-lang code, along with AoC solutions.</p><p>I had <a href=/posts/introduction-to-creating-a-basic-php-extension/>limited</a> <a href=/posts/php-extension-development-for-beginners-with-joe-watkins/>experience</a> in writing PHP extensions in the past and really enjoyed how this crate abstracted away any need for C macros and <code>zend_</code> magic.
It was interesting constructing PHP associative arrays (Zend Hash Tables) for each of the exposed PHP functions&rsquo; return values.
This certainly isn&rsquo;t the most useful runtime, but it does document how easy it is to expose Rust-based code in a higher-level language without needing to resort to C.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#f92672>&lt;?</span><span style=color:#a6e22e>php</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$solution <span style=color:#f92672>=</span> <span style=color:#a6e22e>file_get_contents</span>(<span style=color:#66d9ef>__DIR__</span> <span style=color:#f92672>.</span> <span style=color:#e6db74>&#39;/solution.santa&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>santa_aoc_run</span>($solution, <span style=color:#a6e22e>cwd</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>__DIR__</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>santa_aoc_test</span>($solution);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>santa_evaluate</span>(<span style=color:#e6db74>&#39;1.. |&gt; filter(_ % 2) |&gt; take(3);&#39;</span>);
</span></span></code></pre></div><p>Along with providing this PHP extension support, there is future scope to expose the interpreter within <a href=https://github.com/PyO3/pyo3 rel="external noopener" target=_blank>Python</a>.
This crate looks to expose a similar level of abstraction as the PHP one.</p><h2 id=jupyter-kernel>Jupyter Kernel</h2><p>Over the past several months, I have been introduced to the power of <a href=https://jupyter.org/ rel="external noopener" target=_blank>Jupyter Notebook</a> and the fast REPL it provides.
This is in large part due to every AI/LLM YouTube video or post I see using it (due to the authors coming from Data Science backgrounds).
Similar to the PHP extension, my mind wandered into the possibility of creating a custom <a href=https://docs.jupyter.org/en/latest/projects/kernels.html rel="external noopener" target=_blank>Kernel</a> to expose the santa-lang language as an additional runtime.</p><p>Thanks to yet another well-thought-out <a href=https://crates.io/crates/jupyter rel="external noopener" target=_blank>crate</a>, this task proved to be rather seamless.
There was one caveat, however, in that the crate used asynchronous execution to handle language server requests.
This caused issues with the <code>Rc&lt;RefCell&lt;Environment>></code> type that is required to model script state during evaluation.
As santa-lang&rsquo;s core language is designed to be single-threaded, I was required to add <em>unsafe</em> <code>Sendable</code> and <code>Sync</code> trait implementations to a wrapper <a href=https://github.com/eddmann/santa-lang-rs/blob/a36476d3d7adcc68980b56465c5c0ee891c831db/runtime/jupyter/src/main.rs#L14-L17 rel="external noopener" target=_blank><code>SharedEnvironment</code></a> type to appease the compiler (a big no-no!).</p><p>This is certainly not production-ready, but as a proof of concept, it was fun to build.
It also make me interested to see how I could possibly use a notebook to help develop Advent of Code solutions in the future.</p><p><picture><source type=image/webp srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_47e4fa9fd6ab5104.webp 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_891d971b8fac6ab9.webp 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_6dba48992fa8b9f5.webp 1400w"><source type=image/jpeg srcset="/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_2eb5007029e85347.jpg 350w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_3767cf9b0953031e.jpg 700w, /posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_5944c235a9111ff0.jpg 1400w"><img src=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-2-runtimes/jupyter-kernel_hu_3767cf9b0953031e.jpg alt="Jupyter Kernel" loading=lazy></picture></p><h2 id=whats-next>What&rsquo;s Next?</h2><p>Now that all the desired runtimes have been implemented, it is finally time to investigate performance considerations!
In the <a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/>next post</a> within the <a href=/archive/tag/santa-lang-in-rust-series>series</a>, I will document how I went about benchmarking the two implementations, greatly improving performance, and highlighting interesting findings along the way.</p></main><footer class=post__tags><a href=/archive/tag/rust>rust</a><a href=/archive/tag/santa-lang>santa-lang</a><a href=/archive/tag/interpreter>interpreter</a><a href=/archive/tag/santa-lang-in-rust-series>santa-lang-in-rust-series</a></footer></article><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;setTimeout(()=>{const s=window.pageYOffset;n.classList.toggle("is-sticky",s>0&&t>s),t=s,e=!1},500),e=!0})})()</script></body></html>