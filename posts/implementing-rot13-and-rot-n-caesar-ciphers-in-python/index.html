<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Implementing ROT13 and ROT(n) Caesar Ciphers in Python - Edd Mann</title>
<meta name=description content="Discover multiple techniques to encode and decode messages using ROT13 and ROT(n) Caesar ciphers in Python, with practical examples and clear explanations."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Implementing ROT13 and ROT(n) Caesar Ciphers in Python"><meta itemprop=description content="The Caesar cipher (shift cipher) is an extremely simple encryption technique. Substitutions of this kind rely on an invariant - replacing each plain-text letter with the letter at a fixed number of positions across the alphabet. The recipient is then able to decode the encoded message successfully if they are aware of the chosen shift."><meta itemprop=datePublished content="2014-04-12T00:00:00+00:00"><meta itemprop=dateModified content="2014-04-12T00:00:00+00:00"><meta itemprop=wordCount content="567"><meta itemprop=keywords content="Python,Algorithms,Encryption"><meta property="og:url" content="https://eddmann.com/posts/implementing-rot13-and-rot-n-caesar-ciphers-in-python/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Implementing ROT13 and ROT(n) Caesar Ciphers in Python"><meta property="og:description" content="The Caesar cipher (shift cipher) is an extremely simple encryption technique. Substitutions of this kind rely on an invariant - replacing each plain-text letter with the letter at a fixed number of positions across the alphabet. The recipient is then able to decode the encoded message successfully if they are aware of the chosen shift."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-04-12T00:00:00+00:00"><meta property="article:modified_time" content="2014-04-12T00:00:00+00:00"><meta property="article:tag" content="Python"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Encryption"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing ROT13 and ROT(n) Caesar Ciphers in Python"><meta name=twitter:description content="The Caesar cipher (shift cipher) is an extremely simple encryption technique. Substitutions of this kind rely on an invariant - replacing each plain-text letter with the letter at a fixed number of positions across the alphabet. The recipient is then able to decode the encoded message successfully if they are aware of the chosen shift."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.a18bbea58d05187498ffb7d6a33b580609df2e92b988055a4b51e41596cc934e.css integrity="sha256-oYu+pY0FGHSY/7fWoztYBgnfLpK5iAVaS1HkFZbMk04="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/implementing-rot13-and-rot-n-caesar-ciphers-in-python/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.7f6917401c23509595a4da9144cfe3c8fde343c0352e6d627aa366129e1bdb48.js integrity="sha256-f2kXQBwjUJWVpNqRRM/jyP3jQ8A1Lm1ieqNmEp4b20g=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:implementing-rot13-and-rot-n-caesar-ciphers-in-python>Implementing ROT13 and ROT(n) Caesar Ciphers in Python</h1><time datetime=2014-04-12T00:00:00Z class=published-at>Apr 12, 2014</time></header><main class=u-prose><p>The Caesar cipher (shift cipher) is an extremely simple encryption technique.
Substitutions of this kind rely on an invariant - replacing each plain-text letter with the letter at a fixed number of positions across the alphabet.
The recipient is then able to decode the encoded message successfully if they are aware of the chosen shift.</p><p>ROT13 (also known as rotate by 13 places) is an implementation of this cipher.
It replaces each letter with the letter 13 positions later in the given symbol table (typically the alphabet).
As the basic Latin alphabet is 26 letters long, the same algorithm can be used to decode an encoded message.</p><h2 id=basic-implementation>Basic Implementation</h2><p>Using Python 3.4 as the implementation language, we are able to simply use the provided (<em>batteries included</em>) &rsquo;encode&rsquo; method as shown below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rot13</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> codecs <span style=color:#f92672>import</span> encode
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> encode(s, <span style=color:#e6db74>&#39;rot13&#39;</span>)
</span></span></code></pre></div><h2 id=mapping-implementation>Mapping Implementation</h2><p>The above implementation is extremely useful.
However, it does not give us a feel for how the algorithm works from first principles.
The example below highlights the same functionality (limited to the Latin alphabet) by mapping each character in the subject string.
Each character is passed into the <code>lookup</code> function that returns the valid replacement value without altering non-alphabet characters.
I would like to highlight Python&rsquo;s ability to succinctly express range conditions using standard chained comparisons.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rot13_alpha</span>(s):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>lookup</span>(v):
</span></span><span style=display:flex><span>        o, c <span style=color:#f92672>=</span> ord(v), v<span style=color:#f92672>.</span>lower()
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;a&#39;</span> <span style=color:#f92672>&lt;=</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;m&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> chr(o <span style=color:#f92672>+</span> <span style=color:#ae81ff>13</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> <span style=color:#e6db74>&#39;n&#39;</span> <span style=color:#f92672>&lt;=</span> c <span style=color:#f92672>&lt;=</span> <span style=color:#e6db74>&#39;z&#39;</span>:
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> chr(o <span style=color:#f92672>-</span> <span style=color:#ae81ff>13</span>)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> v
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(map(lookup, s))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rot13_alpha(<span style=color:#e6db74>&#39;Hello World&#39;</span>) <span style=color:#75715e># Uryyb Jbeyq</span>
</span></span></code></pre></div><h2 id=generic-alphabet-shift-implementation>Generic Alphabet Shift Implementation</h2><p>Using Python&rsquo;s string translation functionality, I was able to create a more generic implementation that allows you to specify the shift length.
I decided on using partial function application to allow for rotation functions to be composed and reused.
For example, the use-case below follows a single invocation of the initially implemented function.
We could have instead assigned this function to a variable (say <code>rot13</code>) and called it at will.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rot_alpha</span>(n):
</span></span><span style=display:flex><span>    <span style=color:#f92672>from</span> string <span style=color:#f92672>import</span> ascii_lowercase <span style=color:#66d9ef>as</span> lc, ascii_uppercase <span style=color:#66d9ef>as</span> uc
</span></span><span style=display:flex><span>    lookup <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span>maketrans(lc <span style=color:#f92672>+</span> uc, lc[n:] <span style=color:#f92672>+</span> lc[:n] <span style=color:#f92672>+</span> uc[n:] <span style=color:#f92672>+</span> uc[:n])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>lambda</span> s: s<span style=color:#f92672>.</span>translate(lookup)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rot_alpha(<span style=color:#ae81ff>13</span>)(<span style=color:#e6db74>&#39;Hello World&#39;</span>) <span style=color:#75715e># Uryyb Jbeyq</span>
</span></span></code></pre></div><h2 id=generic-shift-implementation>Generic Shift Implementation</h2><p>The final implementation limitation is that it only handles Latin alphabet symbols.
If we would like to use ROT5 for number encoding, this would require a separate implementation.
The example below removes this constraint, allowing the user to pass in each of the symbol strings they wish to permit for encoding.
These passed-in values are used to create an encoded lookup table based on the shift length (similar to the previous example).
Finally, the lookup table is used by Python&rsquo;s string translation method to return the processed value.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>rot</span>(<span style=color:#f92672>*</span>symbols):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>_rot</span>(n):
</span></span><span style=display:flex><span>        encoded <span style=color:#f92672>=</span> <span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(sy[n:] <span style=color:#f92672>+</span> sy[:n] <span style=color:#66d9ef>for</span> sy <span style=color:#f92672>in</span> symbols)
</span></span><span style=display:flex><span>        lookup <span style=color:#f92672>=</span> str<span style=color:#f92672>.</span>maketrans(<span style=color:#e6db74>&#39;&#39;</span><span style=color:#f92672>.</span>join(symbols), encoded)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>lambda</span> s: s<span style=color:#f92672>.</span>translate(lookup)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> _rot
</span></span></code></pre></div><p>The following example highlights number encoding by five positions.
We are able to compose a new function based on the partial application nature of the <code>rot</code> function.
Latin alphabet encoding is also present with the five position length invariant.
I would like to note that a separate decode implementation is required (-N), as unlike ROT13 the encode algorithm is not its own inverse.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>rot5_num <span style=color:#f92672>=</span> rot(<span style=color:#e6db74>&#39;0123456789&#39;</span>)(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>rot5_num(<span style=color:#e6db74>&#39;1234&#39;</span>) <span style=color:#75715e># 6789</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>rot_alpha <span style=color:#f92672>=</span> rot(ascii_lowercase, ascii_uppercase)
</span></span><span style=display:flex><span>rot5_alpha_enc <span style=color:#f92672>=</span> rot_alpha(<span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>rot5_alpha_dec <span style=color:#f92672>=</span> rot_alpha(<span style=color:#f92672>-</span><span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>enc <span style=color:#f92672>=</span> rot5_alpha_enc(<span style=color:#e6db74>&#39;Hello World&#39;</span>) <span style=color:#75715e># Mjqqt Btwqi</span>
</span></span><span style=display:flex><span>rot5_alpha_dec(enc) <span style=color:#75715e># Hello World</span>
</span></span></code></pre></div></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/python>python</a></li><li><a href=/archive/tag/algorithms>algorithms</a></li><li><a href=/archive/tag/encryption>encryption</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/using-iterative-deepening-depth-first-search-in-python/>Using Iterative deepening depth-first search in Python</a></li><li><a href=/posts/depth-first-search-and-breadth-first-search-in-python/>Depth-First Search and Breadth-First Search in Python</a></li><li><a href=/posts/functional-quick-sort-in-scala-and-javascript/>Functional Quick sort in Scala and JavaScript</a></li><li><a href=/posts/parallel-summation-in-java/>Parallel Summation in Java</a></li><li><a href=/posts/creating-a-basic-auth-wsgi-middleware-in-python/>Creating a Basic Auth. WSGI Middleware in Python</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>