<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Sql on Edd Mann</title><link>https://eddmann.com/archive/tag/sql/</link><description>Recent content in Sql on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Tue, 12 Apr 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/sql/index.xml" rel="self" type="application/rss+xml"/><item><title>Operations on a Deck of Cards in PostgreSQL</title><link>https://eddmann.com/posts/operations-on-a-deck-of-cards-in-postgresql/</link><pubDate>Tue, 12 Apr 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/operations-on-a-deck-of-cards-in-postgresql/</guid><description>&lt;p>Recently, I have been looking more into SQL and, in particular, how RDBMSs work under the hood.
I thought it would be interesting to use some of the lesser-known features that PostgreSQL has to offer, concentrating my efforts on operations performed on a deck of cards.&lt;/p></description></item><item><title>Using the 'IS (NOT) DISTINCT FROM' SQL Comparators</title><link>https://eddmann.com/posts/using-the-is-not-distinct-from-sql-comparators/</link><pubDate>Thu, 17 Mar 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/using-the-is-not-distinct-from-sql-comparators/</guid><description>&lt;p>In a recent SQL statement, I stumbled upon an issue regarding the handling of &lt;code>NULL&lt;/code> values within a given predicate.
Coming from languages such as PHP, which are very liberal in their type coercion (&lt;code>NULL&lt;/code> can be treated as a falsy value), I was surprised to find how the inclusion of such a value resulted in a sort of predicate short-circuiting.&lt;/p></description></item><item><title>Maintaining Invariant Constraints in PostgreSQL using Trigger Functions</title><link>https://eddmann.com/posts/maintaining-invariant-constraints-in-postgresql-using-trigger-functions/</link><pubDate>Thu, 03 Mar 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/maintaining-invariant-constraints-in-postgresql-using-trigger-functions/</guid><description>&lt;p>Recently, a feature I was working on required me to alter a unique constraint that existed on a table column.
The invariant had now been weakened to allow storing of duplicate &lt;code>email&lt;/code> addresses, provided they shared an equivalent &lt;code>link_id&lt;/code> (excluding &lt;code>NULL&lt;/code>).
Sadly, the ease with which I had initially added the general unique constraint had disappeared.
However, I was able to take advantage of insertion/update triggers to regain these invariant reassurances.&lt;/p></description></item><item><title>Conditional Expressions in PostgreSQL</title><link>https://eddmann.com/posts/conditional-expressions-in-postgresql/</link><pubDate>Tue, 12 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/conditional-expressions-in-postgresql/</guid><description>&lt;p>There may be a case where you need to make sure only a single row value is &lt;code>true&lt;/code> in a collection of results.
A common pattern for performing such a task is to set all values to &lt;code>false&lt;/code> in the collection, and then set the desired one to &lt;code>true&lt;/code>.&lt;/p></description></item></channel></rss>