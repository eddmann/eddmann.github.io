<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Exploration into handling asynchronous calls within the Flux architecture">

    <title>
        
            Asynchronous Calls within Flux &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
        <link rel="canonical" href="https://tech.mybuilder.com/asynchronous-calls-within-flux/" />
    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Asynchronous Calls within Flux</h1>
    <time datetime="2015-10-28T00:00:00+00:00" class="post-date">28 Oct 2015</time>
    <p>The Flux architecture abides by a single unidirectional data-flow throughout the entire application.
This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies.
However, one issue we faced in our recently updated interface tradesmen use to communicate with customers, was how to handle asynchronous calls within these constraints.
Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries.</p>



<h2 id="basic-component-example">Basic Component Example</h2>

<p>There is a common use-case within client-side applications to both push and fetch data from an external resource asynchronously.
In the contrived component below we provide the client with the ability to act upon the enter-key being hit with a supplied submission handler.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">TaskInput</span> <span class="kd">extends</span> <span class="nx">React</span><span class="p">.</span><span class="nx">Component</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">ENTER_KEY</span> <span class="o">=</span> <span class="mi">13</span><span class="p">;</span>

  <span class="nx">_handleSubmit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">e</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">keyCode</span> <span class="o">===</span> <span class="nx">ENTER_KEY</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">onSubmit</span><span class="p">(</span><span class="nx">e</span><span class="p">.</span><span class="nx">target</span><span class="p">.</span><span class="nx">value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nx">e</span><span class="p">.</span><span class="nx">preventDefault</span><span class="p">();</span>
  <span class="p">};</span>

  <span class="nx">render</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">&lt;</span><span class="nx">input</span> <span class="nx">type</span><span class="o">=</span><span class="dl">"</span><span class="s2">text</span><span class="dl">"</span> <span class="nx">onKeyUp</span><span class="o">=</span><span class="p">{</span><span class="k">this</span><span class="p">.</span><span class="nx">_handleSubmit</span><span class="p">}</span> <span class="sr">/&gt;</span><span class="err">;
</span>  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="asynchronous-calls-within-components">Asynchronous Calls within Components</h2>

<p>We initially decided to keep the asynchronous call and response logic within the component itself.
This included the dispatch of either a success or fail action upon handling the result - due to external resource concerns (i.e. network issues, server-based validation) we could not be sure that a successful path would always occur.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">postJson</span> <span class="o">=</span> <span class="p">(</span><span class="nx">endpoint</span><span class="p">,</span> <span class="nx">payload</span><span class="p">)</span> <span class="o">=&gt;</span>
  <span class="nx">fetch</span><span class="p">(</span><span class="nx">endpoint</span><span class="p">,</span> <span class="p">{</span>
    <span class="na">method</span><span class="p">:</span> <span class="dl">'</span><span class="s1">post</span><span class="dl">'</span><span class="p">,</span>
    <span class="na">headers</span><span class="p">:</span> <span class="p">{</span> <span class="dl">'</span><span class="s1">Content-Type</span><span class="dl">'</span><span class="p">:</span> <span class="dl">'</span><span class="s1">application/json</span><span class="dl">'</span> <span class="p">},</span>
    <span class="na">body</span><span class="p">:</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">(</span><span class="nx">payload</span><span class="p">),</span>
  <span class="p">});</span>
</code></pre></div></div>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">TaskInput</span>
  <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">message</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="nx">postJson</span><span class="p">(</span><span class="dl">'</span><span class="s1">/post</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">message</span> <span class="p">})</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span> <span class="o">=&gt;</span> <span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">RECEIVE_TASK</span><span class="dl">'</span><span class="p">,</span> <span class="nx">task</span> <span class="p">}))</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">TASK_ERROR</span><span class="dl">'</span><span class="p">,</span> <span class="nx">error</span> <span class="p">}));</span>
  <span class="p">}}</span>
<span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p><img src="/uploads/asynchronous-calls-within-flux/asynchronous-calls-within-components.png" alt="Asynchronous Calls within Components" /></p>

<p>Although the above paradigm worked, we noticed many issues arise from its presence.
The first of which was how all the logic had now been co-located within the view layer.
You could question, that at this level is it necessary to know of these low-level details - about how we were submitting a task.
More strongly put, creating and handling the external resource request did not seem to be a responsibly of the component at all.
This coupling in turn made it harder to test the components behavior, as now to validate that a submission is sent we were required to provide an environment where (the implementation detail) <code class="language-plaintext highlighter-rouge">fetch</code> is present.
Finally, the component itself was the only member of the system that knew of the clients desire to add the task.
It is not until the request had been resolved or rejected did we let the dispatcher (and in-turn the system as a whole) know about this intent and resolution.</p>

<h2 id="web-api-and-action-creator-addition">Web API and Action Creator Addition</h2>

<p>To begin trying to resolve these highlighted issues we decided to first abstract out the two raw dispatch calls into an ‘<a href="https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html#actions-and-action-creators">Action Creator</a>’.
This allowed us to devise a clean API which did not concern the callee of what dispatch calls etc. were being fired in response to their invocation.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ServerActions</span> <span class="p">{</span>
  <span class="nx">receiveTask</span><span class="p">(</span><span class="nx">task</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">RECEIVE_TASK</span><span class="dl">'</span><span class="p">,</span> <span class="nx">task</span> <span class="p">});</span>
  <span class="p">}</span>
  <span class="nx">taskError</span><span class="p">(</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">TASK_ERROR</span><span class="dl">'</span><span class="p">,</span> <span class="nx">error</span> <span class="p">});</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Using this Action Creator we then went about abstracting out the external API call into an ‘Web API’, supplying the available server actions at runtime.
This provided us with the ability to easily swap out real actions with test doubles, validating the correctness of API calls within the testing phase.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">WebAPI</span> <span class="p">{</span>
  <span class="nx">serverActions</span><span class="p">;</span>

  <span class="c1">// ...</span>

  <span class="nx">addTask</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">postJson</span><span class="p">(</span><span class="dl">'</span><span class="s1">/post</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">message</span> <span class="p">})</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">serverActions</span><span class="p">.</span><span class="nx">receiveTask</span><span class="p">(</span><span class="nx">task</span><span class="p">))</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">serverActions</span><span class="p">.</span><span class="nx">taskError</span><span class="p">(</span><span class="nx">error</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With the addition of these two members, we could simply replace the submission logic found in the component with a call directly to the Web API.
This refactoring made it easier to now test the component in isolation as well, with only a Web API test double instance being required.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">TaskInput</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">message</span> <span class="o">=&gt;</span> <span class="nx">webApi</span><span class="p">.</span><span class="nx">addTask</span><span class="p">(</span><span class="nx">message</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p><img src="/uploads/asynchronous-calls-within-flux/web-api-and-action-creator-addition.png" alt="Web API and Action Creator Addition" /></p>

<p>However, there were still issues that persisted after this refactoring.
Still the component and now additionally Web API, were the only ones aware of this action being carried out within the system.
At present, there was no way of providing the user with an optimistic representation of what the application state would look like - not until the response had been returned.</p>

<h2 id="optimistic-asynchronous-calls">Optimistic Asynchronous Calls</h2>

<p>At present, as we are not sure when the asynchronous call will return, we did not notify the system of any event until the promise had been resolved or rejected.
However, we felt that it would be a far better user experience to optimistically apply the request to the current client state and reconcile this action when the asynchronous event returned.</p>

<p>To achieve this we decided to abstract out the call made to the Web API into its own action creator.
We then dispatched a new action which, provided with a unique client id, optimistically performed the resulting resolution.
It would then go about calling the Web API as per the previous implementation.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">ClientActions</span> <span class="p">{</span>
  <span class="nx">webApi</span><span class="p">;</span>

  <span class="c1">// ...</span>

  <span class="nx">addTask</span><span class="p">(</span><span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="nx">clientId</span> <span class="o">=</span> <span class="nx">uniqueId</span><span class="p">();</span>

    <span class="nx">dispatch</span><span class="p">({</span> <span class="na">type</span><span class="p">:</span> <span class="dl">'</span><span class="s1">ADD_TASK</span><span class="dl">'</span><span class="p">,</span> <span class="nx">clientId</span><span class="p">,</span> <span class="nx">message</span> <span class="p">});</span>

    <span class="k">this</span><span class="p">.</span><span class="nx">webApi</span><span class="p">.</span><span class="nx">addTask</span><span class="p">(</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">message</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Looking at the implementation above you will notice that we generated a random <code class="language-plaintext highlighter-rouge">clientId</code> which is used to temporary identify the created resource until the external API provides us with an canonical id.
The Web API and server actions were in-turn required to be altered to cater for this temporary identifier.
Stores that were concerned with this action could add the pending resource as they desired, maybe including it with appended meta information (i.e. status: ‘ADDING’).
Finally, when the result from the asynchronous request had been received, the stores could go about reconciling their state i.e. replacing the temporary id with the supplied one or removing it if there had been an error.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">class</span> <span class="nx">WebApi</span> <span class="p">{</span>
  <span class="nx">serverActions</span><span class="p">;</span>

  <span class="c1">// ...</span>

  <span class="nx">addTask</span><span class="p">(</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">message</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">postJson</span><span class="p">(</span><span class="dl">'</span><span class="s1">/post</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="nx">message</span> <span class="p">})</span>
      <span class="p">.</span><span class="nx">then</span><span class="p">(</span><span class="nx">task</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">serverActions</span><span class="p">.</span><span class="nx">recieveTask</span><span class="p">(</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">task</span><span class="p">))</span>
      <span class="p">.</span><span class="k">catch</span><span class="p">(</span><span class="nx">err</span> <span class="o">=&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">serverActions</span><span class="p">.</span><span class="nx">taskError</span><span class="p">(</span><span class="nx">clientId</span><span class="p">,</span> <span class="nx">error</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We could now access the updated task action by way of the client actions creator abstraction.</p>

<div class="language-js highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&lt;</span><span class="nx">TaskInput</span> <span class="nx">onSubmit</span><span class="o">=</span><span class="p">{</span><span class="nx">message</span> <span class="o">=&gt;</span> <span class="nx">clientActions</span><span class="p">.</span><span class="nx">addTask</span><span class="p">(</span><span class="nx">message</span><span class="p">)}</span> <span class="sr">/</span><span class="err">&gt;
</span></code></pre></div></div>

<p><img src="/uploads/asynchronous-calls-within-flux/optimistic-asynchronous-calls.png" alt="Optimistic Asynchronous Calls" /></p>

<p>To conclude, this final refactoring allowed us to clearly visualise and work within specific boundaries of the application, all with there own rates of change.
We have found a significant ease in testing areas of the application in isolation, as well as a far easier to reason about mental model.
Below is a list of some of the key strengths within testing that we have found since incorporating this model into our architecture:</p>

<ul>
  <li>We can easily validate the correctness of Components contractual calls to Client Actions.</li>
  <li>Client Actions can be tested by assertion of store state after they have been invoked, along with their contractual calls to Web APIs.</li>
  <li>The Web API can be tested that it works with the external resource, by way of what is returned to the Server Action methods.</li>
  <li>The Server Actions can be invoked and application store state asserted for the correctness of their actions.</li>
</ul>

<p>If you wish to see a full example of these concepts in practice, you can checkout the <a href="https://github.com/mybuilder/task-app">task-app</a> repository on GitHub.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
