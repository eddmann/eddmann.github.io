<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="This post documents my experience solving the Advent of Code 2023 calendar using both Kotlin and Swift.">

    <title>
        
            Solving the Advent of Code 2023 calendar in Kotlin and Swift &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Solving the Advent of Code 2023 calendar in Kotlin and Swift</h1>
    <time datetime="2024-01-15T00:00:00+00:00" class="post-date">15 Jan 2024</time>
    <p>Another year, another <a href="https://adventofcode.com/2023">Advent of Code</a>, another excuse to explore new languages.
After my recent exploration into <a href="https://eddmann.com/posts/building-a-secret-santa-draw-pwa-in-react-and-typescript/">PWAs</a> this past year, I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development.
Before delving into the mobile domain, I wanted to see what each language had to offer.
In this post, I will document my experience completing the Advent of Code 2023 calendar in both <a href="https://github.com/eddmann/advent-of-code/tree/master/2023/kotlin">Kotlin</a> and <a href="https://github.com/eddmann/advent-of-code/tree/master/2023/swift">Swift</a>.</p>



<p><img src="/uploads/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs.png" alt="Kotlin vs Swift" /></p>

<h2 id="first-impressions">First Impressions</h2>

<p>From the outset, I found that both languages were very comparable in syntax and style - both modelling problems using similar paradigms: OO with a blend of functional primitives.
Both also follow suit in that the language developer also provides the <em>de facto</em> IDE in which to work; for Kotlin (created by JetBrains), it is <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a>, and for Swift (created by Apple), it is <a href="https://developer.apple.com/xcode/">Xcode</a>.
Throughout the month, I found myself much more productive within IntelliJ than Xcode.
I should caveat that I have been using JetBrainsâ€™ suite of IDEs (PHPStorm in particular) for many years.
However, I found that Xcode would randomly crash on me (not what you want from an IDE), even in my limited time using it.
I remember watching a <a href="https://frontendmasters.com/courses/swift-ios/">video series</a> on iOS development last year, which mentioned that this was deemed to be <em>expected behaviour</em> when working in Xcode ðŸ˜¬.</p>

<h3 id="starter-templates">Starter Templates</h3>

<p>Both language developers have (rather handily) published Advent of Code starter templates (<a href="https://github.com/kotlin-hands-on/advent-of-code-kotlin-template">Kotlin</a>, <a href="https://github.com/apple/swift-aoc-starter-example">Swift</a>), which provide a convenient means of getting started tackling each daily problem.
It is good to see language developers investing time in this, as Advent of Code is a great tool to help advertise a language - it is the time developers typically get to explore different languages (me being a case in point).
I found the REPL provided by the Kotlin starter template to be better.
Having the ability to run each day from within the IDE (using the gutter <em>play</em> button) was very useful, and it felt as though, during problem-solving, it was quicker to compile (perhaps due to incremental compilation?).
I had initially looked at using <a href="https://developer.apple.com/swift-playgrounds/">Swift Playgrounds</a> to iterate on the solutions within Xcode but found that it was very unperformant due to the way it has to instrument the code ðŸ˜”.
After some research, I found there were some <em>tricks</em> to make it more performant, but I did not want to rewrite the code to appease the IDE.</p>

<h2 id="today-i-learned">Today I learnedâ€¦</h2>

<p>Each day, I wrote down my learnings and insights into each language as I went about solving the problems.
Below, I have documented these findings, paying close attention to the use of the language itself over the actual problems they were trying to solve.</p>

<h3 id="day-1-trebuchet">Day 1: Trebuchet?!</h3>

<p>From the outset, I decided to add extension methods within both languages to help parse the input.
This included <code class="language-plaintext highlighter-rouge">lines</code>, <code class="language-plaintext highlighter-rouge">ints</code>, and <code class="language-plaintext highlighter-rouge">longs</code> (in the case of Kotlin).
Having to explicitly specify longs (64-bit values) within Kotlin felt like it was one overflow away from being a problem.
This must be due to being hosted on the JVM.</p>

<p>In addition to this, I also found that tuple declaration (<code class="language-plaintext highlighter-rouge">Pair</code>) within Kotlin seemed a little verbose, and the subsequent infix <code class="language-plaintext highlighter-rouge">to</code> syntax was odd.
I understand that this is most likely due to not wanting to add additional syntax to the language.
However, Swift tuples are much more readable.</p>

<h3 id="day-2-cube-conundrum">Day 2: Cube Conundrum</h3>

<p>I found that Kotlin had a far richer standard library, which, when solving problems such as Advent of Code, can come in very handy!
It was also interesting clicking through on a given method and seeing that the supporting code was all readable Kotlin.
It was cool to see how the language had bootstrapped itself.
For example, there was no built-in <code class="language-plaintext highlighter-rouge">sum</code> method within Swift, something which you are required to include using an <a href="https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/Utils.swift">extension method</a>.</p>

<h3 id="day-3-gear-ratios">Day 3: Gear Ratios</h3>

<p>I found that structures (in Swift) and <a href="https://kotlinlang.org/docs/data-classes.html">data classes</a> (within Kotlin) are a very concise means of creating data objects.
Kotlin additionally provides capabilities to compare and copy instances of such classes, which removes a lot of boilerplate.</p>

<h3 id="day-4-scratchcards">Day 4: Scratchcards</h3>

<p>I had fun creating an infix operator within Kotlin and Swift to calculate the power of a given number, opting to use the same <code class="language-plaintext highlighter-rouge">**</code> operator that Python does.
I found that it was incredibly cheap to add such powerful capabilities.
However, it did make me start to worry about how easy it could be to abuse (<em>cough</em> Scala <em>cough</em>).</p>

<h3 id="day-5-if-you-give-a-seed-a-fertilizer">Day 5: If You Give A Seed A Fertilizer</h3>

<p>This day provided me with a perfect excuse to explore both languagesâ€™ concurrency capabilities.
They both follow similar asynchronous execution models (<code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>), which provide an ideal level of abstraction.
Within part two, there was an <em>intelligent</em> way to solve the problem and a brute-force means.
Splitting up the required work led to a great use case for solving the problem in parallel.</p>

<p>Swift has come on leaps and bounds from the time I remember having to use <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch">Grand Central Dispatch</a>.
Having explored Kotlinâ€™s concurrency model first and finding Javaâ€™s <code class="language-plaintext highlighter-rouge">parallelStream</code>, I decided to implement a similar abstraction within Swift (<code class="language-plaintext highlighter-rouge">parallelMap</code>) using a generic <em>Sequence</em> extension method.
It was very cool to see all my machineâ€™s cores being utilised with very little code.</p>

<h3 id="day-6-wait-for-it">Day 6: Wait For It</h3>

<p>Something that I knew I wanted to include in <em>santa-lang</em> (borrowed from Kotlin and Swift) was trailing Lambda expression/Closures syntax.
I used this syntax heavily throughout the month, and building function APIs that took advantage of this syntax provides for a very readable DSL.</p>

<p>In addition to this, explicitly having to define Swiftâ€™s arguments during invocation (unless explicitly declaring not to) was initially odd to me.
However, the parameter names being part of the method/function signature brought with it increased expressiveness in the code.</p>

<h3 id="day-7-camel-cards">Day 7: Camel Cards</h3>

<p>This day allowed me to use Kotlinâ€™s and Swiftâ€™s advanced pattern-matching capabilities within <code class="language-plaintext highlighter-rouge">switch</code> and <code class="language-plaintext highlighter-rouge">when</code> expressions, respectively.
I was able to pattern match on lists, including values found within the data structure itself.
On top of this, I was also able to abstract out the concept of a <code class="language-plaintext highlighter-rouge">Hand</code> into a type that could encapsulate how it was compared in both languages.
This led to a very concise solution whereby the input was passed into <code class="language-plaintext highlighter-rouge">Hand</code>s and then sorted before performing several collection operations on the output.</p>

<h3 id="day-8-haunted-wasteland">Day 8: Haunted Wasteland</h3>

<p>I found that the arguments of a Lambda expression/Closure appearing after the curly brace grew on me.
I was initially opposed to this when designing <em>santa-lang</em>, but I can see how it aids in parsing the syntax whilst maintaining readability.</p>

<h3 id="day-9-mirage-maintenance">Day 9: Mirage Maintenance</h3>

<p>As explained before, Kotlin has a very rich standard library and provides the ability to generate an <em>infinite</em> sequence.
Along with this, it includes functions (e.g. <code class="language-plaintext highlighter-rouge">zipWithNext</code> and <code class="language-plaintext highlighter-rouge">takeIf</code>) that feel like they have been added just for Advent of Code?!
This dayâ€™s Kotlin solution was by far my favourite solution for the entire calendar.</p>

<h3 id="day-10-pipe-maze">Day 10: Pipe Maze</h3>

<p>I built up the solution using a composition of several smaller functions.
I was able to use the <code class="language-plaintext highlighter-rouge">let</code> function within Kotlin to achieve the desired composition that I had become accustomed to within <em>santa-lang</em>.
However, Swift did not provide such functionality, but never fear - this was another good excuse to implement another operator (<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>).</p>

<h3 id="day-11-cosmic-expansion">Day 11: Cosmic Expansion</h3>

<p>This day highlighted more of Kotlinâ€™s extensive standard library, including <code class="language-plaintext highlighter-rouge">mapIndexedNotNull</code>, <code class="language-plaintext highlighter-rouge">mapNotNull</code>, <code class="language-plaintext highlighter-rouge">all</code>, and <code class="language-plaintext highlighter-rouge">count</code>.</p>

<h3 id="day-12-hot-springs">Day 12: Hot Springs</h3>

<p>I found that Kotlin had better support for treating composed data structures as values.
For example, I was able to make a <code class="language-plaintext highlighter-rouge">Pair&lt;String, List&lt;Int&gt;&gt;</code> a <em>hashable</em> map key, whereas in Swift, I had to implement the <code class="language-plaintext highlighter-rouge">Hashable</code> protocol, which was a pain.</p>

<p>I was also a big fan of the <code class="language-plaintext highlighter-rouge">if let</code> syntax within Swift and felt this would be a welcome addition to Kotlin.
Combined with <code class="language-plaintext highlighter-rouge">Optional</code> typing constructs, this provided an easy means of unwrapping values with scoped variables.</p>

<h3 id="day-13-point-of-incidence">Day 13: Point of Incidence</h3>

<p>I found that number ranges are very expressive.
I liked how Kotlin provided <code class="language-plaintext highlighter-rouge">downTo</code> to declare a decreasing range.
This also provided an opportune place to experiment with Kotlinâ€™s syntax support for omitting the function invocation from the call (i.e. <code class="language-plaintext highlighter-rouge">10.downTo(1)</code> being equivalent to <code class="language-plaintext highlighter-rouge">10 downTo 1</code>).</p>

<h3 id="day-14-parabolic-reflector-dish">Day 14: Parabolic Reflector Dish</h3>

<p>Type aliases are awesome!
They allow you to cheaply declare data types using the language of the problem domain.
For example, I was able to define a generic <code class="language-plaintext highlighter-rouge">Matrix&lt;T&gt;</code> (<code class="language-plaintext highlighter-rouge">List&lt;List&lt;T&gt;&gt;</code>) type and compose a <code class="language-plaintext highlighter-rouge">Dish</code> (<code class="language-plaintext highlighter-rouge">Matrix&lt;Char&gt;</code>) type in this dayâ€™s solution.</p>

<h3 id="day-15-lens-library">Day 15: Lens Library</h3>

<p>I found that Kotlin provides better overall immutable data structure support.
I was initially impressed with Swiftâ€™s use of <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">let</code> declarations to dictate whether the data structure itself was immutable or not.
However, I fell into a problem regarding nested mutable data structure definitions.
The means to overcome this problem was rather ugly.</p>

<h3 id="day-16-the-floor-will-be-lava">Day 16: The Floor Will Be Lava</h3>

<p>Apple provides a <a href="https://github.com/apple/swift-collections">Collections</a> library, which includes many useful data structures that come in handy when solving Advent of Code problems.
One such collection was a double-ended queue (Deque), which I was able to make use of on this day.</p>

<h3 id="day-17-clumsy-crucible">Day 17: Clumsy Crucible</h3>

<p>It was fun being able to use Javaâ€™s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue</a> implementation within Kotlin.
One of the advantages of being hosted on the JVM is that you can use libraries that are already available.
The syntax for interacting with these libraries is also very clean.
For example, you can provide a Kotlin lambda expression for the comparator.
Sadly, Swift does not provide such a data structure, so I had to go about building a heap-backed <a href="https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/PriorityQueue.swift">Priority Queue</a>, which was fun.</p>

<h3 id="day-18-lavaduct-lagoon">Day 18: Lavaduct Lagoon</h3>

<p>I originally had written down how I wished that Swift had <code class="language-plaintext highlighter-rouge">switch</code>/<code class="language-plaintext highlighter-rouge">if</code> expression support, similar to Kotlin.
However, upon writing this post, I have seen that Swift 5.9 has <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md">support</a> for it, so I just need to upgrade from 5.8!</p>

<h3 id="day-19-aplenty">Day 19: Aplenty</h3>

<p>I had fun building out an enumerated <code class="language-plaintext highlighter-rouge">Workflow</code> type and being able to destructure the type using a <code class="language-plaintext highlighter-rouge">switch</code> statement in Swift.
There was also more internal debate about Kotlinâ€™s standard library - Kotlinâ€™s <code class="language-plaintext highlighter-rouge">mapIndexed</code> vs Swiftâ€™s <code class="language-plaintext highlighter-rouge">enumerated().map()</code>.
The purist in me likes the latter.
However, the developer who is already akin to the language and just wants to solve the problem likes the ease of the former. ðŸ¤”</p>

<h3 id="day-20-pulse-propagation">Day 20: Pulse Propagation</h3>

<p>I cannot believe it took me until day 20 to find <code class="language-plaintext highlighter-rouge">buildMap</code> within Kotlin.
This provides the ability to construct a <code class="language-plaintext highlighter-rouge">Map</code> in a mutable/imperative manner, with the resulting value being returned to the caller as an immutable data structure.
I am a big fan of this explicit mutation, all thanks to implicit lambda contexts for providing access to the data structure methods.</p>

<h3 id="day-21-step-counter">Day 21: Step Counter</h3>

<p>Now that I had found <code class="language-plaintext highlighter-rouge">buildMap</code>, it was time to use <code class="language-plaintext highlighter-rouge">buildSet</code> within Kotlin as well!</p>

<h3 id="day-22-sand-slabs">Day 22: Sand Slabs</h3>

<p>The ability to add extension methods to existing data types plays a big role in both languages.
Although I refrained from using them too frequently throughout the calendar (excluding utility methods), there were some days when I felt they aided in expressing the solution.
One such example of this was in todayâ€™s <code class="language-plaintext highlighter-rouge">Set&lt;T&gt;.canDrop</code> definition.</p>

<h3 id="day-23-a-long-walk">Day 23: A Long Walk</h3>

<p>Some syntactic sugar that Kotlin could adopt from Swift would be the ability to omit verbose enumeration definitions.
The compiler is aware of the type that is required.
As such, omitting the enumerated class and only providing the value aids readability - for example, <code class="language-plaintext highlighter-rouge">.NORTH</code> instead of <code class="language-plaintext highlighter-rouge">Point.NORTH</code>.</p>

<h3 id="day-24-never-tell-me-the-odds">Day 24: Never Tell Me The Odds</h3>

<p>Part two was a tough maths problem, and I sadly had to reach out to the subreddit for help.
It did, however, provide me with a reason to explore interacting with third-party libraries within both languages by running the <a href="https://github.com/Z3Prover/z3">Z3 problem solver</a>.
There are official Z3 Java bindings, which, thanks to Kotlinâ€™s interop, I was able to use seamlessly.
Fortunately, within Swift, someone had worked on building a <a href="https://github.com/LuizZak/swift-z3">wrapper</a> that exposed a great Swift interface for this C library.</p>

<h3 id="day-25-snowverload">Day 25: Snowverload</h3>

<p>Today was the day I attempted to explore implementing a generic solution to using a tuple as a hash value within Swift - so worth it on the last dayâ€¦
Regarding the Kotlin solution, along with implementing Kargerâ€™s algorithm, I decided to try solving it using a Graphviz visualisation, which I thought would make for a cool diagram to include in this article.</p>

<p><img src="/uploads/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25.png" alt="Day 25 Graphviz Solution" style="max-width:280px;margin:0 auto;" /></p>

<h2 id="santa-lang-dsl-in-kotlin">santa-lang DSL in Kotlin</h2>

<p>As an additional exploration, I wished to look into Kotlinâ€™s <a href="https://kotlinlang.org/docs/type-safe-builders.html">type-safe builders</a>, which provide you with a means to implement your own DSL on top of the language.
I felt that it could be possible to implement the <a href="https://eddmann.com/santa-lang/runner/">day solution structure</a> I had designed for <em>santa-lang</em> within Kotlin itself.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun main() = solution {
    fun calibrate(values: List&lt;String&gt;) = values.sumOf { value -&gt;
        val digits = value.replace(Regex("\\D"), "")
        "${digits.first()}${digits.last()}".toInt()
    }

    input {
        readInput("Day01")
    }

    partOne {
        calibrate(input.lines())
    }

    partTwo {
        val translations = mapOf(
            "one" to "o1e",
            "two" to "t2o",
            "three" to "t3e",
            "four" to "4",
            "five" to "5e",
            "six" to "6",
            "seven" to "7n",
            "eight" to "e8t",
            "nine" to "n9e",
        )

        val values = input.lines().map { value -&gt;
            translations.entries.fold(value) { acc, (from, to) -&gt;
                acc.replace(from, to)
            }
        }

        calibrate(values)
    }

    test {
        input { "..." }
        partOne { 142 }
    }

    test {
        input { "..." }
        partTwo { 281 }
    }
}
</code></pre></div></div>

<p>It was amazing to see what can be achieved with the languageâ€™s support of lambda expression contexts.
Overall, the experience was very easy.
However, I did find <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/">DSL markers</a> a little confusing to get my head around.
Similar to infix operators and extension methods, this is another language feature that provides great power.
A part of me again fears how developers could overuse or exploit it (i.e. not everything needs its own DSL!).</p>

<p><img src="/uploads/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/santa-lang-dsl.png" alt="santa-lang DSL in Kotlin" /></p>

<h2 id="conclusion">Conclusion</h2>

<p>There were some very interesting days in this yearâ€™s calendar, along with some very complex maths-related problems that I am happy to see the back of.
I really enjoyed working in both Kotlin and Swift to solve these puzzles, and, as per my initial thoughts, I was able to model the problems in a similar manner most of the time.
Reflecting on the experience, I feel as though Kotlin (surprisingly to me) is my preferred language going forward.
Throughout the month, I have had the opportunity to explore almost all of the touted features in both languages, and at each hurdle, Kotlin tips Swift.
Going forward, I hope to expand upon this and delve into building native mobile applications using both languages.
Perhaps that may sway things Swiftâ€™s way?</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
