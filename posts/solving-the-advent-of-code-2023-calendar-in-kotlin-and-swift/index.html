<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="This article documents my experience solving the Advent of Code 2023 calendar using both Kotlin and Swift">

    <title>
        
            Solving the Advent of Code 2023 calendar in Kotlin and Swift &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Solving the Advent of Code 2023 calendar in Kotlin and Swift</h1>
    <time datetime="2024-01-15T00:00:00+00:00" class="post-date">15 Jan 2024</time>
    <p>Another year, another <a href="https://adventofcode.com/2023">Advent of Code</a>, another excuse to explore new languages.
After my recent exploration into <a href="https://eddmann.com/posts/building-a-secret-santa-draw-pwa-in-react-and-typescript/">PWAâ€™s</a> this past year I wanted a reason to explore Kotlin and Swift, two languages equipped for native mobile (Android and iOS) development.
Before delving into the mobile-domain I wanted to see what each language had to offer.
In this article I will document my experience completing the Advent of Code 2023 calendar in both <a href="https://github.com/eddmann/advent-of-code/tree/master/2023/kotlin">Kotlin</a> and <a href="https://github.com/eddmann/advent-of-code/tree/master/2023/swift">Swift</a>.</p>



<p><img src="/uploads/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/vs.png" alt="Kotlin vs Swift" /></p>

<h3 id="first-impressions">First-impressions</h3>

<p>From the offset I found that both languages were very comparable in syntax and style - both modelling problems using similar paradigms, OO with a blend of functional primitives.
Both also follow suit in that the language developer also provides the <em>defacto</em> IDE in which to <em>code</em>; for Kotlin (created by JetBrains) it is <a href="https://www.jetbrains.com/idea/">IntelliJ IDEA</a> and Swift (created by Apple) it is <a href="https://developer.apple.com/xcode/">Xcode</a>.
Throughout the month I found myself much more productive within IntelliJ than Xcode.
I should caveat that I have been using JetBrainâ€™s suite of IDEs (PHPStorm in particular) for many years, however I found that Xcode would randomly crash on me (not what you want from an IDE) even in my limited time using it.
I remember watching a <a href="https://frontendmasters.com/courses/swift-ios/">video series</a> on iOS development last year which mentioned that this was deemed to be <em>expected behaviour</em> when working in Xcode ðŸ˜¬.</p>

<h4 id="starter-templates">Starter Templates</h4>

<p>Both languages developers have (rather handily) published Advent of Code starter templates (<a href="https://github.com/kotlin-hands-on/advent-of-code-kotlin-template">Kotlin</a>, <a href="https://github.com/apple/swift-aoc-starter-example">Swift</a>) which provide a convenient means of getting stated tackling each daily problem.
It is good to see language developers investing time to do this, as Advent of Code is a great tool to help advertise a language, as it is the time developers typically explore different languages (me being case in point).
I found the REPL provided by the Kotlin starter template to again be better, having the ability to run each day from within the IDE (using the gutter <em>play</em> button) was very useful; and it felt as though during problem-solving quicker to compile (maybe incremental compilation?).
I had initially looked at using <a href="https://developer.apple.com/swift-playgrounds/">Swift Playgrounds</a> to iterate on the solutions within Xcode but found that it was very un-performant due to the way it has to instrument your code ðŸ˜”.
After some research I found there were some <em>tricks</em> to make it more performant, but I did not want re-write the code to appease the IDE.</p>

<h3 id="today-i-learned">Today I learnedâ€¦</h3>

<p>Each day I wrote down my learnings and insights into each language as I went about solving the problem.
Below I have documented these findings, paying close attention to the use of the language itself over the actual problem they were trying to solve.</p>

<h4 id="day-1">Day 1</h4>

<p>I found that tuple declaration (<code class="language-plaintext highlighter-rouge">Pair</code>) within Kotlin seemed a little verbose and subsequent infix <code class="language-plaintext highlighter-rouge">to</code> syntax was odd.
I understand this was most likely due to not wanting to add additional syntax to the language, however, Swift tuples are much more readable.</p>

<h4 id="day-2">Day 2</h4>

<p>I found that Kotlin had a far richer standard library which when solving problems such as Advent of Code can come in very handy!
It was also interesting clicking through on a given method and seeing that the supporting code was all readable Kotlin (it was cool to see how the language had bootstrapped itself).
For example, there was no inbuilt <code class="language-plaintext highlighter-rouge">sum</code> method within Swift, something which you are required to include useful with an <a href="https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/Utils.swift">extension method</a>.</p>

<h4 id="day-3">Day 3</h4>

<p>I found that structures (in Swift) and <a href="https://kotlinlang.org/docs/data-classes.html">data classes</a> (within Kotlin) are a very concise means of creating data objects.
Kotlin additional provides capabilities to compare and copy instances of such classes which removes a lot of boilerplate.</p>

<h4 id="day-4">Day 4</h4>

<p>I had fun creating an infix operator within Kotlin and Swift to calculate the power of a given number, opting to use the same <code class="language-plaintext highlighter-rouge">**</code> operator that Python does.
I found that it was incredibly cheap to add such powerful capabilities, however, it did make me start to worry about how easy it could be to abuse (<em>cough</em> Scala <em>cough</em>).</p>

<h4 id="day-5">Day 5</h4>

<p>This day provided me with a perfect excuse to explore both languagesâ€™ concurrency capabilities.
They both follow similar asynchronous execution models (<code class="language-plaintext highlighter-rouge">async</code>, <code class="language-plaintext highlighter-rouge">await</code>) which provide an ideal level of abstraction.
Within the second part there was an <em>intelligent</em> way to solve the problem and a brute force means; splitting up the required work lead to great use-case for solving the problem in parallel.</p>

<p>Swift has come on leaps and bounds from the time I remember having to use <a href="https://en.wikipedia.org/wiki/Grand_Central_Dispatch">Grand Central Dispatch</a>.
Having explored Kotlinâ€™s concurrency model first and finding Javaâ€™s <code class="language-plaintext highlighter-rouge">parallelStream</code>, I decided to implement a similar abstraction within Swift (<code class="language-plaintext highlighter-rouge">parallelMap</code>) using a generic <em>Sequence</em> extension method.
It was very cool to see all my machines cores being utilised with very little code.</p>

<h4 id="day-6">Day 6</h4>

<p>Something that I knew I wanted to include in <em>santa-lang</em> (borrowed from Kotlin and Swift) was trailing Lambda expression/Closures syntax.
I used this syntax heavily throughout the month and building function APIs that took advantage of this syntax provides for a very readable DSL.</p>

<p>Additional to this, explicitly having to define Swiftâ€™s arguments during invocation (unless explicitly declaring not to) was initially odd to me, however, the arguments names being part of the method/function signature brought with it increased expressibility to the code.</p>

<h4 id="day-7">Day 7</h4>

<p>This day allowed me to use Kotlinâ€™s and Swiftâ€™s advanced pattern matching capabilities within <code class="language-plaintext highlighter-rouge">switch</code> and <code class="language-plaintext highlighter-rouge">when</code> expressions respectably.
I was able to pattern match on lists, including values found within the data structure itself.
On top of this I was also able to abstract out the concept of a <code class="language-plaintext highlighter-rouge">Hand</code> into a type which could encapsulate how it was compared in both languages.
This lead to a very concise solution where-by the input was passed into <code class="language-plaintext highlighter-rouge">Hand</code>â€™s and then sorted before performing several collection operations on the output.</p>

<h4 id="day-8">Day 8</h4>

<p>I found that the arguments of a Lambda expression/Closure appearing after the curly brace grew on me.
I was initially opposed to this when designing <em>santa-lang,</em> but I can see how it aids in parsing the syntax whilst maintaining readability.</p>

<h4 id="day-9">Day 9</h4>

<p>As explained before, Kotlin has a very rich standard library and provides the ability to generate an <em>infinite</em> sequence.
Along with this it includes functions (i.e <code class="language-plaintext highlighter-rouge">zipWithNext</code> and <code class="language-plaintext highlighter-rouge">takeIf</code>) which feel like they have been added just for Advent of Code?!
This dayâ€™s Kotlin solution was by-far my favourite solution for the entire calendar.</p>

<h4 id="day-10">Day 10</h4>

<p>I built up the solution using a composition of several smaller functions.
I was able to use the <code class="language-plaintext highlighter-rouge">let</code> function within Kotlin to achieve the desired composition that I had become accustomed to within <em>santa-lang</em>.
However, Swift did not provide such functionality, but never fear, this was another good excuse to implement another operator (<code class="language-plaintext highlighter-rouge">&gt;&gt;&gt;</code>).</p>

<h4 id="day-11">Day 11</h4>

<p>Highlighted more of Kotlinâ€™s extensive standard library, <code class="language-plaintext highlighter-rouge">mapIndexedNotNull</code>, <code class="language-plaintext highlighter-rouge">mapNotNull</code>, <code class="language-plaintext highlighter-rouge">all</code> and <code class="language-plaintext highlighter-rouge">count</code>.</p>

<h4 id="day-12">Day 12</h4>

<p>I found that Kotlin had better support for treating composed data-structures as values.
For example, I was able to make a <code class="language-plaintext highlighter-rouge">Pair&lt;String, List&lt;Int&gt;&gt;</code> a <em>hashable</em> map key, whereas in Swift I had to implement the <code class="language-plaintext highlighter-rouge">Hashable</code> protocol which was a pain.
I was also big fan of the <code class="language-plaintext highlighter-rouge">if let</code> syntax within Swift and felt this would be a welcome addition to Kotlin.
Combined with <code class="language-plaintext highlighter-rouge">Optional</code> typing constructs this provided an easy means of unwrapping values with scoped variables.</p>

<h4 id="day-13">Day 13</h4>

<p>I found that number ranges are very expressive.
I liked how Kotlin provided <code class="language-plaintext highlighter-rouge">downTo</code> to declare a decreasing range.
This also provided an opportune place to experiment with Kotlinâ€™s syntax support for omitting the function invocation from the call (i.e. <code class="language-plaintext highlighter-rouge">10.downTo(1)</code> being equivalent to <code class="language-plaintext highlighter-rouge">10 downTo 1</code>).</p>

<h4 id="day-14">Day 14</h4>

<p>Type-aliases are awesome!
They allow you to cheaply declare data-types using the language of the problem domain.
For example, I was able to define a generic <code class="language-plaintext highlighter-rouge">Matrix&lt;T&gt;</code> (<code class="language-plaintext highlighter-rouge">List&lt;List&lt;T&gt;&gt;</code>) type and composed a <code class="language-plaintext highlighter-rouge">Dish</code> (<code class="language-plaintext highlighter-rouge">Matrix&lt;Char&gt;</code>) type in this dayâ€™s solution.</p>

<h4 id="day-15">Day 15</h4>

<p>I found that Kotlin provides better overall immutable data structure support.
I was initially impressed with Swiftâ€™s use of <code class="language-plaintext highlighter-rouge">var</code>/<code class="language-plaintext highlighter-rouge">let</code> declarations to dictate if the data-structure itself was immutable or not, however, I fel into a problem in regard to nested mutable data-structure definitions.
The means to overcome this problem was rather ugly.</p>

<h4 id="day-16">Day 16</h4>

<p>Apple provides a <a href="https://github.com/apple/swift-collections">Collections</a> library which includes many useful data-structures which come in handy when solving Advent of Code problems.
One such collection was a double-ended queue (Deque) which I was able to make use of on this day.</p>

<h4 id="day-17">Day 17</h4>

<p>It was fun being able to use Javaâ€™s <a href="https://docs.oracle.com/javase/8/docs/api/java/util/PriorityQueue.html">Priority Queue</a> implementation within Kotlin.
One of the advantages of using the JVM is that you can use libraries that are already present.
The syntax for interacting with these libraries is also very clean, for example, you can provide a Kotlin Lambda expressions for the comparator.
Sadly, Swift does not provide such a data-structure, so I had to go about building a heap-backed <a href="https://github.com/eddmann/advent-of-code/blob/master/2023/swift/AdventOfCode2023/Sources/PriorityQueue.swift">Priority Queue</a> which was fun.</p>

<h4 id="day-18">Day 18</h4>

<p>I originally had written down how I wished that Swift had <code class="language-plaintext highlighter-rouge">switch</code>/<code class="language-plaintext highlighter-rouge">if</code> expression support, similar to Kotlin.
However, upon writing this article I have seen that Swift 5.9 has <a href="https://github.com/apple/swift-evolution/blob/main/proposals/0380-if-switch-expressions.md">support</a> for it, so I just need to upgrade from 5.8!</p>

<h4 id="day-19">Day 19</h4>

<p>I had fun building out an enumerated <code class="language-plaintext highlighter-rouge">Workflow</code> type, being able to destructure the type using the <code class="language-plaintext highlighter-rouge">switch</code> pattern in Swift.
There was also more internal debate about Kotlinâ€™s standard library, Kotlinâ€™s <code class="language-plaintext highlighter-rouge">mapIndexed</code> vs Swiftâ€™s <code class="language-plaintext highlighter-rouge">enumerated().map()</code>.
The purist in me likes the latter, however, the developer who already is akin to the language and just wants to solve the problem likes the ease of the former ðŸ¤”.</p>

<h4 id="day-20">Day 20</h4>

<p>I can not believe it took me until day 20 to find <code class="language-plaintext highlighter-rouge">buildMap</code> within Kotlin.
This provides you with the ability to construct the Map in a mutable/imperative means, with the resulting value being returned to the caller as a immutable data-structure.
I am a big fan of this explicit mutation, and thanks to implicit Lambda contexts for providing access to the data-structure methods.</p>

<h4 id="day-21">Day 21</h4>

<p>Now that I had found <code class="language-plaintext highlighter-rouge">buildMap</code> it was time to use <code class="language-plaintext highlighter-rouge">buildSet</code> within Kotlin as well!</p>

<h4 id="day-22">Day 22</h4>

<p>The ability to add extension methods to existing data-types play a big role in both languages, and although I refrained from using them too frequently throughout the calendar (excluding utility methods), there were some days when I felt they aided in expressing the solution.
One such example of this was in todayâ€™s <code class="language-plaintext highlighter-rouge">Set&lt;T&gt;.canDrop</code> definition.</p>

<h4 id="day-23">Day 23</h4>

<p>Some syntactic sugar that Kotlin could adopt from Swift would be the ability to omit the verbose enumeration definitions.
The compiler is aware of the type which is required and as such omitting the enumerated class and only provide the value aids in readability, for example <code class="language-plaintext highlighter-rouge">.NORTH</code> instead of <code class="language-plaintext highlighter-rouge">Point.NORTH</code>.</p>

<h4 id="day-24">Day 24</h4>

<p>Part two was a tough math problem and I sadly had to reach out to the subreddit for help.
It did however provide me with a reason to explore interacting with third-party libraries within both languages, by way of running the <a href="https://github.com/Z3Prover/z3">Z3 problem solver</a>.
There are official Z3 Java bindings which thanks to Kotlinâ€™s interop I was able to use seamlessly.
Fortunately within Swift, someone had worked on building a <a href="https://github.com/LuizZak/swift-z3">wrapper</a> that exposed a great Swift interface for this C-library.</p>

<h4 id="day-25">Day 25</h4>

<p>Today was the day I attempted to explore implementing a generic solution to being able to use a tuple as a hash value within Swift, so worth it on the last dayâ€¦
In regard to the Kotlin solution along with implementing Kargerâ€™s algorithm I decided to try and solve it using a Graphviz visualisation, which I thought would make for a cool diagram to include in this article.</p>

<p><img src="/uploads/solving-the-advent-of-code-2023-calendar-in-kotlin-and-swift/day25.png" alt="Day 25 Graphviz Solution" style="max-width:280px;margin:0 auto;" /></p>

<h3 id="santa-lang-dsl-in-kotlin">santa-lang DSL in Kotlin</h3>

<p>As an additional exploration I wished to look into Kotlinâ€™s <a href="https://kotlinlang.org/docs/type-safe-builders.html">type-safe builders</a>, which provide you with a means to implement your own DSL on-top of the language.
I felt that it could be possible to implement the day solution structure I had designed for <em>santa-lang</em> within Kotlin itself.
It was amazing to see what can be achieved with the languages support of Lambda expression contexts.
Overall the experience was very easy, however, I did find <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-dsl-marker/">DSL markers</a> a little confusing to get my head around.
Similar to infix operators and extension methods this is another language feature that provides great power; a part of me again fears how developers could over-use/exploit it (i.e. everything does not need its own DSL!).</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>fun main() = solution {
    fun calibrate(values: List&lt;String&gt;) = values.sumOf { value -&gt;
        val digits = value.replace(Regex("\\D"), "")
        "${digits.first()}${digits.last()}".toInt()
    }

    input {
        readInput("Day01")
    }

    partOne {
        calibrate(input.lines())
    }

    partTwo {
        val translations = mapOf(
            "one" to "o1e",
            "two" to "t2o",
            "three" to "t3e",
            "four" to "4",
            "five" to "5e",
            "six" to "6",
            "seven" to "7n",
            "eight" to "e8t",
            "nine" to "n9e",
        )

        val values = input.lines().map { value -&gt;
            translations.entries.fold(value) { acc, (from, to) -&gt;
                acc.replace(from, to)
            }
        }

        calibrate(values)
    }

    test {
        input { "..." }
        partOne { 142 }
    }

    test {
        input { "..." }
        partTwo { 281 }
    }
}
</code></pre></div></div>

<h3 id="conclusion">Conclusion</h3>

<p>There were some very interesting days in this yearâ€™s calendar, along with some very complex math related problems that I am happy to see the back off.
I really enjoyed working in both Kotlin and Swift to solve these puzzles, and as per my initial thoughts I was able to model the problems in a similar manner (most of the time).
Reflecting on the experience, I feel as though Kotlin (surprisingly to me) feels like my preferred language going forward.
Throughout the month I have had the opportunity to explore (almost all) of the toted features in both languages and at each hurdle Kotlin tips Swift.
Going forward I hope to expand upon this and delve into building native mobile application using both languages, perhaps that may sway Swiftâ€™s way?</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
