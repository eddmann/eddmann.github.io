---
layout: post
title: 'Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB'
meta: 'Discusses the process of building a Serverless Photo Gallery for use by our wedding guests'
tags: aws lambda s3 dynamodb
---

Whilst [documenting](https://github.com/eddmann/our-wedding-infra#stage-applications) how I structured the [infrastructure](https://github.com/eddmann/our-wedding-infra) used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern.
In the tradition of over engineering a problem related to our wedding - we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day.
So instead, I decided to create a Serverless photo gallery which provided guests with the ability to share the original photos in one place.
I also wanted to explore the ability to achieve this with having 100% feature parity locally in a development setting.
In this post I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB.
The final implementation can be found in [this GitHub repository](https://github.com/eddmann/our-wedding-gallery).

<!--more-->

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/diagram.png" alt="The AWS architecture diagram" />

### The API

For the backend API I opted to use the Node 16 (`nodejs16.x`) supported Lambda runtime, conforming to the RESTful Hypertext Application Language (HAL) standard.
Like in previous projects, I opted to use the [Serverless Framework](https://www.serverless.com/) to manage deploying the transient application, whilst leaving the foundational building blocks for Terraform.
Each API endpoint's functionality is split into individually packaged artifacts using [esbuild](https://www.serverless.com/plugins/serverless-esbuild) for bundling and transpilation.
This provides smaller artifacts that only contain the dependencies (such as Sharp, AWS-SDK) which are actually required within each of the desired endpoint's.

#### Persistence

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/nosql-workbench.png" alt="The DynamoDB table schema" />

For storing the photos metadata and gallery listing (used for the infinite scroll) I opted to use a [Single-Table Design](https://www.alexdebrie.com/posts/dynamodb-single-table/) DynamoDB table.
This uses the `PK`/`SK` and `GSI*PK`/`GSI*SK` partition/sort key pattern found in Single-Table Design, to be able to optimally fetch data based on pre-defined access patterns.

The `GSI1PK` is used as a _hot key_ ðŸ˜¬ for listing the gallery photos in sorted processed timestamp order - using the last evaluated key as a marker to progressively provide the _next_ batch of gallery photos to the client.
Using a _hot key_ is not best practise, but based on this usage pattern and load, suffices for this use-case.

In its current form the use of a _Single-Table Design_ may seem unnecessary with the application lacking lots of different access patterns and concerns.
However, there is future scope to better showcase the idea with the additional functionality such as photo comments.

#### Photo Upload and Resizing

Uploaded photos are stored within an initial _upload_ S3 bucket using pre-signed [form POST requests](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html), which are generated by the API based on a supplied pre-request by the client.
Upon successful photo upload, the resulting `s3:ObjectCreated` event triggers a Lambda whose responsibility is to move the photo to the _persistent_ S3 bucket, and generate resized web and thumbnail variants in WebP (using [Node.js Sharp](https://sharp.pixelplumbing.com/)).
At the end of this process a record with the photo's metadata is stored in the DynamoDB table, for inclusion into the gallery response.
The initial _upload_ S3 bucket uses a lifecycle rule to clean up any failed photo uploads after 7 days.

#### Local Development

As stated above, one of my goals was to have local feature parity for development purposes.
Thanks to a combination of [Serverless Offline](https://www.serverless.com/plugins/serverless-offline), [Serverless DynamoDB Local](https://www.serverless.com/plugins/serverless-dynamodb-local) and [Serverless S3 Local](https://www.serverless.com/plugins/serverless-s3-local) I was able to achieve just that ðŸŽ‰.
I was pleasantly surprised at how easy it was to be able to replicate both pre-signing S3 POST requests and handling S3 event triggers thanks to [s3rver](https://github.com/jamhall/s3rver).
In doing this I was able to have greater confidence in my implementation before deploying it to AWS.

### The Client

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/gallery.png" alt="The lazy-loaded photo gallery" style="width: 48%; max-width: 250px; display: inline;" /> <img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/lightbox.png" alt="The photo lighbox" style="width: 48%; max-width: 250px; display: inline;" />

The client is developed as a Single-page application (SPA) using React and Create React App.
I used this project as a good opportunity to explore using [Tailwind CSS](https://tailwindcss.com/) for presentational concerns.
The client is built statically within the [build pipeline](https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows), distributed via S3 and fronted by CloudFront.
To ensure only authorised users have access to the gallery, a [CloudFront function](https://github.com/eddmann/our-wedding-infra/blob/main/stage/apps/gallery/resources/viewer-request.js) is employed to ensure that shared HTTP Basic Authentication credentials are supplied.
As the same CloudFront distribution is used to front the Client, API and S3 buckets, we can be certain that all requests are protected by these security measures.

#### Photo Lazy Loading and Lightbox

The gallery is presented as an [infinite scrollable list](https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/PhotoGallery.js), which progressively (lazily) requests the _next_ available batch of photos.
When a photo is clicked on, a full-screen [lightbox variant](https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/Lightbox.js) is presented to the user, providing the ability to visually swipe back and forth (on mobile devices) between photos.
Effectively handling touch events, with graceful desktop mouse click fallback, was an interesting challenge using React Hooks.

### Conclusion

I really enjoyed the chance to add additional functionality that could be hosted within the infrastructure project I had set up for our wedding website.
Being able to replicate all the behaviour within a local setting was very satisfying, enabling a quick REPL for API/Client development.
I was also very happy with the decision to structure both the client and API in a [monorepo](https://en.wikipedia.org/wiki/Monorepo), with independent [build pipelines](https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows) for any changes that are pushed.

Finally, since getting the chance to now see how this gallery has been used in practise, I feel the addition of handling video media would be a great future improvement.
Using [AWS Elemental MediaConvert](https://aws.amazon.com/mediaconvert/) as a possible means to handle processing uploaded video media could provide similar _elastic compute_ that Node.js Sharp hosted on Lambda does for photos.
