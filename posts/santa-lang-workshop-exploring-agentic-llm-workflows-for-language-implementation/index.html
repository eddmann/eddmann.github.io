<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>santa-lang Workshop: Exploring Agentic LLM Workflows for Language Implementation - Edd Mann</title>
<meta name=description content="An experiment in agentic LLM workflows: automatically implementing elf-lang (a subset of santa-lang) across different programming languages using AI agents, with shared test suites and stage-gated development phases."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="santa-lang Workshop: Exploring Agentic LLM Workflows for Language Implementation"><meta itemprop=description content="Exploring how AI agents can implement programming languages from scratch. The santa-lang Workshop provides a structured approach using shared PHPT-style tests, Docker isolation, and stage-gated development to compare how different harnesses and models tackle the same language specification across multiple programming languages."><meta itemprop=datePublished content="2025-09-15T00:00:00+00:00"><meta itemprop=dateModified content="2025-09-15T00:00:00+00:00"><meta itemprop=wordCount content="1576"><meta itemprop=keywords content="Llm,Santa-Lang,Cursor,Claude-Code"><meta property="og:url" content="https://eddmann.com/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="santa-lang Workshop: Exploring Agentic LLM Workflows for Language Implementation"><meta property="og:description" content="Exploring how AI agents can implement programming languages from scratch. The santa-lang Workshop provides a structured approach using shared PHPT-style tests, Docker isolation, and stage-gated development to compare how different harnesses and models tackle the same language specification across multiple programming languages."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2025-09-15T00:00:00+00:00"><meta property="article:modified_time" content="2025-09-15T00:00:00+00:00"><meta property="article:tag" content="Llm"><meta property="article:tag" content="Santa-Lang"><meta property="article:tag" content="Cursor"><meta property="article:tag" content="Claude-Code"><meta name=twitter:card content="summary"><meta name=twitter:title content="santa-lang Workshop: Exploring Agentic LLM Workflows for Language Implementation"><meta name=twitter:description content="Exploring how AI agents can implement programming languages from scratch. The santa-lang Workshop provides a structured approach using shared PHPT-style tests, Docker isolation, and stage-gated development to compare how different harnesses and models tackle the same language specification across multiple programming languages."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.4c8b66c005db4efc68625e4ceed190f2dc110d342d05ffb19ba924cc13c3ef15.css integrity="sha256-TItmwAXbTvxoYl5M7tGQ8twRDTQtBf+xm6kkzBPD7xU="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.da71ac9c7b8bd4e644618df0ab735aed1393aad3cb5e5c57e5adc300fe7c8209.js integrity="sha256-2nGsnHuL1OZEYY3wq3Na7ROTqtPLXlxX5a3DAP58ggk=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li><li><a href=/cv.html>CV</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation>santa-lang Workshop: Exploring Agentic LLM Workflows for Language Implementation</h1><time datetime=2025-09-15T00:00:00Z class=published-at>Sep 15, 2025</time></header><main class=u-prose><p>Over the past few weeks, I&rsquo;ve been diving into the world of agentic LLM workflows, particularly how they can be applied to complex programming tasks.
One area that&rsquo;s fascinated me is whether we can get AI agents to implement programming languages from scratch - not just generate code, but actually build interpreters and compilers.</p><p>This led me to create the <a href=https://eddmann.com/santa-lang-workshop/>santa-lang Workshop</a>.</p><blockquote><p>A cozy corner of the North Pole where <code>elf-lang</code> (a subset of <a href=https://eddmann.com/santa-lang/><code>santa-lang</code></a>) comes to life.
Here, magical elves (LLM agents) sit at their workbenches, carefully crafting elf-lang implementations in different languages and making sure each one behaves exactly as intended.
Just like Santa&rsquo;s workshop follows a shared plan, our elves follow a <strong>shared set of <code>.santat</code> tests</strong>, the official santa-lang wish list.
Each implementation must pass these tests before it can be wrapped up and placed under the tree.</p></blockquote><p><strong>Warning:</strong> I think I may have taken the Christmas-themed programming language thing a bit too far ü§∑‚Äç‚ôÇÔ∏è</p><p><picture><source type=image/webp srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_2d34b3cc511ca636.webp 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_35b823bcacc7caed.webp 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_b57a79b85106cbb8.webp 1400w"><source type=image/jpeg srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_f251b7b165a3a4f8.jpg 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_4d7c4872652102c1.jpg 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_85bc5b84fbd2ec94.jpg 1400w"><img src=/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/workshop_hu_4d7c4872652102c1.jpg alt="santa-lang Workshop" loading=lazy></picture></p><h2 id=the-workshop>The Workshop</h2><p>This started as a simple question: can we get LLM agents to automatically implement a programming language from scratch?
Not just generate some code, but actually build a complete interpreter or compiler that passes a comprehensive test suite.</p><p>The answer, it turns out, is yes - but it requires a very structured approach.
The <a href=https://github.com/eddmann/santa-lang-workshop rel="external noopener" target=_blank>workshop</a> provides a framework where agents can automatically implement <code>elf-lang</code> (a small, well‚Äëdefined subset of <a href=https://eddmann.com/santa-lang/><code>santa-lang</code></a>) in a chosen language using a given harness (Claude Code, Codex, Cursor etc.) and model (Sonnet 4, GPT-5 etc.), verify correctness against a shared <a href=https://www.phpinternalsbook.com/tests/phpt_file_structure.html rel="external noopener" target=_blank>PHPT‚Äëstyle</a> test suite, and iterate stage‚Äëby‚Äëstage so work can continue across agent sessions.</p><p>What really interested me was seeing how various harnesses and models would approach the same problem.
Would these alternative strategies lead to distinct architectural and implementation decisions?
The workshop setup lets me run these experiments systematically and compare the results.</p><h3 id=what-is-elf-lang>What is elf-lang?</h3><p><picture><source type=image/webp srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_f0829e8ffd44ea99.webp 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_bddd6f32ac9feb5e.webp 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_3813a531142dc891.webp 910w"><source type=image/jpeg srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_1dab57d48d3f3225.jpg 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_d841ed0d26b03eaa.jpg 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_56d6a1878babcaf2.jpg 910w"><img src=/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/logo_hu_d841ed0d26b03eaa.jpg alt="elf-lang Logo" loading=lazy></picture></p><p><code>elf-lang</code> is a dynamic, functional, C-like language subset inspired by <a href=https://eddmann.com/santa-lang/><code>santa-lang</code></a>; which was designed for Advent of Code-style problems and language ergonomics I value.
It includes literals; immutable collections (lists, sets, dicts) with structural equality; first-class functions; partial application; function composition (<code>>></code>); and a thread/pipeline operator (<code>|></code>).</p><p>I chose this subset because it&rsquo;s complex enough to be interesting but small enough to be manageable for an AI agent.
The <a href=https://eddmann.com/santa-lang-workshop/language/>full specification</a> is available on the workshop site if you&rsquo;d like to dive deeper.
Below is a small taste of the language&rsquo;s aesthetics:</p><pre tabindex=0><code>let factorial = |n| if n &lt;= 1 { 1 } else { n * factorial(n - 1) };
let inc = +(1);

[1,2,3]
  |&gt; map(inc &gt;&gt; factorial)
  |&gt; filter(|x| x &gt; 30)
  |&gt; fold(0, +)
</code></pre><h3 id=how-it-works>How it works</h3><p>The approach is surprisingly straightforward once you break it down.
You spin up a new implementation directory (using the provided <code>santa-bootstrap</code> tool) for your chosen language (Python, Go, Rust, etc.) and harness, then the agent (our elf) builds <code>elf-lang</code> incrementally through five stage‚Äëgated phases: lexing ‚Üí parsing ‚Üí evaluation ‚Üí collections ‚Üí higher‚Äëorder/composition.
Each agent gets a festive elf name and unique avatar - because why not add a bit of personality to the process?</p><p>What makes this work is the strict, implementation‚Äëagnostic CLI contract and PHPT‚Äëstyle <code>.santat</code> tests that define exact behaviour and formatting.
The agent must adhere to strict validation criteria - it must pass specific tests at each stage before proceeding.
Throughout the process, the agent records progress and decision rationale in a per‚Äëimplementation <code>JOURNAL</code> (using the provided <code>santa-journal</code> tool), keeping updates current and making the why/how of language‚Äëspecific choices visible.</p><h2 id=the-five-stage-approach>The five-stage approach</h2><p>I decided to break down the implementation into five distinct stages, each building on the last and accompanied by its own targeted test suite:</p><ol><li><strong>Lexing</strong>: Basic token recognition for literals, operators, symbols, keywords, and identifiers</li><li><strong>Parsing</strong>: Building an AST for literals, lets, operations, collections, conditionals, lambdas, function calls, and composition/threading</li><li><strong>Basic evaluation</strong>: Runtime implementation with <code>puts</code>, arithmetic, variables, and error handling</li><li><strong>Collections & indexing</strong>: List/set/dict operations, string manipulation, and edge cases</li><li><strong>Higher-order & composition</strong>: Recursion, <code>map</code>/<code>filter</code>/<code>fold</code>, and function arity rules</li></ol><p>The key insight here is that all prior stages must pass before moving forward - no regressions allowed.
At each stage, the agent consults the language specification, stage-specific tests, and reviews recent journal entries to implement just enough functionality for the current scope.
Once a stage is green (including all prior stages), the agent records another journal entry detailing the current status and next steps.
It can then proceed to the next stage.</p><h2 id=the-cli-contract>The CLI contract</h2><p>One of the most important aspects of this experiment is ensuring consistency across implementations.
Every implementation must provide an executable CLI that adheres to a strict contract (captured in the <a href=https://eddmann.com/santa-lang-workshop/tasks/>TASKS.md</a> provided to the agent):</p><ul><li>Run program: <code>&lt;bin> &lt;file></code></li><li>Print AST: <code>&lt;bin> ast &lt;file></code></li><li>Print tokens: <code>&lt;bin> tokens &lt;file></code></li></ul><h2 id=testing-approach>Testing approach</h2><p>The testing strategy borrows heavily from PHP&rsquo;s <a href=https://www.phpinternalsbook.com/tests/phpt_file_structure.html rel="external noopener" target=_blank>PHPT format</a>, which I&rsquo;ve found to be incredibly effective for this kind of work.
Tests are <code>.santat</code> files with sections like <code>--FILE--</code>, <code>--EXPECT--</code>, <code>--EXPECT_AST--</code>, and <code>--EXPECT_TOKENS--</code>.
This PHPT-inspired approach makes the suite implementation-agnostic and purely CLI-driven.</p><p>What makes this format so powerful is that it validates behaviour over implementation details.
By using the CLI as the public interface, I can test that a Python implementation produces the same output as a Rust implementation, regardless of how they&rsquo;re structured internally.
The test runner doesn&rsquo;t care whether you&rsquo;re using recursive descent parsing or a Pratt parser - it only cares that <code>1 + 2</code> evaluates to <code>3</code> and that the AST looks correct.
This focus on observable behaviour rather than internal architecture is crucial when comparing implementations across different languages and AI approaches.</p><p>The <code>santa-test</code> runner executes your CLI in different modes and compares stdout to the expected content, showing precise diffs on failure.
It&rsquo;s surprisingly satisfying to watch an agent work through failing tests one by one.</p><p><strong>Note:</strong> I initially hesitated to expose the tokens and AST, since these are typically considered implementation details.
However, I found that making them available was helpful for guiding the agent.
I may consider removing this requirement in the future.</p><h2 id=docker-isolation-and-ci>Docker isolation and CI</h2><p>One thing I quickly realised is that managing dependencies across multiple programming languages can get messy fast.
I solved this by encapsultating everything in Docker containers - each implementation gets its own isolated environment with all the necessary tooling.</p><p>This approach has several benefits: it keeps the host system clean (no need to install Python, Go, Rust, and whatever else), ensures reproducible builds, and makes the CI setup much more reliable.
The GitHub Actions workflow runs the <a href=https://github.com/eddmann/santa-lang-workshop/blob/main/.github/workflows/test-implementations.yml rel="external noopener" target=_blank>full test suite</a> for every implementation on every push to <code>main</code>.</p><p>The <a href=https://github.com/eddmann/santa-lang-workshop/blob/main/.github/workflows/publish-website.yml rel="external noopener" target=_blank>static site generation</a> also runs as part of the CI pipeline, so the showcase website stays up-to-date automatically.
It&rsquo;s satisfying to see all those green checkmarks across different languages and implementations.</p><h2 id=the-tooling-ecosystem>The tooling ecosystem</h2><p>To support this workflow, I developed four helper tools that streamline the entire process:</p><p><strong>santa-bootstrap</strong>: Scaffolds a new implementation directory with all the boilerplate.
This is where you specify your target language, harness, model, and any special requirements.
Each implementation gets assigned a festive elf name (like &ldquo;Guido Jinglecode&rdquo; for Python or &ldquo;Ruby Rednose&rdquo; for Ruby) and generates a unique avatar image to represent the agent.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tools/bin/santa-bootstrap --lang &lt;lang&gt; --harness &lt;harness&gt; --model &lt;model&gt; --requirements <span style=color:#e6db74>&#34;&lt;notes&gt;&#34;</span> --force
</span></span></code></pre></div><p><strong>santa-test</strong>: Runs the PHPT‚Äëstyle test suite against your implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tools/bin/santa-test --bin &lt;path-or-docker-uri&gt; <span style=color:#f92672>[</span>--update<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--timeout &lt;secs&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--jobs &lt;N&gt;<span style=color:#f92672>]</span> &lt;tests-or-directories&gt;
</span></span></code></pre></div><p><strong>santa-journal</strong>: Tracks progress and decisions throughout the implementation process.
This is crucial for maintaining continuity across agent sessions and ensuring that the agent resumes work exactly where they left off.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tools/bin/santa-journal <span style=color:#f92672>[</span>--dir &lt;impl-dir&gt;<span style=color:#f92672>]</span> &lt;author|progress|entry|entries&gt; <span style=color:#f92672>[</span>...<span style=color:#f92672>]</span>
</span></span></code></pre></div><p><strong>santa-site</strong>: Generates a static website showcasing all the implementations.
It&rsquo;s nice to have a visual overview of what&rsquo;s been built - the generated site shows each implementation&rsquo;s progress through the stages and includes a code explorer to look through the implementation within the browser.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>tools/bin/santa-site <span style=color:#f92672>[</span>--out-dir &lt;path&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--impl-dir &lt;path&gt;<span style=color:#f92672>]</span> <span style=color:#f92672>[</span>--base-path &lt;url-path&gt;<span style=color:#f92672>]</span>
</span></span></code></pre></div><h2 id=what-ive-learned>What I&rsquo;ve learned</h2><p>The santa-lang Workshop has been a fascinating exploration into agentic LLM workflows for programming language implementation.
By providing a structured, test-driven approach with clear stage gates and comprehensive tooling, I&rsquo;ve been able to observe how different AI agents approach the same language specification across various programming languages.</p><p>This project has taught me several important lessons about AI-assisted development.
First, the importance of structure cannot be overstated - agents need clear boundaries, specific tests, and incremental goals to succeed.
Second, the journaling system has proven invaluable for maintaining continuity across sessions and understanding the decision-making process.
Third, having a shared test suite ensures consistency across implementations, which is crucial when working with multiple agents.</p><p>It&rsquo;s been particularly fascinating to observe how different harnesses interpret the tasks I set and decompose the problem; while simultaneously seeing how various programming languages, with their unique idioms, patterns, and trade-offs - approach the same implementation challenge.
Comparing, for example, Python&rsquo;s dynamic flexibility to Rust&rsquo;s emphasis on memory safety, or Go&rsquo;s simplicity to Haskell&rsquo;s functional purity, has given me a crash course in both agentic reasoning and language design philosophy - all through the lens of practical implementation.</p><p><picture><source type=image/webp srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_2063c743ef9b30d1.webp 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_d5e34ae2b13e69d1.webp 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_92700ddc3e59a1e3.webp 1400w"><source type=image/jpeg srcset="/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_bce49e22a0782cc4.jpg 350w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_6e2608bebb4f7eb6.jpg 700w, /posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_aeaa22fd50aaaf53.jpg 1400w"><img src=/posts/santa-lang-workshop-exploring-agentic-llm-workflows-for-language-implementation/site_hu_6e2608bebb4f7eb6.jpg alt="santa-lang Workshop Site" loading=lazy></picture></p><p>To conclude, whether you&rsquo;re interested in programming language design, AI-assisted development, or simply curious about how elves might approach language implementation, the <a href=https://eddmann.com/santa-lang-workshop/>santa-lang Workshop</a> offers a unique perspective on the intersection of artificial intelligence and software engineering.
I hope to expand on the workshop in the future, making it a growing collection of implementations that highlight the unique qualities of different programming languages and AI approaches.</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/llm>llm</a></li><li><a href=/archive/tag/santa-lang>santa-lang</a></li><li><a href=/archive/tag/cursor>cursor</a></li><li><a href=/archive/tag/claude-code>claude-code</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/vibe-coding-a-chess-ui-building-on-the-esp32-with-cursor-and-lvgl/>Vibe Coding a Chess UI: Building on the ESP32 with Cursor & LVGL</a></li><li><a href=/posts/improving-an-f1-picks-game-in-4-hours/>Improving an F1 Picks Game in 4 Hours: It's Lights Out and Away We Go!</a></li><li><a href=/posts/lego-f1-minifigure-scanner-a-quick-build-with-gpt-5-and-cursor/>LEGO F1 Minifigure Scanner: A Quick Build with GPT-5 and Cursor</a></li><li><a href=/posts/how-i-used-chatgpt-to-fix-my-old-blog-posts-and-what-i-learned/>How I Used ChatGPT to Fix My Old Blog Posts (And What I Learned)</a></li><li><a href=/posts/rewriting-the-santa-lang-interpreter-in-rust-part-4-distribution/>Rewriting the santa-lang Interpreter in Rust, Part 4 - Distribution</a></li></ul></div></footer></article><div class="podcast-ad u-overlay-wrapper"><div class=podcast-ad__artwork><img src=https://compiledconversations.com/album-art.jpg alt="Compiled Conversations podcast album art" class=podcast-ad__artwork-image></div><div class=podcast-ad__content><h3 class=podcast-ad__title>Compiled Conversations</h3><p class=podcast-ad__description>Podcast I host, featuring conversations with the people shaping software and technology.</p><div class=podcast-ad__link>Check out the show</a></div><a class=u-overlay href=https://compiledconversations.com target=_blank>Listen to Compiled Conversations</a></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>