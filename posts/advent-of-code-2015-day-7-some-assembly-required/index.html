<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2015 - Day 7 - Some Assembly Required - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2015 Day 7 puzzle using TypeScript."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2015 - Day 7 - Some Assembly Required"><meta itemprop=description content="On the seventh day of Advent of Code 2015, we are tasked with helping little Bobby Tables assemble a circuit (wires and bitwise logic gates) that Santa brought him for Christmas."><meta itemprop=datePublished content="2021-01-31T00:00:00+00:00"><meta itemprop=dateModified content="2021-01-31T00:00:00+00:00"><meta itemprop=wordCount content="1190"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2015,Typescript"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2015-day-7-some-assembly-required/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2015 - Day 7 - Some Assembly Required"><meta property="og:description" content="On the seventh day of Advent of Code 2015, we are tasked with helping little Bobby Tables assemble a circuit (wires and bitwise logic gates) that Santa brought him for Christmas."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-01-31T00:00:00+00:00"><meta property="article:modified_time" content="2021-01-31T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2015"><meta property="article:tag" content="Typescript"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2015 - Day 7 - Some Assembly Required"><meta name=twitter:description content="On the seventh day of Advent of Code 2015, we are tasked with helping little Bobby Tables assemble a circuit (wires and bitwise logic gates) that Santa brought him for Christmas."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.5fbaacecfa2bd7648bff91abf1d24a0fb8a2e53d9c8d53d6b3afa628c3b0f7f6.css integrity="sha256-X7qs7Por12SL/5Gr8dJKD7ii5T2cjVPWs6+mKMOw9/Y="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2015-day-7-some-assembly-required/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Advent of Code 2015 - Day 7 - Some Assembly Required</h1><time class=post__time>Jan 31, 2021</time></header><main class=prose><p>On the seventh day of Advent of Code 2015, we are tasked with helping little Bobby Tables assemble a circuit (wires and bitwise logic gates) that Santa brought him for Christmas.</p><h2 id=part-1>Part 1</h2><p>Our input is an instruction booklet that describes how to connect these parts together.
By following the instructions laid out in the booklet, we are asked to determine what signal is ultimately provided to wire <code>a</code>.
As before, we will start by parsing the input into a usable form within our solution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Wire</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Instruction</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Circuit</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Map</span>&lt;<span style=color:#f92672>Wire</span>, <span style=color:#a6e22e>Instruction</span>&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parseCircuit</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Circuit</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;\n&#39;</span>).<span style=color:#a6e22e>reduce</span>((<span style=color:#a6e22e>circuit</span>, <span style=color:#a6e22e>line</span>) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>instruction</span>, <span style=color:#a6e22e>wire</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; -&gt; &#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>circuit</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instruction</span>);
</span></span><span style=display:flex><span>  }, <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>());
</span></span></code></pre></div><p>The parser above converts the instruction listing into a <code>Circuit</code> mapping between the defined <code>Wire</code> and associated actionable <code>Instruction</code> (i.e. bitwise operation, assignment).
With the input now parsed, we can move on to working out how we wish to emulate this circuit and record the outputted signals.
Reviewing the input leads us to the conclusion that we cannot expect the instructions to be in dependency order like the provided example is - i.e. <code>b</code> is declared and assigned almost at the end of the listing but is referenced many times before this.
Taking this on board, and as we only wish to determine what a single wire signal is, my initial solution is to begin at wire <code>a</code>&rsquo;s instruction and recursively build up the resulting signal.
This approach caters for the unsorted ordering and only performs the instructions required to answer the question.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>getEmulatedSignal</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>circuit</span>: <span style=color:#66d9ef>Circuit</span>, <span style=color:#a6e22e>wire</span>: <span style=color:#66d9ef>Wire</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>emulate</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>memoize</span>((<span style=color:#a6e22e>wire</span>: <span style=color:#66d9ef>Wire</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#e6db74>/^(\d)+$/</span>.<span style=color:#a6e22e>test</span>(<span style=color:#a6e22e>wire</span>)) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>toInt</span>(<span style=color:#a6e22e>wire</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instruction</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>circuit</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>wire</span>).<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; &#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>switch</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;AND&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&amp;</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;OR&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>|</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;LSHIFT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;RSHIFT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;NOT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#f92672>~</span><span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffff</span>;
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>wire</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Based on the currently supplied wire identifier, we provide a base case asserting that if the string value is a number, we simply return the integer equivalent.
All instructions laid out will eventually hit this base case, ensuring that the recursion will stop and the call stack tails can be evaluated.
Upon experimenting with this approach, I noticed that performance was a significant issue when attempting to run this on the actual input instruction booklet.
Due to naively recursing over all instructions, previously evaluated instructions would be unnecessarily recalculated multiple times down different branches.
To resolve this, I employed a small generic <a href=https://en.wikipedia.org/wiki/Memoization rel="external noopener" target=_blank>memoization</a> function, which wrapped the closure and opaquely provided a caching mechanism for subsequent calls to the same resolved wire signal.</p><p>You will also notice the use of a <code>0xffff</code> mask when applying the <em>NOT</em> operation on the value.
As explained in the problem statement, the signals are unsigned 16-bit values; however, JavaScript bitwise operators use 32 bits.
To produce the desired results, we must apply the 16-bit mask provided.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part1</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>getEmulatedSignal</span>(<span style=color:#a6e22e>parseCircuit</span>(<span style=color:#a6e22e>input</span>), <span style=color:#e6db74>&#39;a&#39;</span>);
</span></span></code></pre></div><p>With the logic in place, we can combine the two functions and determine the resulting signal from wire <code>a</code> ðŸŒŸ.</p><h2 id=part-2>Part 2</h2><p>For part two, we are required to replace the original input&rsquo;s wire <code>b</code> value with the resulting signal that we emulated in part one for wire <code>a</code>.
From this, we are then asked to determine the new resulting signal for wire <code>a</code>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part2</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>circuit</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>parseCircuit</span>(<span style=color:#a6e22e>input</span>);
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>circuit</span>.<span style=color:#66d9ef>set</span>(<span style=color:#e6db74>&#39;b&#39;</span>, <span style=color:#a6e22e>getEmulatedSignal</span>(<span style=color:#a6e22e>circuit</span>, <span style=color:#e6db74>&#39;a&#39;</span>).<span style=color:#a6e22e>toString</span>());
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>getEmulatedSignal</span>(<span style=color:#a6e22e>circuit</span>, <span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>By modifying the parsed circuit mapping before getting the newly emulated signal, we obtain the desired answer ðŸŒŸ.</p><h2 id=alternative-solution>Alternative Solution</h2><p>Since solving this problem, I re-evaluated the provided input and noticed that it did not include any <a href=https://en.wikipedia.org/wiki/Circular_dependency rel="external noopener" target=_blank>circular dependencies</a>!
As such, it could be treated as a <a href=https://en.wikipedia.org/wiki/Directed_acyclic_graph rel="external noopener" target=_blank>Directed Acyclic Graph</a> (DAG), which would allow us to perform a <a href=https://en.wikipedia.org/wiki/Topological_sorting rel="external noopener" target=_blank>Topological Sort</a> to return the correctly ordered instruction listing.
This would allow us to emulate the circuit without the need for recursion.
I set out to re-implement the solution using this newfound knowledge and approach.</p><p>I began by creating the function below, which parses the instruction listing in a very different manner than before.
Instead of simply returning the parsed instructions in an unordered map back to the callee, this function returns an array of the <em>correctly</em> ordered instruction execution.
Correctness, in this case, means that all required wire signal values will have already been emulated before attempting to evaluate the given wire instruction.
As such, we can just iterate through the instruction listing once to return the entire signal value outputs.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Wire</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>;
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Instruction</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>string</span>[];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>createInstructionExecutionOrder</span> <span style=color:#f92672>=</span> (
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> [<span style=color:#a6e22e>Wire</span>, <span style=color:#a6e22e>Instruction</span>][] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>dependencies</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>&lt;<span style=color:#f92672>Wire</span>, <span style=color:#a6e22e>Wire</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt;();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instructions</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>&lt;<span style=color:#f92672>Wire</span>, <span style=color:#a6e22e>Instruction</span>&gt;();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>const</span> <span style=color:#a6e22e>line</span> <span style=color:#66d9ef>of</span> <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;\n&#39;</span>)) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> [<span style=color:#a6e22e>instruction</span>, <span style=color:#a6e22e>wire</span>] <span style=color:#f92672>=</span> <span style=color:#a6e22e>line</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; -&gt; &#39;</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dependencies</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>match</span>(<span style=color:#e6db74>/([a-z]+)/g</span>) <span style=color:#f92672>||</span> []);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>instructions</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39; &#39;</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>visited</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Set</span>&lt;<span style=color:#f92672>Wire</span>&gt;();
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ordered</span>: <span style=color:#66d9ef>Wire</span>[] <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  [...<span style=color:#a6e22e>dependencies</span>.<span style=color:#a6e22e>keys</span>()].<span style=color:#a6e22e>forEach</span>(<span style=color:#66d9ef>function</span> <span style=color:#a6e22e>dfs</span>(<span style=color:#a6e22e>wire</span>: <span style=color:#66d9ef>Wire</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>visited</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>wire</span>)) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>visited</span>.<span style=color:#a6e22e>add</span>(<span style=color:#a6e22e>wire</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dependencies</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>wire</span>).<span style=color:#a6e22e>forEach</span>(<span style=color:#a6e22e>dfs</span>);
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>ordered</span>.<span style=color:#a6e22e>push</span>(<span style=color:#a6e22e>wire</span>);
</span></span><span style=display:flex><span>  });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>ordered</span>.<span style=color:#a6e22e>reduce</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>wires</span>, <span style=color:#a6e22e>wire</span>) <span style=color:#f92672>=&gt;</span> [...<span style=color:#a6e22e>wires</span>, [<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instructions</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>wire</span>)]],
</span></span><span style=display:flex><span>    []
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Treating the instruction booklet as a DAG allows us to perform the Topological Sort (opting for the <a href=https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search rel="external noopener" target=_blank>depth-first search approach</a>) and return the ordered instructions.
With this in hand, we now need a means to emulate and return the signal value for a given wire&rsquo;s instruction - based on the signal mapping that we have built up to that point.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#a6e22e>Signals</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>Map</span>&lt;<span style=color:#f92672>Wire</span>, <span style=color:#a6e22e>number</span>&gt;;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>emulate</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>signals</span>: <span style=color:#66d9ef>Signals</span>, <span style=color:#a6e22e>instruction</span>: <span style=color:#66d9ef>Instruction</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#66d9ef>get</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>token</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>signals</span>.<span style=color:#a6e22e>has</span>(<span style=color:#a6e22e>token</span>) <span style=color:#f92672>?</span> <span style=color:#a6e22e>signals</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>token</span>) <span style=color:#f92672>:</span> <span style=color:#a6e22e>toInt</span>(<span style=color:#a6e22e>token</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>switch</span> (<span style=color:#66d9ef>true</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;AND&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&amp;</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;OR&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>|</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;LSHIFT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&lt;&lt;</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;RSHIFT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]) <span style=color:#f92672>&gt;&gt;</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>2</span>]);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>case</span> <span style=color:#a6e22e>instruction</span>.<span style=color:#a6e22e>includes</span>(<span style=color:#e6db74>&#39;NOT&#39;</span>)<span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#f92672>~</span><span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>1</span>]) <span style=color:#f92672>&amp;</span> <span style=color:#ae81ff>0xffff</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>default</span><span style=color:#f92672>:</span>
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>instruction</span>[<span style=color:#ae81ff>0</span>]);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>We use a local <code>get</code> helper function to attempt to retrieve the instruction identifier value from the signal mapping; otherwise, we assume it must be an integer value that we must parse.
From here, we can then perform a single reduction over the instruction execution listing, building up the resulting signal mapping along the way.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part1</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>signals</span>: <span style=color:#66d9ef>Signals</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createInstructionExecutionOrder</span>(<span style=color:#a6e22e>input</span>).<span style=color:#a6e22e>reduce</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>signals</span>, [<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instruction</span>]) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>signals</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>signals</span>, <span style=color:#a6e22e>instruction</span>)),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>()
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>signals</span>.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>It is then from this built map that we can get the signal value which has been emulated for wire <code>a</code>.
Likewise, we can solve part two in a similar manner, except we must first replace the signal value of wire <code>b</code> with part one&rsquo;s answer.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part2</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>instructions</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>createInstructionExecutionOrder</span>(
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>replace</span>(<span style=color:#e6db74>/^\d+ -&gt; b$/gm</span>, <span style=color:#e6db74>`</span><span style=color:#e6db74>${</span><span style=color:#a6e22e>part1</span>(<span style=color:#a6e22e>input</span>).<span style=color:#a6e22e>toString</span>()<span style=color:#e6db74>}</span><span style=color:#e6db74> -&gt; b`</span>)
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>signals</span>: <span style=color:#66d9ef>Signals</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>instructions</span>.<span style=color:#a6e22e>reduce</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>signals</span>, [<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>instruction</span>]) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>signals</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>wire</span>, <span style=color:#a6e22e>emulate</span>(<span style=color:#a6e22e>signals</span>, <span style=color:#a6e22e>instruction</span>)),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>()
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>signals</span>.<span style=color:#66d9ef>get</span>(<span style=color:#e6db74>&#39;a&#39;</span>);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>I really enjoyed exploring the Topological Sorting algorithm to implement the second solution to today&rsquo;s problem.
By performing this initial ordering, we can greatly simplify the emulation logic and remove the need for any memoization or recursive calls.</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/advent-of-code-2015>advent-of-code-2015</a><a href=/archive/tag/typescript>typescript</a></footer></article><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;setTimeout(()=>{const s=window.pageYOffset;n.classList.toggle("is-sticky",s>0&&t>s),t=s,e=!1},500),e=!0})})()</script></body></html>