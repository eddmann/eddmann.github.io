<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2016 - Day 7 - Internet Protocol Version 7 - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2016 Day 7 puzzle using Python."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2016 - Day 7 - Internet Protocol Version 7"><meta itemprop=description content="On the seventh day of Advent of Code 2016, we are required to determine which IPv7 addresses support TLS (Transport-Layer Snooping) and SSL (Super-Secret Listening)."><meta itemprop=datePublished content="2021-03-29T00:00:00+00:00"><meta itemprop=dateModified content="2021-03-29T00:00:00+00:00"><meta itemprop=wordCount content="577"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2016,Python"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2016-day-7-internet-protocol-version-7/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2016 - Day 7 - Internet Protocol Version 7"><meta property="og:description" content="On the seventh day of Advent of Code 2016, we are required to determine which IPv7 addresses support TLS (Transport-Layer Snooping) and SSL (Super-Secret Listening)."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-03-29T00:00:00+00:00"><meta property="article:modified_time" content="2021-03-29T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2016"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2016 - Day 7 - Internet Protocol Version 7"><meta name=twitter:description content="On the seventh day of Advent of Code 2016, we are required to determine which IPv7 addresses support TLS (Transport-Layer Snooping) and SSL (Super-Secret Listening)."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.c3ee6cab58dd3fee7e6960b0391e996ba9254804702bc60a52ec5e0e3591a018.css integrity="sha256-w+5sq1jdP+5+aWCwOR6Za6klSARwK8YKUuxeDjWRoBg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2016-day-7-internet-protocol-version-7/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.164d56ac6f4c8613b0b7109fd1b4d9dfdce1d004edab8e1afb7240013f9221d7.js integrity="sha256-Fk1WrG9MhhOwtxCf0bTZ39zh0ATtq44a+3JAAT+SIdc=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:advent-of-code-2016-day-7-internet-protocol-version-7>Advent of Code 2016 - Day 7 - Internet Protocol Version 7</h1><time datetime=2021-03-29T00:00:00Z class=published-at>Mar 29, 2021</time></header><main class=u-prose><p>On the seventh day of Advent of Code 2016, we are required to determine which IPv7 addresses support TLS (Transport-Layer Snooping) and SSL (Super-Secret Listening).</p><h2 id=part-1>Part 1</h2><p>We are supplied with a list of IPv7 addresses, which consist of supernets (sequences outside square brackets) and hypernets (sequences within square brackets).
For part one, we are required to count how many IPv7 addresses support TLS.</p><blockquote><p>An IP supports TLS if it has an Autonomous Bridge Bypass Annotation, or ABBA.
An ABBA is any four-character sequence which consists of a pair of two different characters followed by the reverse of that pair, such as xyyx or abba.
However, the IP also must not have an ABBA within any hypernet sequences, which are contained by square brackets.</p></blockquote><p>We will begin by parsing the IPv7 addresses into a structured form that we can process further.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_ips</span>(input):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_ip</span>(ip):
</span></span><span style=display:flex><span>        supernets <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>split(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;\[[^\]]+\]&#34;</span>, ip)
</span></span><span style=display:flex><span>        hypernets <span style=color:#f92672>=</span> re<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;\[([^\]]+)\]&#34;</span>, ip)
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> supernets, hypernets
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> map(parse_ip, input<span style=color:#f92672>.</span>splitlines())
</span></span></code></pre></div><p>Now, having access to a structured tuple that includes all the supernets and hypernets for a given address, we can construct a predicate function to check if the IP supports TLS.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>has_tls_support</span>(ip):
</span></span><span style=display:flex><span>    supernets, hypernets <span style=color:#f92672>=</span> ip
</span></span><span style=display:flex><span>    abba <span style=color:#f92672>=</span> <span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;(.)((?!\1).)\2\1&#34;</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> any(re<span style=color:#f92672>.</span>search(abba, s) <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> supernets) <span style=color:#f92672>and</span> <span style=color:#f92672>not</span> any(re<span style=color:#f92672>.</span>search(abba, h) <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> hypernets)
</span></span></code></pre></div><p>We construct a regular expression that captures an initial character (<em>a</em>), followed by a different character (<em>b</em>), and then ensures that the sequence follows the captured groupings <em>b</em> and <em>a</em>.
This expression is then searched for within both the IP supernets and hypernets, ensuring that it is present in at least one supernet but absent from all hypernets.
With this predicate function in place, we can map over all the parsed IP addresses and count those that support TLS.
In doing so, we have answered part one of today&rsquo;s puzzle ðŸŒŸ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(input):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum(has_tls_support(ip) <span style=color:#66d9ef>for</span> ip <span style=color:#f92672>in</span> parse_ips(input))
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><p>For part two, we are instead asked to count how many of these parsed IPv7 addresses support SSL.</p><blockquote><p>An IP supports SSL if it has an Area-Broadcast Accessor, or ABA, anywhere in the supernet sequences (outside any square bracketed sections), and a corresponding Byte Allocation Block, or BAB, anywhere in the hypernet sequences.
An ABA is any three-character sequence which consists of the same character twice with a different character between them, such as xyx or aba.
A corresponding BAB is the same characters but in reversed positions: yxy and bab, respectively.</p></blockquote><p>Similar to how we checked for TLS support, we will create a small predicate function that handles the base case of a single IP.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>has_ssl_support</span>(ip):
</span></span><span style=display:flex><span>    supernets, hypernets <span style=color:#f92672>=</span> ip
</span></span><span style=display:flex><span>    aba <span style=color:#f92672>=</span> iter(ab
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>for</span> s <span style=color:#f92672>in</span> supernets
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>for</span> ab <span style=color:#f92672>in</span> re<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#34;(?=(.)((?!\1).)\1)&#34;</span>, s))
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> any(b <span style=color:#f92672>+</span> a <span style=color:#f92672>+</span> b <span style=color:#f92672>in</span> h <span style=color:#66d9ef>for</span> a, b <span style=color:#f92672>in</span> aba <span style=color:#66d9ef>for</span> h <span style=color:#f92672>in</span> hypernets)
</span></span></code></pre></div><p>We use a regular expression again to find all occurrences of <em>aba</em> within the provided supernets, returning the captured <em>a</em> and <em>b</em> values from each match.
These values are then used to check if a hypernet contains the corresponding <em>bab</em> pattern.
We wrap the expression in a positive lookahead to accommodate overlapping matches such as <code>zazbz</code>, which contains both <code>zaz</code> and <code>zbz</code>.
This highlights the power of Python&rsquo;s list comprehension capabilities.</p><p>Finally, we can tweak the part one solution to filter the IP address list and count those that support SSL.
In doing so, we have answered part two of today&rsquo;s puzzle ðŸŒŸ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(input):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sum(has_ssl_support(ip) <span style=color:#66d9ef>for</span> ip <span style=color:#f92672>in</span> parse_ips(input))
</span></span></code></pre></div></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/advent-of-code>advent-of-code</a></li><li><a href=/archive/tag/advent-of-code-2016>advent-of-code-2016</a></li><li><a href=/archive/tag/python>python</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/advent-of-code-2016-day-6-signals-and-noise/>Advent of Code 2016 - Day 6 - Signals and Noise</a></li><li><a href=/posts/advent-of-code-2016-day-5-how-about-a-nice-game-of-chess/>Advent of Code 2016 - Day 5 - How About a Nice Game of Chess?</a></li><li><a href=/posts/advent-of-code-2016-day-4-security-through-obscurity/>Advent of Code 2016 - Day 4 - Security Through Obscurity</a></li><li><a href=/posts/advent-of-code-2016-day-3-squares-with-three-sides/>Advent of Code 2016 - Day 3 - Squares With Three Sides</a></li><li><a href=/posts/advent-of-code-2016-day-2-bathroom-security/>Advent of Code 2016 - Day 2 - Bathroom Security</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>