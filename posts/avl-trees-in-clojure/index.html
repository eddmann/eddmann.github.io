<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to implement a self-balancing AVL binary search tree in Clojure, ensuring optimal search performance through automatic rebalancing.">

    <title>
        
            AVL Trees in Clojure &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">AVL Trees in Clojure</h1>
    <time datetime="2016-09-03T00:00:00+00:00" class="post-date">03 Sep 2016</time>
    <p>An AVL tree is a self-balancing binary search tree, whereby the height of a node’s children differs by at most one.
In the event that this property is violated, a rebalancing process takes place. 
In the past, I have discussed how to implement a <a href="/posts/binary-search-trees-in-clojure/">Binary Search Tree in Clojure</a>, providing an average time complexity of O(log n).
However, if the order of insertion is sequential (where each value is either greater than or less than the last), time complexity increases to be linear, the same as a linked list.
Self-balancing trees, such as the AVL variant, provide us with a worst-case complexity of O(log n), thanks to their rebalancing phase.</p>

<h2 id="balance-factor">Balance Factor</h2>

<p>Using the previous Binary Search Tree implementation as a base, we can expand upon this to include the AVL property.
For the sake of performance, you would typically store the height of each node’s children within the structure.
However, as I wish to reuse the existing implementation, I will instead calculate their height upon <code class="language-plaintext highlighter-rouge">factor</code> invocation.
The balance factor of a node is calculated as the difference between the heights of its two child nodes, as shown below.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">height</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="w"> </span><span class="nb">count</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">tree</span><span class="w">
      </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">))</span><span class="w">
           </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">)))</span><span class="w">
      </span><span class="nb">count</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="nb">right</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The above two functions provide the described behaviour, allowing us to supply a root node and return its balance factor.</p>

<h2 id="rotations">Rotations</h2>

<p>To complete the final rebalancing step, we must also be able to rotate a given node both left and right within the tree structure.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate-left</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">right</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="p">(</span><span class="no">:el</span><span class="w"> </span><span class="nb">right</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="n">tree</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate-right</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">left</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="p">(</span><span class="no">:el</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="n">tree</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>This can be achieved as shown above, taking advantage of an immutable approach.</p>

<h2 id="rebalancing-phase">Rebalancing Phase</h2>

<p>With the balance factor and rotation actions now available, we can begin working on the four different situations where a node’s placement requires a tree rotation.</p>

<p><img src="/uploads/avl-trees-in-clojure/lr-ll-cases.png" alt="Left Right, Left Left Cases" /></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-left-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="mi">-1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-left-right-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">is-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><img src="/uploads/avl-trees-in-clojure/rl-rr-cases.png" alt="Right Left, Right Right Cases" /></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-right-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-right-left-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">is-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>With these conditions now identifiable, we can apply the desired tree rotations, as visualised in the diagrams above.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-right-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-left-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="nb">right</span><span class="p">)))</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w">
    </span><span class="no">:else</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h2 id="example-usage">Example Usage</h2>

<p>Finally, we can create new AVL insertion and deletion variants by composing the Binary Search Tree functions with the newly created <code class="language-plaintext highlighter-rouge">balance</code> function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">avl-insert</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">insert</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">avl-remove</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="nb">remove</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">seq-&gt;avl</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">reduce</span><span class="w"> </span><span class="n">avl-insert</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>These data structures can then be visualised using the following function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tabs</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="w"> </span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="s">"\t"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">visualise</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}</span><span class="w"> </span><span class="n">depth</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">tree</span><span class="w">
      </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="nb">right</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">tabs</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="s">"\n"</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">tabs</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="s">"~\n"</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="p">(</span><span class="nf">seq-&gt;avl</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">;       3</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">; 2</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">;       1</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span></code></pre></div></div>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
