<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Scala on Edd Mann</title><link>https://eddmann.com/archive/tag/scala/</link><description>Recent content in Scala on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Sun, 06 Apr 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/scala/index.xml" rel="self" type="application/rss+xml"/><item><title>Functional Quick sort in Scala and JavaScript</title><link>https://eddmann.com/posts/functional-quick-sort-in-scala-and-javascript/</link><pubDate>Sun, 06 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/functional-quick-sort-in-scala-and-javascript/</guid><description>&lt;p>Functional languages provide you with the ability to concisely define the intent of a piece of code, without low-level issues getting in the way.
This can be clearly seen when implementing the Quick sort algorithm.
Often referred to as &amp;lsquo;partition-exchange&amp;rsquo; sort, this divide and conquer algorithm recursively divides a list into two sub-lists, based on a chosen pivot element.&lt;/p></description></item><item><title>Reverse Polish Notation (RPN) in Scala</title><link>https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/</link><pubDate>Sun, 15 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/</guid><description>&lt;p>Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical &lt;a href="http://en.wikipedia.org/wiki/Reverse_Polish_Notation" rel="external noopener" target="_blank">Reverse Polish notation&lt;/a> string.
Popularised by its use in the &lt;a href="http://en.wikipedia.org/wiki/HP-10C_series" rel="external noopener" target="_blank">HP-10C&lt;/a> series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation).&lt;/p></description></item><item><title>Using For-Comprehensions in Scala</title><link>https://eddmann.com/posts/using-for-comprehensions-in-scala/</link><pubDate>Wed, 11 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/using-for-comprehensions-in-scala/</guid><description>&lt;p>Scala can be a very deceptive language, as type inference is a good example of this.
Another less understood example that you will soon be introduced to upon closer exploration of the language is the &amp;lsquo;for-comprehension&amp;rsquo;.
The first point I wish to highlight is that in Scala everything is an expression which returns a value, even if this be Unit (which is equivalent to nothing).
This is a fundamental design principle of Scala which allows for productive use of its functional nature.
In an imperative manner, for example, we have become very accustomed to declaring and assigning a default value, only to reassign it with another if a condition is met on the next line.
Due to the expressive nature of the language, this can instead be condensed into one line, immutably and as a result is less prone to error.&lt;/p></description></item><item><title>Solving the k-combinations problem in Scala</title><link>https://eddmann.com/posts/solving-the-k-combinations-problem-in-scala/</link><pubDate>Tue, 03 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/solving-the-k-combinations-problem-in-scala/</guid><description>&lt;p>More often than not there are many different ways to solve a particular task.
I encountered this trait when coding a solution to the k-combinations (N-choose-k) problem.
A &lt;a href="http://en.wikipedia.org/wiki/Combination" rel="external noopener" target="_blank">combination&lt;/a> is the action of selecting a set number of elements from a larger group, where order is not considered (unlike a &lt;a href="http://en.wikipedia.org/wiki/Permutation" rel="external noopener" target="_blank">permutation&lt;/a>).
An example of a combination is in the cards you are dealt in a poker hand - from the possible 52 cards, you are dealt 5 (52 choose 5).
We can calculate the unique hand offerings in many different ways, allowing us to predict how likely it is for an individual card to be dealt.
In this post, I will show examples of solving the 10 choose 2 problem.&lt;/p></description></item><item><title>Merge sort in Scala using Tail-recursion and Streams</title><link>https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/</guid><description>&lt;p>In a previous &lt;a href="https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/">post&lt;/a> I made a rudimentary comparison of Java and Scala using the &lt;a href="http://en.wikipedia.org/wiki/Merge_sort" rel="external noopener" target="_blank">Merge sort&lt;/a> algorithm as a case study.
There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list.
In this post I wish to describe two very different implementations that resolve this glaring omission.&lt;/p></description></item><item><title>Merge sort comparison in Java and Scala</title><link>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</guid><description>&lt;p>Having only just recently got a complete shot of functional goodness in the form of the &lt;a href="http://www.coursera.org/course/progfun" rel="external noopener" target="_blank">Functional Programming Principles in Scala&lt;/a> &lt;a href="http://en.wikipedia.org/wiki/Massive_open_online_course" rel="external noopener" target="_blank">MOOC&lt;/a>, my imperative standing is in a state of confusion.
Is mutability the devil, should every function not have side-effects, what really is a monad?
Okay, so I may be joking a little with these semi-rhetorical remarks - boy, have I read enough monad posts for a lifetime.
Added to the mainstream application design consensus, the functional paradigm is making inroads out of multi-core necessity (goodbye &lt;a href="http://en.wikipedia.org/wiki/Moore%27s_law" rel="external noopener" target="_blank">Moore&amp;rsquo;s law&lt;/a>).&lt;/p></description></item></channel></rss>