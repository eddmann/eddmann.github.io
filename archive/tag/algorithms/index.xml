<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Algorithms on Edd Mann</title><link>https://eddmann.com/archive/tag/algorithms/</link><description>Recent content in Algorithms on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Mon, 15 Aug 2016 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/algorithms/index.xml" rel="self" type="application/rss+xml"/><item><title>Anagram Solver in Clojure</title><link>https://eddmann.com/posts/anagram-solver-in-clojure/</link><pubDate>Mon, 15 Aug 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/anagram-solver-in-clojure/</guid><description>&lt;p>This past week, a discussion around solving anagrams was brought up.
I thought it would be interesting to devise a couple of methods for computationally achieving such a task.
Providing an anagram string and a dictionary file, I wished to return all possible matching words from the dictionary.&lt;/p></description></item><item><title>Insertion Sort in Clojure</title><link>https://eddmann.com/posts/insertion-sort-in-clojure/</link><pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/insertion-sort-in-clojure/</guid><description>&lt;p>The next sorting algorithm I have decided to explore is the Insertion Sort.
This sorting technique can be completed in-place.
However, using Clojure, we will instead use &lt;code>reduce&lt;/code> to accumulate the final sorted collection.
Each element is iteratively inserted into a &amp;rsquo;new&amp;rsquo; collection, which maintains a sorted invariant, as shown in the implementation documented below.&lt;/p></description></item><item><title>Bubble Sort in Clojure... again</title><link>https://eddmann.com/posts/bubble-sort-in-clojure-again/</link><pubDate>Sun, 21 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/bubble-sort-in-clojure-again/</guid><description>&lt;p>Following on from my &lt;a href="https://eddmann.com/posts/bubble-sort-in-clojure/">previous solution&lt;/a> to implementing the Bubble Sort algorithm in Clojure, I thought it would be interesting to experiment with a different approach.
Taking advantage of lists and vectors&amp;rsquo; respective cheap head and tail insertions, we can use these two properties to good effect, as shown below.&lt;/p></description></item><item><title>Bubble Sort in Clojure</title><link>https://eddmann.com/posts/bubble-sort-in-clojure/</link><pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/bubble-sort-in-clojure/</guid><description>&lt;p>Following on with my exploration into implementing common sorting algorithms in Clojure, today we have the Bubble Sort.
This sort works by iteratively passing through the supplied sequence, swapping the current element with the next if it is comparably greater.
The operation is complete when a pass through the sequence does not result in a swap occurring.&lt;/p></description></item><item><title>Checking for Balanced Parentheses in Clojure</title><link>https://eddmann.com/posts/checking-for-balanced-parentheses-in-clojure/</link><pubDate>Wed, 13 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/checking-for-balanced-parentheses-in-clojure/</guid><description>&lt;p>This lunchtime I decided to implement a solution to the balanced parentheses (brackets) problem in Clojure.
Looking at the code below, you can see that I took advantage of the &lt;code>cond&lt;/code> macro to more clearly express the recursive algorithm&amp;rsquo;s intent.
I have also provided a couple of test assertions which are stored in the vars metadata and called using the core library&amp;rsquo;s &lt;code>test&lt;/code> function.&lt;/p></description></item><item><title>QuickSort in Clojure</title><link>https://eddmann.com/posts/quicksort-in-clojure/</link><pubDate>Mon, 11 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/quicksort-in-clojure/</guid><description>&lt;p>This past weekend I had the opportunity to delve more deeply into Clojure&amp;rsquo;s &lt;a href="https://clojuredocs.org/clojure.core" rel="external noopener" target="_blank">core library&lt;/a>.
I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways.&lt;/p></description></item><item><title>Mergesort in Clojure using Post Conditionals</title><link>https://eddmann.com/posts/mergesort-in-clojure-using-post-conditionals/</link><pubDate>Tue, 05 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mergesort-in-clojure-using-post-conditionals/</guid><description>&lt;p>Whilst currently reading through &lt;a href="https://www.manning.com/books/the-joy-of-clojure" rel="external noopener" target="_blank">The Joy of Clojure&lt;/a> book I was introduced to the concept of pre and post-conditionals, similar to another language called &lt;a href="https://en.wikipedia.org/wiki/Eiffel_%28programming_language%29" rel="external noopener" target="_blank">Eiffel&lt;/a>.
To experiment with this feature I decided to create a simple merge-sort algorithm implementation which ensured that its returned values were sorted by the provided predicate.&lt;/p></description></item><item><title>Infix Calculator in Clojure</title><link>https://eddmann.com/posts/infix-calculator-in-clojure/</link><pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/infix-calculator-in-clojure/</guid><description>&lt;p>Following on from my previous post, I have continued my exploration into Clojure by implementing a simple infix calculator - using the Shunting Yard algorithm and RPN evaluation.
The documented implementation is split into three distinct parts, of which I will describe piece-by-piece before composing them together to result in the final calculator.&lt;/p></description></item><item><title>Arabic to Roman Numerals Converter in JavaScript</title><link>https://eddmann.com/posts/arabic-to-roman-numerals-converter-in-javascript/</link><pubDate>Tue, 20 Oct 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/arabic-to-roman-numerals-converter-in-javascript/</guid><description>Having an hour to spare recently, I decided to solve the common problem of converting from Hindu-Arabic to Roman numerals.</description></item><item><title>Implementing the Shunting Yard algorithm in JavaScript</title><link>https://eddmann.com/posts/implementing-the-shunting-yard-algorithm-in-javascript/</link><pubDate>Sat, 29 Aug 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-the-shunting-yard-algorithm-in-javascript/</guid><description>Following on from my recent post on implementing a small RPN parser using JavaScript, we can expand on this by handling infix expressions. This can be achieved by initially parsing the expression into its postfix (RPN) counterpart, highlighting another use case where a stack-based approach works well.</description></item><item><title>Small RPN Implementation in JavaScript</title><link>https://eddmann.com/posts/small-rpn-implementation-in-javascript/</link><pubDate>Tue, 25 Aug 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/small-rpn-implementation-in-javascript/</guid><description>This morning I decided to quickly write up a small Reverse Polish Notation evaluator in JavaScript. Evaluation of these expressions highlights the perfect use-case for a stack-based approach.</description></item><item><title>Insertion, Removal and Inversion Operations on Binary (Search) Trees in PHP</title><link>https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/</link><pubDate>Wed, 22 Jul 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/</guid><description>&lt;p>Recently Max Howell (creator of &lt;a href="http://brew.sh/" rel="external noopener" target="_blank">Homebrew&lt;/a>) posted an interesting &lt;a href="https://twitter.com/mxcl/status/608682016205344768" rel="external noopener" target="_blank">tweet&lt;/a> in regard to Google&amp;rsquo;s interview process.
In this tweet he mentioned how one of the proposed questions was to white-board a solution to invert a binary tree.
Over the past couple of years I have been interested in exploring fundamental computer science data structures and algorithms.
As a result, I thought it would be interesting to explore this structure and its associated operations in more depth - using immutable and mutable PHP implementations to clearly highlight the benefits garnered from each approach.&lt;/p></description></item><item><title>Implementing ROT13 and ROT(n) Caesar Ciphers in Python</title><link>https://eddmann.com/posts/implementing-rot13-and-rot-n-caesar-ciphers-in-python/</link><pubDate>Sat, 12 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-rot13-and-rot-n-caesar-ciphers-in-python/</guid><description>&lt;p>The Caesar cipher (shift cipher) is an extremely simple encryption technique.
Substitutions of this kind rely on an invariant - replacing each plain-text letter with the letter at a fixed number of positions across the alphabet.
The recipient is then able to decode the encoded message successfully if they are aware of the chosen shift.&lt;/p></description></item><item><title>Functional Quick sort in Scala and JavaScript</title><link>https://eddmann.com/posts/functional-quick-sort-in-scala-and-javascript/</link><pubDate>Sun, 06 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/functional-quick-sort-in-scala-and-javascript/</guid><description>&lt;p>Functional languages provide you with the ability to concisely define the intent of a piece of code, without low-level issues getting in the way.
This can be clearly seen when implementing the Quick sort algorithm.
Often referred to as &amp;lsquo;partition-exchange&amp;rsquo; sort, this divide and conquer algorithm recursively divides a list into two sub-lists, based on a chosen pivot element.&lt;/p></description></item><item><title>Parallel Summation in Java</title><link>https://eddmann.com/posts/parallel-summation-in-java/</link><pubDate>Fri, 14 Mar 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/parallel-summation-in-java/</guid><description>Summation is the common operation of adding a sequence of numbers together, resulting in their total. The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress. For small sequences, a single-threaded implementation will suffice.</description></item><item><title>Using Iterative deepening depth-first search in Python</title><link>https://eddmann.com/posts/using-iterative-deepening-depth-first-search-in-python/</link><pubDate>Thu, 06 Mar 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/using-iterative-deepening-depth-first-search-in-python/</guid><description>&lt;p>Iterative deepening depth-first search (IDDFS) is an extension to the &amp;lsquo;vanilla&amp;rsquo; depth-first search algorithm, with an added constraint on the total depth explored per iteration.
It produces equivalent results to those achieved using breadth-first search, without incurring the large memory costs.
Due to breadth-first search storing fringe vertices in memory, O(b^d) memory space may be required (where b is the branching factor).
This is in stark contrast to IDDFS&amp;rsquo;s worst-case memory requirements of O(bd).
At each iteration, vertex successors at the depth-cap level are ignored.
If the goal has not been found, the maximum level is increased by one and the process repeated.
Similarly to breadth-first search, it guarantees finding an optimal path between two vertices, as the shallowest goal vertex is reached first due to the depth cap, resulting in no exploration of subsequent, unnecessary branches.&lt;/p></description></item><item><title>Depth-First Search and Breadth-First Search in Python</title><link>https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/</link><pubDate>Wed, 05 Mar 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/depth-first-search-and-breadth-first-search-in-python/</guid><description>Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics. Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains. One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph.</description></item><item><title>Implementing Heapsort in Java and C</title><link>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</link><pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</guid><description>&lt;p>In this post, we will delve into the mechanics of heapsort by building a tree-based heap data structure and then methodically extracting a sorted array.
We will then implement said algorithm in both Java and C to get a feel for how the process is modelled in code.&lt;/p></description></item><item><title>Experimenting with the XOR Swap Method in Java</title><link>https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/</link><pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/</guid><description>&lt;p>The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable.
Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length &lt;a href="http://en.wikipedia.org/wiki/Bit_array" rel="external noopener" target="_blank">bit-strings&lt;/a> will work.
Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to &lt;a href="http://en.wikipedia.org/wiki/High-level_programming_language" rel="external noopener" target="_blank">higher-level&lt;/a> programmers.
Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes.
An example of such an abstraction is the &lt;a href="http://javabook.compuware.com/content/memory/how-garbage-collection-works.aspx" rel="external noopener" target="_blank">garbage collector&lt;/a> found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention.&lt;/p></description></item><item><title>Least Significant Digit (LSD) Radix Sort in Java</title><link>https://eddmann.com/posts/least-significant-digit-lsd-radix-sort-in-java/</link><pubDate>Sat, 28 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/least-significant-digit-lsd-radix-sort-in-java/</guid><description>&lt;p>Radix sort is an O(digits·keys) sorting algorithm that relies on grouping integer keys to efficiently process and naturally order the specified dataset.
Based on structure and positional notation, many other data types that can be represented in integer form (e.g. ASCII characters) can benefit from the algorithm.
Sorting occurs by comparing digits in the same position of the items.
Two alternative versions of the algorithm exist, each tackling the problem from the opposite direction.
In this post, I will describe an iterative least significant digit implementation which, as the name suggests, begins processing from the right-most digit position.
This implementation results in a &lt;a href="http://en.wikipedia.org/wiki/Stable_sort#Stability" rel="external noopener" target="_blank">stable&lt;/a> sort, whereas the other implementation, which tackles the most significant digit first, cannot guarantee stability.
In a stable sorting algorithm, the initial ordering of equal keys remains unchanged in the result.&lt;/p></description></item><item><title>Shunting Yard Implementation in Java</title><link>https://eddmann.com/posts/shunting-yard-implementation-in-java/</link><pubDate>Mon, 23 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/shunting-yard-implementation-in-java/</guid><description>&lt;p>The Shunting Yard algorithm was developed by the great &lt;a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra" rel="external noopener" target="_blank">Edsger Dijkstra&lt;/a> as a means to parse an infix mathematical expression into Reverse Polish notation (postfix).
Using this notation allows the computer to evaluate the expression in a simple stack-based form, &lt;a href="https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/">examples&lt;/a> of which I have shown in Scala previously.
The algorithm itself also uses a stack along with a built-up output string to create the resulting value.
Below is an example implementation which only takes into consideration brackets and the four common operator precedences.
Although it is possible to evaluate more, including functions and associativity, I decided to keep the implementation simple to better highlight the process.&lt;/p></description></item><item><title>Decimal to Hexadecimal using Bitwise, Bit Shift Operations in Java</title><link>https://eddmann.com/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/</link><pubDate>Wed, 18 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/</guid><description>&lt;p>I recently wanted to create a simple function in JavaScript which allowed me to generate a random background colour for a small &lt;a href="http://workshop.eddmann.com/copacabana/" rel="external noopener" target="_blank">experiment&lt;/a> I was working on.
The implementation I came up with worked very well, but the decimal-hexadecimal representation conversion was all wrapped up in one &lt;code>toString(16)&lt;/code> function call.
I was very interested in creating this method myself, and I decided to use the Java language for the attempt.
The discussed functionality is already present in the Java language, within the &lt;code>java.lang.Integer&lt;/code> class, as &lt;code>toHexString&lt;/code>.&lt;/p></description></item><item><title>Reverse Polish Notation (RPN) in Scala</title><link>https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/</link><pubDate>Sun, 15 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/</guid><description>&lt;p>Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical &lt;a href="http://en.wikipedia.org/wiki/Reverse_Polish_Notation" rel="external noopener" target="_blank">Reverse Polish notation&lt;/a> string.
Popularised by its use in the &lt;a href="http://en.wikipedia.org/wiki/HP-10C_series" rel="external noopener" target="_blank">HP-10C&lt;/a> series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation).&lt;/p></description></item><item><title>Solving the k-combinations problem in Scala</title><link>https://eddmann.com/posts/solving-the-k-combinations-problem-in-scala/</link><pubDate>Tue, 03 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/solving-the-k-combinations-problem-in-scala/</guid><description>&lt;p>More often than not there are many different ways to solve a particular task.
I encountered this trait when coding a solution to the k-combinations (N-choose-k) problem.
A &lt;a href="http://en.wikipedia.org/wiki/Combination" rel="external noopener" target="_blank">combination&lt;/a> is the action of selecting a set number of elements from a larger group, where order is not considered (unlike a &lt;a href="http://en.wikipedia.org/wiki/Permutation" rel="external noopener" target="_blank">permutation&lt;/a>).
An example of a combination is in the cards you are dealt in a poker hand - from the possible 52 cards, you are dealt 5 (52 choose 5).
We can calculate the unique hand offerings in many different ways, allowing us to predict how likely it is for an individual card to be dealt.
In this post, I will show examples of solving the 10 choose 2 problem.&lt;/p></description></item><item><title>Merge sort in Scala using Tail-recursion and Streams</title><link>https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/</link><pubDate>Sun, 01 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/</guid><description>&lt;p>In a previous &lt;a href="https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/">post&lt;/a> I made a rudimentary comparison of Java and Scala using the &lt;a href="http://en.wikipedia.org/wiki/Merge_sort" rel="external noopener" target="_blank">Merge sort&lt;/a> algorithm as a case study.
There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list.
In this post I wish to describe two very different implementations that resolve this glaring omission.&lt;/p></description></item><item><title>Merge sort comparison in Java and Scala</title><link>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</guid><description>&lt;p>Having only just recently got a complete shot of functional goodness in the form of the &lt;a href="http://www.coursera.org/course/progfun" rel="external noopener" target="_blank">Functional Programming Principles in Scala&lt;/a> &lt;a href="http://en.wikipedia.org/wiki/Massive_open_online_course" rel="external noopener" target="_blank">MOOC&lt;/a>, my imperative standing is in a state of confusion.
Is mutability the devil, should every function not have side-effects, what really is a monad?
Okay, so I may be joking a little with these semi-rhetorical remarks - boy, have I read enough monad posts for a lifetime.
Added to the mainstream application design consensus, the functional paradigm is making inroads out of multi-core necessity (goodbye &lt;a href="http://en.wikipedia.org/wiki/Moore%27s_law" rel="external noopener" target="_blank">Moore&amp;rsquo;s law&lt;/a>).&lt;/p></description></item></channel></rss>