<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>AVL Trees in Clojure - Edd Mann</title>
<meta name=description content="Learn how to implement a self-balancing AVL binary search tree in Clojure, ensuring optimal search performance through automatic rebalancing."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="AVL Trees in Clojure"><meta itemprop=description content="An AVL tree is a self-balancing binary search tree, whereby the height of a node’s children differs by at most one. In the event that this property is violated, a rebalancing process takes place."><meta itemprop=datePublished content="2016-09-03T00:00:00+00:00"><meta itemprop=dateModified content="2016-09-03T00:00:00+00:00"><meta itemprop=wordCount content="549"><meta itemprop=keywords content="Clojure,Data-Structures,Functional-Programming"><meta property="og:url" content="https://eddmann.com/posts/avl-trees-in-clojure/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="AVL Trees in Clojure"><meta property="og:description" content="An AVL tree is a self-balancing binary search tree, whereby the height of a node’s children differs by at most one. In the event that this property is violated, a rebalancing process takes place."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-09-03T00:00:00+00:00"><meta property="article:modified_time" content="2016-09-03T00:00:00+00:00"><meta property="article:tag" content="Clojure"><meta property="article:tag" content="Data-Structures"><meta property="article:tag" content="Functional-Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="AVL Trees in Clojure"><meta name=twitter:description content="An AVL tree is a self-balancing binary search tree, whereby the height of a node’s children differs by at most one. In the event that this property is violated, a rebalancing process takes place."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6c18b9cbfe138a24784e64860eaa9d70076170f03c68d8be3b3f1ae99e51df9f.css integrity="sha256-bBi5y/4TiiR4TmSGDqqdcAdhcPA8aNi+Oz8a6Z5R358="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x3x.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/avl-trees-in-clojure/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>AVL Trees in Clojure</h1><time class=post__time>Sep 3, 2016</time></header><main class=prose><p>An AVL tree is a self-balancing binary search tree, whereby the height of a node&rsquo;s children differs by at most one.
In the event that this property is violated, a rebalancing process takes place.</p><p>In the past, I have discussed how to implement a <a href=/posts/binary-search-trees-in-clojure/>Binary Search Tree in Clojure</a>, providing an average time complexity of O(log n).
However, if the order of insertion is sequential (where each value is either greater than or less than the last), time complexity increases to be linear, the same as a linked list.
Self-balancing trees, such as the AVL variant, provide us with a worst-case complexity of O(log n), thanks to their rebalancing phase.</p><h2 id=balance-factor>Balance Factor</h2><p>Using the previous Binary Search Tree implementation as a base, we can expand upon this to include the AVL property.
For the sake of performance, you would typically store the height of each node&rsquo;s children within the structure.
However, as I wish to reuse the existing implementation, I will instead calculate their height upon <code>factor</code> invocation.
The balance factor of a node is calculated as the difference between the heights of its two child nodes, as shown below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>height
</span></span><span style=display:flex><span>  ([tree] (<span style=color:#a6e22e>height</span> tree <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  ([tree count]
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>tree
</span></span><span style=display:flex><span>      (max (<span style=color:#a6e22e>height</span> (<span style=color:#e6db74>:left</span> tree) (inc count))
</span></span><span style=display:flex><span>           (<span style=color:#a6e22e>height</span> (<span style=color:#e6db74>:right</span> tree) (inc count)))
</span></span><span style=display:flex><span>      count)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>factor [{<span style=color:#e6db74>:keys</span> [left right]}]
</span></span><span style=display:flex><span>  (- (<span style=color:#a6e22e>height</span> left) (<span style=color:#a6e22e>height</span> right)))
</span></span></code></pre></div><p>The above two functions provide the described behaviour, allowing us to supply a root node and return its balance factor.</p><h2 id=rotations>Rotations</h2><p>To complete the final rebalancing step, we must also be able to rotate a given node both left and right within the tree structure.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>rotate-left [{<span style=color:#e6db74>:keys</span> [el left right] <span style=color:#e6db74>:as</span> tree}]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>right
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>-&gt;Node</span> (<span style=color:#e6db74>:el</span> right) (<span style=color:#a6e22e>-&gt;Node</span> el left (<span style=color:#e6db74>:left</span> right)) (<span style=color:#e6db74>:right</span> right))
</span></span><span style=display:flex><span>    tree))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>rotate-right [{<span style=color:#e6db74>:keys</span> [el left right] <span style=color:#e6db74>:as</span> tree}]
</span></span><span style=display:flex><span>  (<span style=color:#66d9ef>if </span>left
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>-&gt;Node</span> (<span style=color:#e6db74>:el</span> left) (<span style=color:#e6db74>:left</span> left) (<span style=color:#a6e22e>-&gt;Node</span> el (<span style=color:#e6db74>:right</span> left) right))
</span></span><span style=display:flex><span>    tree))
</span></span></code></pre></div><p>This can be achieved as shown above, taking advantage of an immutable approach.</p><h2 id=rebalancing-phase>Rebalancing Phase</h2><p>With the balance factor and rotation actions now available, we can begin working on the four different situations where a node&rsquo;s placement requires a tree rotation.</p><p><picture><source type=image/webp srcset=/posts/avl-trees-in-clojure/lr-ll-cases_hu_d8209723b614aedd.webp><source type=image/jpeg srcset=/posts/avl-trees-in-clojure/lr-ll-cases_hu_9d9247184a1cc1e9.jpg><img src=/posts/avl-trees-in-clojure/lr-ll-cases_hu_9d9247184a1cc1e9.jpg alt="Left Right, Left Left Cases" loading=lazy></picture></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>is-left-case? [tree]
</span></span><span style=display:flex><span>  (&lt; (<span style=color:#a6e22e>factor</span> tree) <span style=color:#ae81ff>-1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>is-left-right-case? [tree]
</span></span><span style=display:flex><span>  (and (<span style=color:#a6e22e>is-left-case?</span> tree) (&gt; (<span style=color:#a6e22e>factor</span> (<span style=color:#e6db74>:right</span> tree)) <span style=color:#ae81ff>0</span>)))
</span></span></code></pre></div><p><picture><source type=image/webp srcset=/posts/avl-trees-in-clojure/rl-rr-cases_hu_9ea6fe6121da104e.webp><source type=image/jpeg srcset=/posts/avl-trees-in-clojure/rl-rr-cases_hu_7812d1c3ac1bd979.jpg><img src=/posts/avl-trees-in-clojure/rl-rr-cases_hu_7812d1c3ac1bd979.jpg alt="Right Left, Right Right Cases" loading=lazy></picture></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>is-right-case? [tree]
</span></span><span style=display:flex><span>  (&gt; (<span style=color:#a6e22e>factor</span> tree) <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>is-right-left-case? [tree]
</span></span><span style=display:flex><span>  (and (<span style=color:#a6e22e>is-right-case?</span> tree) (&lt; (<span style=color:#a6e22e>factor</span> (<span style=color:#e6db74>:left</span> tree)) <span style=color:#ae81ff>0</span>)))
</span></span></code></pre></div><p>With these conditions now identifiable, we can apply the desired tree rotations, as visualised in the diagrams above.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>balance [{<span style=color:#e6db74>:keys</span> [el left right] <span style=color:#e6db74>:as</span> tree}]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>cond</span>
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>is-right-left-case?</span> tree) (<span style=color:#a6e22e>rotate-right</span> (<span style=color:#a6e22e>-&gt;Node</span> el (<span style=color:#a6e22e>rotate-left</span> left) right))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>is-left-right-case?</span> tree) (<span style=color:#a6e22e>rotate-left</span> (<span style=color:#a6e22e>-&gt;Node</span> el left (<span style=color:#a6e22e>rotate-right</span> right)))
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>is-right-case?</span> tree) (<span style=color:#a6e22e>rotate-right</span> tree)
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>is-left-case?</span> tree) (<span style=color:#a6e22e>rotate-left</span> tree)
</span></span><span style=display:flex><span>    <span style=color:#e6db74>:else</span> tree))
</span></span></code></pre></div><h2 id=example-usage>Example Usage</h2><p>Finally, we can create new AVL insertion and deletion variants by composing the Binary Search Tree functions with the newly created <code>balance</code> function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>def </span>avl-insert (comp balance insert))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>def </span>avl-remove (comp balance remove))
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>def </span>seq-&gt;avl (partial reduce avl-insert nil))
</span></span></code></pre></div><p>These data structures can then be visualised using the following function.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>tabs [n]
</span></span><span style=display:flex><span>  (<span style=color:#a6e22e>clojure.string/join</span> (repeat n <span style=color:#e6db74>&#34;\t&#34;</span>)))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>visualise
</span></span><span style=display:flex><span>  ([tree] (<span style=color:#a6e22e>visualise</span> tree <span style=color:#ae81ff>0</span>))
</span></span><span style=display:flex><span>  ([{<span style=color:#e6db74>:keys</span> [el left right] <span style=color:#e6db74>:as</span> tree} depth]
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>if </span>tree
</span></span><span style=display:flex><span>      (str (<span style=color:#a6e22e>visualise</span> right (inc depth)) (<span style=color:#a6e22e>tabs</span> depth) el <span style=color:#e6db74>&#34;\n&#34;</span> (<span style=color:#a6e22e>visualise</span> left (inc depth)))
</span></span><span style=display:flex><span>      (str (<span style=color:#a6e22e>tabs</span> depth) <span style=color:#e6db74>&#34;~\n&#34;</span>))))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(<span style=color:#a6e22e>visualise</span> (<span style=color:#a6e22e>seq-&gt;avl</span> [<span style=color:#ae81ff>1</span> <span style=color:#ae81ff>2</span> <span style=color:#ae81ff>3</span>]))
</span></span><span style=display:flex><span><span style=color:#75715e>;              ~</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;       3</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;              ~</span>
</span></span><span style=display:flex><span><span style=color:#75715e>; 2</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;              ~</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;       1</span>
</span></span><span style=display:flex><span><span style=color:#75715e>;              ~</span>
</span></span></code></pre></div></main><footer class=post__tags><a href=/archive/tag/clojure>clojure</a><a href=/archive/tag/data-structures>data-structures</a><a href=/archive/tag/functional-programming>functional-programming</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>