<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="This series of articles documents my experience rewriting the santa-lang interpreter in Rust. In this article, I delve into how I integrated the core language library with the desired (delivery) runtimes.">

    <title>
        
            Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Rewriting the santa-lang Interpreter in Rust, Part 2 - Runtimes</h1>
    <time datetime="2023-08-06T00:00:00+00:00" class="post-date">06 Aug 2023</time>
    <p>With the <a href="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-1-implementing-the-core/">core language library</a> now written, I could go about building the desired (delivery) runtimes.
In this article within the series, I will delve into my experience integrating the core language library with these chosen runtimes, documenting some of the challenges that I faced along the way.</p>



<p>The TypeScript implementation of the santa-lang interpreter included CLI, Web, and Lambda runtimes.
I decided to tackle these in this order of importance, as I required at least the CLI to begin testing the interpreter on real solutions.</p>

<h2 id="cli">CLI</h2>

<p>I intentionally decided to write the CLI with minimal package dependencies.
There are many useful <a href="https://github.com/clap-rs/clap">crates</a> available to assist in CLI development, but I did not feel like I needed the additional features they provided at this time.
I did, however, use a <a href="https://github.com/kkawakam/rustyline">crate</a> to provide the ability to start up an interactive shell via <em>readline</em> support.
The runtime itself included I/O <em>external functions</em> <code class="language-plaintext highlighter-rouge">puts</code> and <code class="language-plaintext highlighter-rouge">read</code>, which had feature parity with the TypeScript implementation.
This included POSIX support for reading files from disk, fetching contents from HTTP endpoints, and the AoC schema I had devised when first designing santa-lang.
I was able to provide test coverage for this delivery using the <a href="https://docs.rs/assert_cmd/latest/assert_cmd/">assert_cmd</a> crate.
This provided me with confidence that I had correctly integrated the library with the delivery.</p>

<div style="display:flex;gap:0.5rem;align-items:center;flex-direction:row;">
  <div>
    <img src="/uploads/rewriting-the-santa-lang-interpreter-in-rust/cli-runner.png" alt="CLI Runner" />
  </div>
  <div>
    <img src="/uploads/rewriting-the-santa-lang-interpreter-in-rust/cli-repl.png" alt="CLI REPL" />
  </div>
</div>

<p>To aid in performance benchmarking, I added the ability to compile the runtime with <a href="https://github.com/tikv/pprof-rs">pprof</a> code profiling (via a <a href="https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/cli/Cargo.toml#L26"><code class="language-plaintext highlighter-rouge">profile</code></a> feature flag).
The chosen library also allowed me to produce <a href="https://www.brendangregg.com/flamegraphs.html">flame graphs</a>, which were used extensively throughout development to help pinpoint areas where performance could be improved.
Further discussion on performance will be documented in the <a href="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/">next article</a> within the series.</p>

<h2 id="web-wasm">Web (WASM)</h2>

<p>The TypeScript interpreter being transpiled into JavaScript made it already well-suited for <em>Web platform</em> usage.
This required very little additional effort on my part.
To provide use of this interpreter within the <a href="https://eddmann.com/santa-lang-editor/">Web-based code editor</a> and Browsers/Node in general, I needed to leverage WebAssembly (WASM).
Having had <a href="https://eddmann.com/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/">experience</a> with this before, I was again surprised at how easy it was to achieve.
Not only was I able to trivially expose the language as a WASM library, but I could also provide the ability to include user-land JavaScript functions as external functions (similar to the TypeScript implementation), as shown below:</p>

<div class="language-ts highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">evaluate</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">'</span><span class="s1">@eddmann/santa-lang-wasm</span><span class="dl">'</span><span class="p">;</span>

<span class="nx">evaluate</span><span class="p">(</span><span class="dl">'</span><span class="s1">[1, 2, 3] |&gt; map(_ + 1) |&gt; sum</span><span class="dl">'</span><span class="p">);</span>

<span class="nx">evaluate</span><span class="p">(</span><span class="dl">'</span><span class="s1">puts("Hello, world")</span><span class="dl">'</span><span class="p">,</span> <span class="p">{</span> <span class="na">puts</span><span class="p">:</span> <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">.</span><span class="nx">bind</span><span class="p">(</span><span class="nx">console</span><span class="p">)</span> <span class="p">});</span>
</code></pre></div></div>

<p>The runtime required me to enable the <a href="https://github.com/eddmann/santa-lang-rs/blob/d56cd6748111dc22f078a6eb554c80476342d033/lang/Cargo.toml#L18"><code class="language-plaintext highlighter-rouge">serde</code></a> feature support, which I had included within the core language library, to make it possible to represent compatible data structures between JavaScript and santa-lang.
Being enabled on a per-runtime basis ensured that any additional overheads would not impact other runtimes.
The Runner instance used the <a href="https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/wasm/src/lib.rs#L16-L21"><code class="language-plaintext highlighter-rouge">Time</code></a> trait with a specific WASM implementation to determine the execution time of solutions.
Similar to the CLI, I was able to garner confidence in the desired behaviour by using a <a href="https://crates.io/crates/wasm-bindgen-test">testing</a> crate, which allowed me to verify correctness of the compiled library within both Node and Chrome-browser environments.</p>

<p>With very <a href="https://github.com/eddmann/santa-lang-editor/blob/b27aeddc19444003cb5d39704d934e733e05bb86/worker.ts">few changes</a>, I was then able to update the <a href="https://eddmann.com/santa-lang-editor/">Web-based code editor</a> to use this new interpreter.
On top of this, I had begun <a href="https://eddmann.com/santa-lang/">documenting</a> the language specification and features it had to offer using <a href="https://www.mkdocs.org/">MkDocs</a>.
I decided to additionally add <a href="https://github.com/eddmann/santa-lang/blob/f55c6d085118bc9ae6a269e2f57ef415b57b96eb/runner/runner.js">executable examples</a> using this library, which exercised the runtime in a different context.</p>

<div style="max-width:500px;margin:0 auto;">
  <img src="/uploads/rewriting-the-santa-lang-interpreter-in-rust/web-editor.png" alt="Web Editor" />
</div>

<h2 id="lambda">Lambda</h2>

<p>I had initially developed the Lambda runtime in TypeScript for use within last year’s <a href="https://eddmann.com/posts/allocating-secret-santas-using-an-aws-step-function-workflow-and-every-available-lambda-runtime/">Secret Santa Allocation</a> project.
I wanted to provide feature parity and implement such a runtime in Rust.
To achieve this, I borrowed ideas from the <a href="https://github.com/eddmann/santa-lang-ts/blob/aa0a2a53d6dab80e844d4c87183a1f3936d1a7f5/src/lambda/src/index.ts">Node version</a>, conforming to the <a href="https://docs.aws.amazon.com/lambda/latest/dg/runtimes-api.html">Lambda runtime API</a> and expected request/response lifecycle.
I used the lightweight <a href="https://crates.io/crates/ureq/0.9.0">ureq</a> crate to handle HTTP transport between the compiled <em>bootstrap</em> and the Lambda runtime environment.
Due to Lambda’s heavy reliance on JSON for transport, I again enabled the <code class="language-plaintext highlighter-rouge">serde</code> feature support (similar to the WASM runtime) that had been added to the core language library to handle converting santa-lang data structures to and from their JSON equivalents.
I was pleasantly surprised at how performant this runtime was in practice, with very little overhead and a small binary size.</p>

<div style="max-width:500px;margin:0 auto;">
  <img src="/uploads/rewriting-the-santa-lang-interpreter-in-rust/lambda-runtime.png" alt="Lambda Runtime" />
</div>

<h2 id="php-extension">PHP extension</h2>

<p>One evening, I spotted an interesting <a href="https://github.com/davidcole1340/ext-php-rs">crate</a>, which provided an abstraction around creating PHP extensions within Rust.
As all I had been thinking about over the past several months was santa-lang, the first thing that came into my mind was: could I make a runtime for it?!
So, I set about creating a <a href="https://github.com/eddmann/santa-lang-rs/blob/870e364a9ae47c3648e358d89b42e491f9d59577/runtime/php-ext/src/lib.rs">simple extension</a> that provided user-land PHP with the ability to evaluate santa-lang code, along with AoC solutions.</p>

<p>I had <a href="https://eddmann.com/posts/introduction-to-creating-a-basic-php-extension/">limited</a> <a href="https://eddmann.com/posts/php-extension-development-for-beginners-with-joe-watkins/">experience</a> in writing PHP extensions in the past and really enjoyed how this crate abstracted away any need for C macros and <code class="language-plaintext highlighter-rouge">zend_</code> magic.
It was interesting constructing PHP associative arrays (Zend Hash Tables) for each of the exposed PHP functions’ return values.
This certainly isn’t the most useful runtime, but it does document how easy it is to expose Rust-based code in a higher-level language without needing to resort to C.</p>

<div class="language-php highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">&lt;?php</span>

<span class="nv">$solution</span> <span class="o">=</span> <span class="nb">file_get_contents</span><span class="p">(</span><span class="k">__DIR__</span> <span class="mf">.</span> <span class="s1">'/solution.santa'</span><span class="p">);</span>

<span class="nf">santa_aoc_run</span><span class="p">(</span><span class="nv">$solution</span><span class="p">,</span> <span class="n">cwd</span><span class="o">:</span> <span class="k">__DIR__</span><span class="p">);</span>

<span class="nf">santa_aoc_test</span><span class="p">(</span><span class="nv">$solution</span><span class="p">);</span>

<span class="nf">santa_evaluate</span><span class="p">(</span><span class="s1">'1.. |&gt; filter(_ % 2) |&gt; take(3);'</span><span class="p">);</span>
</code></pre></div></div>

<p>Along with providing this PHP extension support, there is future scope to expose the interpreter within <a href="https://github.com/PyO3/pyo3">Python</a>.
This crate looks to expose a similar level of abstraction as the PHP one.</p>

<h2 id="jupyter-kernel">Jupyter Kernel</h2>

<p>Over the past several months, I have been introduced to the power of <a href="https://jupyter.org/">Jupyter Notebook</a> and the fast REPL it provides.
This is in large part due to every AI/LLM YouTube video or article I see using it (due to the authors coming from Data Science backgrounds).
Similar to the PHP extension, my mind wandered into the possibility of creating a custom <a href="https://docs.jupyter.org/en/latest/projects/kernels.html">Kernel</a> to expose the santa-lang language as an additional runtime.</p>

<p>Thanks to yet another well-thought-out <a href="https://crates.io/crates/jupyter">crate</a>, this task proved to be rather seamless.
There was one caveat, however, in that the crate used asynchronous execution to handle language server requests.
This caused issues with the <code class="language-plaintext highlighter-rouge">Rc&lt;RefCell&lt;Environment&gt;&gt;</code> type that is required to model script state during evaluation.
As santa-lang’s core language is designed to be single-threaded, I was required to add <em>unsafe</em> <code class="language-plaintext highlighter-rouge">Sendable</code> and <code class="language-plaintext highlighter-rouge">Sync</code> trait implementations to a wrapper <a href="https://github.com/eddmann/santa-lang-rs/blob/a36476d3d7adcc68980b56465c5c0ee891c831db/runtime/jupyter/src/main.rs#L14-L17"><code class="language-plaintext highlighter-rouge">SharedEnvironment</code></a> type to appease the compiler (a big no-no!).</p>

<p>This is certainly not production-ready, but as a proof of concept, it was fun to build.
It also make me interested to see how I could possibly use a notebook to help develop Advent of Code solutions in the future.</p>

<div style="max-width:500px;margin:0 auto;">
  <img src="/uploads/rewriting-the-santa-lang-interpreter-in-rust/jupyter-kernel.png" alt="Jupyter Kernel" />
</div>

<h2 id="whats-next">What’s next?</h2>

<p>Now that all the desired runtimes have been implemented, it is finally time to investigate performance considerations!
In the <a href="https://eddmann.com/posts/rewriting-the-santa-lang-interpreter-in-rust-part-3-performance/">next post</a>, I will document how I went about benchmarking the two implementations, greatly improving performance, and highlighting interesting findings along the way.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
