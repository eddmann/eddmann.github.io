<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Building an Enigma Machine in Haskell - Edd Mann</title>
<meta name=description content="Explore the intricacies of creating an Enigma Machine in Haskell, utilising property-based testing to ensure correctness and robustness."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Building an Enigma Machine in Haskell"><meta itemprop=description content="Following on from my previous post which highlighted my experience building an Enigma Machine in ClojureScript. I decided it would be interesting to model the machine within Haskell. I felt solving the same problem in this manner would be a great way to compare and contrast Lisp and heavily-typed languages such as Haskell. Through this process I also wanted to explore using Hspec and QuickCheck for comparable property-based testing that I achieved in the ClojureScript counterpart."><meta itemprop=datePublished content="2020-11-27T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-27T00:00:00+00:00"><meta itemprop=wordCount content="1970"><meta itemprop=keywords content="Enigma-Machine,Haskell,Property-Testing"><meta property="og:url" content="https://eddmann.com/posts/building-an-enigma-machine-in-haskell/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Building an Enigma Machine in Haskell"><meta property="og:description" content="Following on from my previous post which highlighted my experience building an Enigma Machine in ClojureScript. I decided it would be interesting to model the machine within Haskell. I felt solving the same problem in this manner would be a great way to compare and contrast Lisp and heavily-typed languages such as Haskell. Through this process I also wanted to explore using Hspec and QuickCheck for comparable property-based testing that I achieved in the ClojureScript counterpart."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2020-11-27T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-27T00:00:00+00:00"><meta property="article:tag" content="Enigma-Machine"><meta property="article:tag" content="Haskell"><meta property="article:tag" content="Property-Testing"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building an Enigma Machine in Haskell"><meta name=twitter:description content="Following on from my previous post which highlighted my experience building an Enigma Machine in ClojureScript. I decided it would be interesting to model the machine within Haskell. I felt solving the same problem in this manner would be a great way to compare and contrast Lisp and heavily-typed languages such as Haskell. Through this process I also wanted to explore using Hspec and QuickCheck for comparable property-based testing that I achieved in the ClojureScript counterpart."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.c3ee6cab58dd3fee7e6960b0391e996ba9254804702bc60a52ec5e0e3591a018.css integrity="sha256-w+5sq1jdP+5+aWCwOR6Za6klSARwK8YKUuxeDjWRoBg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/building-an-enigma-machine-in-haskell/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.250e7cf850e958b4272ae208ba50192c2c96e26ebb656d272683894c80f86f20.js integrity="sha256-JQ58+FDpWLQnKuIIulAZLCyW4m67ZW0nJoOJTID4byA=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:building-an-enigma-machine-in-haskell>Building an Enigma Machine in Haskell</h1><time datetime=2020-11-27T00:00:00Z class=published-at>Nov 27, 2020</time></header><main class=u-prose><p>Following on from my previous post which highlighted my experience building an <a href=/posts/building-an-enigma-machine-in-clojurescript/>Enigma Machine in ClojureScript</a>.
I decided it would be interesting to model the machine within Haskell.
I felt solving the same problem in this manner would be a great way to compare and contrast Lisp and heavily-typed languages such as Haskell.
Through this process I also wanted to explore using Hspec and QuickCheck for comparable property-based testing that I achieved in the ClojureScript counterpart.</p><p>You can experiment with the final implementation by pulling down the <a href=https://github.com/eddmann/enigma-machine-haskell rel="external noopener" target=_blank>GitHub repository</a> and using the provided Makefile <code>encode</code> Makefile target.
We leverage Docker to containerise the Haskell development/testing requirements when being run locally and during CI.</p><p><a href=https://github.com/eddmann/enigma-machine-haskell rel="external noopener" target=_blank><picture><source type=image/webp srcset="/posts/building-an-enigma-machine-in-haskell/demo_hu_da046054a39b251.webp 350w, /posts/building-an-enigma-machine-in-haskell/demo_hu_644667cd0ae15ec6.webp 700w, /posts/building-an-enigma-machine-in-haskell/demo_hu_64161dc8eac82e6e.webp 1240w"><source type=image/jpeg srcset="/posts/building-an-enigma-machine-in-haskell/demo_hu_cf8dbed6c310216c.jpg 350w, /posts/building-an-enigma-machine-in-haskell/demo_hu_bad04c57eb1b039c.jpg 700w, /posts/building-an-enigma-machine-in-haskell/demo_hu_1c997690d8b7e511.jpg 1240w"><img src=/posts/building-an-enigma-machine-in-haskell/demo_hu_bad04c57eb1b039c.jpg alt="Command-line based Enigma Machine in Haskell" loading=lazy></picture></a></p><h2 id=how-it-works>How it works</h2><p>I spent some time within the previous ClojureScript implementation discussing the purpose and inner-workings of the Enigma Machine.
So as to not simply repeat myself here I ask that you refer to <a href=/posts/building-an-enigma-machine-in-clojurescript/#how-it-works>this section</a> for a basic understanding of the machine behaviour we will be modelling.</p><p><picture><source type=image/webp srcset="/posts/building-an-enigma-machine-in-haskell/enigma-machine_hu_d882fb761fe26b3c.webp 350w, /posts/building-an-enigma-machine-in-haskell/enigma-machine_hu_b8b11b8cecfb9d63.webp 620w"><source type=image/jpeg srcset="/posts/building-an-enigma-machine-in-haskell/enigma-machine_hu_bc362b768591a9e1.jpg 350w, /posts/building-an-enigma-machine-in-haskell/enigma-machine_hu_4e6a460443552a3b.jpg 620w"><img src=/posts/building-an-enigma-machine-in-haskell/enigma-machine_hu_4e6a460443552a3b.jpg alt="Enigma Machine" loading=lazy></picture></p><h2 id=the-machine>The Machine</h2><p>In a similar fashion to how we tackled the previous implementation, the first element of the machine that we will model are the Rotors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>alphabet</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Char</span>]
</span></span><span style=display:flex><span><span style=color:#a6e22e>alphabet</span> <span style=color:#f92672>=</span> [<span style=color:#e6db74>&#39;A&#39;</span><span style=color:#f92672>..</span><span style=color:#e6db74>&#39;Z&#39;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>data</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> { _out <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>, _in <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span>, _step <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span> }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>deriving</span> (<span style=color:#66d9ef>Show</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>=</span> (<span style=color:#66d9ef>Rotor</span>, <span style=color:#66d9ef>Rotor</span>, <span style=color:#66d9ef>Rotor</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorI</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorI</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#e6db74>&#34;EKMFLGDQVZNTOWYHXUSPAIBRCJ&#34;</span> alphabet <span style=color:#e6db74>&#39;Q&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorII</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorII</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#e6db74>&#34;AJDKSIRUXBLHWTMCQGZNPYFVOE&#34;</span> alphabet <span style=color:#e6db74>&#39;E&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorIII</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotorIII</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#e6db74>&#34;BDFHJLCPRTXVZNYEIWGAKMUSQO&#34;</span> alphabet <span style=color:#e6db74>&#39;V&#39;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>isStep</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Bool</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>isStep</span> rotor <span style=color:#f92672>=</span> _step rotor <span style=color:#f92672>==</span> head (_in rotor)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotate</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotate</span> (<span style=color:#66d9ef>Rotor</span> _out _in _step) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> (tail _out <span style=color:#f92672>++</span> [head _out]) (tail _in <span style=color:#f92672>++</span> [head _in]) _step
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotateAll</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Rotors</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>rotateAll</span> (a, b, c) <span style=color:#f92672>=</span> (rotate a, <span style=color:#66d9ef>if</span> isStep a <span style=color:#f92672>||</span> isStep b <span style=color:#66d9ef>then</span> rotate b <span style=color:#66d9ef>else</span> b, <span style=color:#66d9ef>if</span> isStep b <span style=color:#66d9ef>then</span> rotate c <span style=color:#66d9ef>else</span> c)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>passthrough</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>passthrough</span> rotor letter <span style=color:#f92672>=</span> maybe <span style=color:#e6db74>&#39;?&#39;</span> id (lookup letter in&#39; <span style=color:#f92672>&gt;&gt;=</span> (flip lookup) out&#39;)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> in&#39; <span style=color:#f92672>=</span> zip alphabet (_out rotor)
</span></span><span style=display:flex><span>          out&#39; <span style=color:#f92672>=</span> zip (_in rotor) alphabet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>passthroughAll</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>passthroughAll</span> (a, b, c) letter <span style=color:#f92672>=</span> passthrough c <span style=color:#f92672>.</span> passthrough b <span style=color:#f92672>.</span> passthrough a <span style=color:#f92672>$</span> letter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>invert</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotor</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>invert</span> (<span style=color:#66d9ef>Rotor</span> _out _in _step) <span style=color:#f92672>=</span> <span style=color:#66d9ef>Rotor</span> _in _out _step
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>invertedPassthroughAll</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>invertedPassthroughAll</span> (a, b, c) letter <span style=color:#f92672>=</span> passthrough (invert a) <span style=color:#f92672>.</span> passthrough (invert b) <span style=color:#f92672>.</span> passthrough (invert c) <span style=color:#f92672>$</span> letter
</span></span></code></pre></div><p>Based on the code above we first create a new <em>data type</em> which will represent a given Rotor - along with an aggregate tuple which represents the collection of Rotors.
This leads us to providing the behaviour necessary to rotate the Rotor collection based on each given rotor&rsquo;s position and step.
Finally, we provide a means of passing a given letter through (and back-through) the Rotors, performing the substitution encryption (scrambled wiring) along the way.</p><p>From here, we will now model the Reflector, which is used to complete the circuit and send the current (letter) back through the Rotors.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Reflector</span> <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>Char</span>, <span style=color:#66d9ef>Char</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorA</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorA</span> <span style=color:#f92672>=</span> zip alphabet <span style=color:#e6db74>&#34;EJMZALYXVBWFCRQUONTSPIKHGD&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorB</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorB</span> <span style=color:#f92672>=</span> zip alphabet <span style=color:#e6db74>&#34;YRUHQSLDPXNGOKMIEBFZCWVJAT&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorC</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflectorC</span> <span style=color:#f92672>=</span> zip alphabet <span style=color:#e6db74>&#34;FVPJIAOYEDRZXWGCTKUQSBNMHL&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflect</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Reflector</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>reflect</span> reflector letter <span style=color:#f92672>=</span> maybe <span style=color:#e6db74>&#39;?&#39;</span> id <span style=color:#f92672>$</span> lookup letter reflector
</span></span></code></pre></div><p>Being a static substitution system, the Reflector is trivial to model - however, we do cater for the possibility of a value not being present in the <code>lookup</code> invocation via unwrapping the <em>Maybe</em> and returning a <code>?</code> instead.
This should not occur in practice, but to date I have not been able to find a means of adding the sufficient type-level constraints required to ensure that only <code>Char</code> values present in the <code>alphabet</code> listing should be consumed/returned.</p><p>This leads us on to modelling the Plugboard, which uses the <code>lookup</code> Haskell function again to see if a translation (plug) for the given letter has been provided.
If this is not the case when unwrapping the <em>Maybe</em> monadic structure, the provided letter itself (by way of the <code>id</code> function) is returned instead.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#66d9ef>type</span> <span style=color:#66d9ef>Plugboard</span> <span style=color:#f92672>=</span> [(<span style=color:#66d9ef>Char</span>, <span style=color:#66d9ef>Char</span>)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>plug</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Plugboard</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>plug</span> plugboard letter <span style=color:#f92672>=</span> maybe letter id <span style=color:#f92672>$</span> lookup letter plugboard&#39;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> plugboard&#39; <span style=color:#f92672>=</span> (plugboard <span style=color:#f92672>++</span> map swap plugboard)
</span></span></code></pre></div><p>With all the building blocks now in place we can begin to compose them together to handle encoding a given message through the machine.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>encode</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Reflector</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Plugboard</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Char</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>encode</span> rotors reflector plugboard letter <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    plug plugboard <span style=color:#f92672>.</span> invertedPassthroughAll rotors <span style=color:#f92672>.</span> reflect reflector <span style=color:#f92672>.</span> passthroughAll rotors <span style=color:#f92672>.</span> plug plugboard <span style=color:#f92672>$</span> letter
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>encodeMessage</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Rotors</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Reflector</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Plugboard</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>encodeMessage</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#66d9ef>_</span> <span style=color:#e6db74>&#34;&#34;</span> <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>encodeMessage</span> rotors reflector plugboard (letter <span style=color:#66d9ef>:</span> letters) <span style=color:#f92672>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>let</span> rotated <span style=color:#f92672>=</span> rotateAll rotors <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>        encode rotated reflector plugboard letter <span style=color:#66d9ef>:</span> encodeMessage rotated reflector plugboard letters
</span></span></code></pre></div><p>Above we have opted to break the problem up into a recursive <code>encodeMessage</code> function which uses an internal <code>encode</code> function to provide threading the letter through the currently configured machine.
Unlike Clojure, we do not have a means to express &rsquo;threading&rsquo; the letter through a list of functions defined left-to-right.
Instead, we have to compose the functions together reading the function right-to-left.
It would be nice to be able to provide some syntactic sugar around this use-case - as when you have big composition chains such as this, it is a lot more understandable to read left-to-right (regardless of how the call stack is going to be built internally).</p><h2 id=testing>Testing</h2><p>With the machine behaviour now modelled in code, we can move on to asserting its correctness.
In a similar fashion to how we tested the ClojureScript implementation, I have opted to explore testing using static example-based test cases, along with random examples which ensure desired properties of the machine hold true.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>genReflector</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Gen</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genReflector</span> <span style=color:#f92672>=</span> elements [reflectorA, reflectorB, reflectorB]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genRotor</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Gen</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genRotor</span> <span style=color:#f92672>=</span> elements [rotorI, rotorII, rotorIII]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genRotors</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Gen</span> <span style=color:#66d9ef>Rotors</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genRotors</span> <span style=color:#f92672>=</span> liftM3 (,,) genRotor genRotor genRotor
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>plugboard</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>Char</span>] <span style=color:#f92672>-&gt;</span> [(<span style=color:#66d9ef>Char</span>, <span style=color:#66d9ef>Char</span>)]
</span></span><span style=display:flex><span><span style=color:#a6e22e>plugboard</span> zs <span style=color:#f92672>=</span> zip xs ys
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>where</span> (xs, ys) <span style=color:#f92672>=</span> splitAt ((length zs <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>) `div` <span style=color:#ae81ff>2</span>) zs
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genPlugboard</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Gen</span> <span style=color:#66d9ef>Plugboard</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genPlugboard</span> <span style=color:#f92672>=</span> fmap plugboard <span style=color:#f92672>$</span> shuffle alphabet
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genMessage</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Gen</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>genMessage</span> <span style=color:#f92672>=</span> listOf <span style=color:#f92672>$</span> elements alphabet
</span></span></code></pre></div><p>Using <a href=https://hackage.haskell.org/package/QuickCheck rel="external noopener" target=_blank>QuickCheck</a>, we are able to succinctly provide a means of defining how a valid machine configuration and message input should be constructed.
One omission to this implementation that should be highlighted is that we do not provide the operator with the ability to specify the Rotor starting positions.
This can be trivially added, but I decided that in the interest of code-sample clarity I would leave this as an exercise for the reader to implement if they so wish.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span> hspec <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    describe <span style=color:#e6db74>&#34;Machine&#34;</span> <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>        it <span style=color:#e6db74>&#34;encodes message without plugboard&#34;</span> <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            encodeMessage (rotorIII, rotorII, rotorI) reflectorB <span style=color:#66d9ef>[]</span> <span style=color:#e6db74>&#34;HELLOWORLD&#34;</span> `shouldBe` <span style=color:#e6db74>&#34;ILBDAAMTAZ&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        it <span style=color:#e6db74>&#34;encodes message with plugboard&#34;</span> <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            encodeMessage (rotorIII, rotorII, rotorI) reflectorB [(<span style=color:#e6db74>&#39;A&#39;</span>, <span style=color:#e6db74>&#39;B&#39;</span>)] <span style=color:#e6db74>&#34;HELLOWORLD&#34;</span> `shouldBe` <span style=color:#e6db74>&#34;ILADBBMTBZ&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        it <span style=color:#e6db74>&#34;encoded cipher matches message&#34;</span> <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            property <span style=color:#f92672>$</span> forAll genReflector <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>reflector <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genRotors <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>rotors <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genPlugboard <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>plugboard <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genMessage <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>message <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>let</span> cipher <span style=color:#f92672>=</span> encodeMessage rotors reflector plugboard message <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                              message <span style=color:#f92672>==</span> encodeMessage rotors reflector plugboard cipher
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        it <span style=color:#e6db74>&#34;cipher is same length as message&#34;</span> <span style=color:#f92672>$</span> <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>            property <span style=color:#f92672>$</span> forAll genReflector <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>reflector <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genRotors <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>rotors <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genPlugboard <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>plugboard <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                       forAll genMessage <span style=color:#f92672>$</span> <span style=color:#a6e22e>\</span>message <span style=color:#f92672>-&gt;</span>
</span></span><span style=display:flex><span>                          <span style=color:#66d9ef>let</span> cipher <span style=color:#f92672>=</span> encodeMessage rotors reflector plugboard message <span style=color:#66d9ef>in</span>
</span></span><span style=display:flex><span>                              length message <span style=color:#f92672>==</span> length cipher
</span></span></code></pre></div><p>Coupled with the help of <a href=https://hspec.github.io/ rel="external noopener" target=_blank>Hspec</a>, we are then able to define the two static example-based tests that we created before, along with the two machine properties that we wish to hold true.
Although the syntax is naturally different, the general philosophy of how a property-based test is expressed and validated is very similar to the ClojureScript counterpart.</p><p>As stated in the previous post this test-suite is by no means exhaustive and can be expanded upon greatly.
The goal of this is to highlight the key differences between conventional test assertions and testing validity of <em>System under test</em> (SUT) properties.
This test-suite can be run locally using the <code>make test</code> target, or you can see example resulting output by-way of the configured <a href=https://github.com/eddmann/enigma-machine-haskell/actions rel="external noopener" target=_blank>GitHub Action</a>.</p><h2 id=the-user-interface>The User Interface</h2><p>To make this implementation a little different, I have opted to provide a command-line based user interface over a web-based one.
In doing so, we are able to see a very powerful use-case for Haskell&rsquo;s <a href=http://learnyouahaskell.com/syntax-in-functions rel="external noopener" target=_blank>pattern matching</a> functionality.</p><p>To achieve this end-goal, we must first provide a means for the client to translate their desired machine configuration into one that our <code>encodeMessage</code> function can understand.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>toRotor</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Rotor</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>toRotor</span> <span style=color:#f92672>=</span> (flip lookup) [(<span style=color:#e6db74>&#39;1&#39;</span>, rotorI), (<span style=color:#e6db74>&#39;2&#39;</span>, rotorII), (<span style=color:#e6db74>&#39;3&#39;</span>, rotorIII)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>toReflector</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>Char</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Maybe</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>toReflector</span> <span style=color:#f92672>=</span> (flip lookup) [(<span style=color:#e6db74>&#39;A&#39;</span>, reflectorA), (<span style=color:#e6db74>&#39;B&#39;</span>, reflectorB), (<span style=color:#e6db74>&#39;C&#39;</span>, reflectorC)]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>toPlugboard</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>String</span> <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>Plugboard</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>toPlugboard</span> (x <span style=color:#66d9ef>:</span> y <span style=color:#66d9ef>:</span> xs) <span style=color:#f92672>=</span> [(toUpper x, toUpper y)] <span style=color:#f92672>++</span> toPlugboard xs
</span></span><span style=display:flex><span><span style=color:#a6e22e>toPlugboard</span> <span style=color:#66d9ef>_</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>[]</span>
</span></span></code></pre></div><p>With this functionality now in place, we can move on to parsing the command-line argument input.
Thanks to how powerful Haskell&rsquo;s pattern matching is, we are able to concisely break up the problem of parsing each of the required machine components as follows.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>parseRotors</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>String</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>Rotors</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseRotors</span> (<span style=color:#e6db74>&#34;-rotors&#34;</span> <span style=color:#66d9ef>:</span> [a, b, c] <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> (toRotor a, toRotor b, toRotor c) <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>Just</span> a&#39;, <span style=color:#66d9ef>Just</span> b&#39;, <span style=color:#66d9ef>Just</span> c&#39;) <span style=color:#f92672>-&gt;</span> pure (a&#39;, b&#39;, c&#39;)
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>_</span> <span style=color:#f92672>-&gt;</span> fail <span style=color:#f92672>$</span> <span style=color:#e6db74>&#34;invalid rotors &#34;</span> <span style=color:#f92672>++</span> [a, b, c] <span style=color:#f92672>++</span> <span style=color:#e6db74>&#34; specified in args&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseRotors</span> (<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>:</span> xs) <span style=color:#f92672>=</span> parseRotors xs
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseRotors</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> fail <span style=color:#e6db74>&#34;rotors must be specified in args&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parsePlugboard</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>String</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>Plugboard</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parsePlugboard</span> (<span style=color:#e6db74>&#34;-plugboard&#34;</span> <span style=color:#66d9ef>:</span> plugboard <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> pure <span style=color:#f92672>$</span> toPlugboard plugboard
</span></span><span style=display:flex><span><span style=color:#a6e22e>parsePlugboard</span> (<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>:</span> xs) <span style=color:#f92672>=</span> parsePlugboard xs
</span></span><span style=display:flex><span><span style=color:#a6e22e>parsePlugboard</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> pure <span style=color:#66d9ef>[]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseReflector</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>String</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>Reflector</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseReflector</span> (<span style=color:#e6db74>&#34;-reflector&#34;</span> <span style=color:#66d9ef>:</span> [reflector] <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> <span style=color:#66d9ef>case</span> (toReflector <span style=color:#f92672>.</span> toUpper) reflector <span style=color:#66d9ef>of</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Just</span> reflector&#39; <span style=color:#f92672>-&gt;</span> pure reflector&#39;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>Nothing</span> <span style=color:#f92672>-&gt;</span> fail <span style=color:#f92672>$</span> <span style=color:#e6db74>&#34;invalid reflector &#34;</span> <span style=color:#f92672>++</span> [reflector] <span style=color:#f92672>++</span> <span style=color:#e6db74>&#34; specified in args&#34;</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseReflector</span> (<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>:</span> xs) <span style=color:#f92672>=</span> parseReflector xs
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseReflector</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> fail <span style=color:#e6db74>&#34;reflector must be specified in args&#34;</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseMessage</span> <span style=color:#f92672>::</span> [<span style=color:#66d9ef>String</span>] <span style=color:#f92672>-&gt;</span> <span style=color:#66d9ef>IO</span> <span style=color:#66d9ef>String</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseMessage</span> (<span style=color:#e6db74>&#34;-message&#34;</span> <span style=color:#66d9ef>:</span> message <span style=color:#66d9ef>:</span> <span style=color:#66d9ef>_</span>) <span style=color:#f92672>=</span> pure <span style=color:#f92672>$</span> map toUpper message
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseMessage</span> (<span style=color:#66d9ef>_</span> <span style=color:#66d9ef>:</span> xs) <span style=color:#f92672>=</span> parseMessage xs
</span></span><span style=display:flex><span><span style=color:#a6e22e>parseMessage</span> <span style=color:#66d9ef>[]</span> <span style=color:#f92672>=</span> fail <span style=color:#e6db74>&#34;message must be specified in args&#34;</span>
</span></span></code></pre></div><p>I have decided to take advantage of the <em>IO</em> Monad and return a wrapped value for each given parsed configuration option.
This allows us to neatly use <em>do</em> notation described below to build a fully configured machine, short-circuiting at any stage where we are unable to parse the given input option.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-haskell data-lang=haskell><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>::</span> <span style=color:#66d9ef>IO</span> ()
</span></span><span style=display:flex><span><span style=color:#a6e22e>main</span> <span style=color:#f92672>=</span>  <span style=color:#66d9ef>do</span>
</span></span><span style=display:flex><span>    args <span style=color:#f92672>&lt;-</span> <span style=color:#66d9ef>System</span><span style=color:#f92672>.</span><span style=color:#66d9ef>Environment</span><span style=color:#f92672>.</span>getArgs
</span></span><span style=display:flex><span>    rotors <span style=color:#f92672>&lt;-</span> parseRotors args
</span></span><span style=display:flex><span>    reflector <span style=color:#f92672>&lt;-</span> parseReflector args
</span></span><span style=display:flex><span>    plugboard <span style=color:#f92672>&lt;-</span> parsePlugboard args
</span></span><span style=display:flex><span>    message <span style=color:#f92672>&lt;-</span> parseMessage args
</span></span><span style=display:flex><span>    print <span style=color:#f92672>$</span> encodeMessage rotors reflector plugboard message
</span></span></code></pre></div><p>With the machine configuration successfully parsed, we are able to invoke the <code>encodeMessage</code> function and print the resulting cipher message to the Terminal.</p><h2 id=conclusion>Conclusion</h2><p>I felt reimplementing the Enigma Machine in Haskell was a very worthwhile endeavour, allowing me to compare and contrast how the problem can be solved in the two different languages.
I am a big fan of Lisp and the Clojure dialect, but I did find how useful declaring functions by means of simple type transformations was a very pleasing and powerful development process.
Starting off by thinking in solely type transformations as opposed to concrete behaviour provided a means to build up the system in a very succinct manner.
From here, I hope to spend some additional time solving future problems using Haskell, taking more time to leverage further aspects of its very expressive type system.</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/enigma-machine>enigma-machine</a></li><li><a href=/archive/tag/haskell>haskell</a></li><li><a href=/archive/tag/property-testing>property-testing</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/building-an-enigma-machine-in-clojurescript/>Building an Enigma Machine in ClojureScript</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>