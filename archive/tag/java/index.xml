<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on Edd Mann</title><link>https://eddmann.com/archive/tag/java/</link><description>Recent content in Java on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Fri, 14 Mar 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Parallel Summation in Java</title><link>https://eddmann.com/posts/parallel-summation-in-java/</link><pubDate>Fri, 14 Mar 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/parallel-summation-in-java/</guid><description>&lt;p>Summation is the common operation of adding a sequence of numbers together, resulting in their total.
The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress.
For small sequences, a single-threaded implementation will suffice.
However, when the size increases, the use of other available CPU cores helps to provide the necessary speed optimisations.
As addition is an associative operation, it makes no difference to the end result in which order we process the collection.
This behaviour works well for our implementation design.&lt;/p></description></item><item><title>Implementing Heapsort in Java and C</title><link>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</link><pubDate>Mon, 06 Jan 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-heapsort-in-java-and-c/</guid><description>&lt;p>In this post, we will delve into the mechanics of heapsort by building a tree-based heap data structure and then methodically extracting a sorted array.
We will then implement said algorithm in both Java and C to get a feel for how the process is modelled in code.&lt;/p></description></item><item><title>Experimenting with the XOR Swap Method in Java</title><link>https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/</link><pubDate>Sun, 29 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/</guid><description>&lt;p>The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable.
Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length &lt;a href="http://en.wikipedia.org/wiki/Bit_array" rel="external noopener" target="_blank">bit-strings&lt;/a> will work.
Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to &lt;a href="http://en.wikipedia.org/wiki/High-level_programming_language" rel="external noopener" target="_blank">higher-level&lt;/a> programmers.
Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes.
An example of such an abstraction is the &lt;a href="http://javabook.compuware.com/content/memory/how-garbage-collection-works.aspx" rel="external noopener" target="_blank">garbage collector&lt;/a> found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention.&lt;/p></description></item><item><title>Least Significant Digit (LSD) Radix Sort in Java</title><link>https://eddmann.com/posts/least-significant-digit-lsd-radix-sort-in-java/</link><pubDate>Sat, 28 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/least-significant-digit-lsd-radix-sort-in-java/</guid><description>&lt;p>Radix sort is an O(digitsÂ·keys) sorting algorithm that relies on grouping integer keys to efficiently process and naturally order the specified dataset.
Based on structure and positional notation, many other data types that can be represented in integer form (e.g. ASCII characters) can benefit from the algorithm.
Sorting occurs by comparing digits in the same position of the items.
Two alternative versions of the algorithm exist, each tackling the problem from the opposite direction.
In this post, I will describe an iterative least significant digit implementation which, as the name suggests, begins processing from the right-most digit position.
This implementation results in a &lt;a href="http://en.wikipedia.org/wiki/Stable_sort#Stability" rel="external noopener" target="_blank">stable&lt;/a> sort, whereas the other implementation, which tackles the most significant digit first, cannot guarantee stability.
In a stable sorting algorithm, the initial ordering of equal keys remains unchanged in the result.&lt;/p></description></item><item><title>Implementing a Queue in Java using Arrays and Linked Lists</title><link>https://eddmann.com/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/</link><pubDate>Tue, 24 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/</guid><description>&lt;p>Following on from my previous post on implementing a &lt;a href="https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/">stack&lt;/a> in Java, I now wish to discuss the equally important queue data structure.
Similar to the restrictions placed upon the stack implementation, the queue only allows mutation via two methods.
Addition (enqueue) occurs at the end of the collection, and removal (dequeue) from the beginning, resulting in a FIFO (First-In-First-Out) structure.
Queues are typically used as buffers to store data, objects, and events that are to be held for future sequential processing.
As discussed in the post on stacks, you are more than likely never going to have to implement such a data structure in practical use cases, as the language libraries will already include such an implementation (i.e. &lt;a href="http://www.cplusplus.com/reference/queue/queue/" rel="external noopener" target="_blank">C++ STL&lt;/a> and &lt;a href="http://www.php.net/manual/en/class.splqueue.php" rel="external noopener" target="_blank">PHP SplQueue&lt;/a>).&lt;/p></description></item><item><title>Shunting Yard Implementation in Java</title><link>https://eddmann.com/posts/shunting-yard-implementation-in-java/</link><pubDate>Mon, 23 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/shunting-yard-implementation-in-java/</guid><description>&lt;p>The Shunting Yard algorithm was developed by the great &lt;a href="http://en.wikipedia.org/wiki/Edsger_Dijkstra" rel="external noopener" target="_blank">Edsger Dijkstra&lt;/a> as a means to parse an infix mathematical expression into Reverse Polish notation (postfix).
Using this notation allows the computer to evaluate the expression in a simple stack-based form, &lt;a href="https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/">examples&lt;/a> of which I have shown in Scala previously.
The algorithm itself also uses a stack along with a built-up output string to create the resulting value.
Below is an example implementation which only takes into consideration brackets and the four common operator precedences.
Although it is possible to evaluate more, including functions and associativity, I decided to keep the implementation simple to better highlight the process.&lt;/p></description></item><item><title>Implementing a Stack in Java using Arrays and Linked Lists</title><link>https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/</link><pubDate>Sun, 22 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/</guid><description>&lt;p>The stack is a fundamental data structure used extensively in algorithm design and program implementation.
At an abstract level, it can be described very simply, as it only allows for the addition (pushing) of new elements and the removal (popping) of existing elements from the top of the stack.
This description can be abbreviated to LIFO, which stands for Last-In-First-Out.
Although you will most likely not have to implement such a structure for practical use cases, it can be very useful to &amp;rsquo;look under the hood&amp;rsquo; to gain a better understanding of what is going on.
Doing so will make you more aware of when this data structure can be best used.&lt;/p></description></item><item><title>Using Bit Flags and EnumSets in Java</title><link>https://eddmann.com/posts/using-bit-flags-and-enumsets-in-java/</link><pubDate>Fri, 20 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/using-bit-flags-and-enumsets-in-java/</guid><description>&lt;p>This post examines two popular methods for handling multiple boolean values in Java.
It explores the traditional approach of using bit flags and compares it with the more modern EnumSet implementation.
By analysing both techniques, you will gain insights into their performance, readability, and type safety.&lt;/p></description></item><item><title>Decimal to Hexadecimal using Bitwise, Bit Shift Operations in Java</title><link>https://eddmann.com/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/</link><pubDate>Wed, 18 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/</guid><description>&lt;p>I recently wanted to create a simple function in JavaScript which allowed me to generate a random background colour for a small &lt;a href="http://workshop.eddmann.com/copacabana/" rel="external noopener" target="_blank">experiment&lt;/a> I was working on.
The implementation I came up with worked very well, but the decimal-hexadecimal representation conversion was all wrapped up in one &lt;code>toString(16)&lt;/code> function call.
I was very interested in creating this method myself, and I decided to use the Java language for the attempt.
The discussed functionality is already present in the Java language, within the &lt;code>java.lang.Integer&lt;/code> class, as &lt;code>toHexString&lt;/code>.&lt;/p></description></item><item><title>Merge sort comparison in Java and Scala</title><link>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</link><pubDate>Wed, 27 Nov 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/merge-sort-comparison-in-java-and-scala/</guid><description>&lt;p>Having only just recently got a complete shot of functional goodness in the form of the &lt;a href="http://www.coursera.org/course/progfun" rel="external noopener" target="_blank">Functional Programming Principles in Scala&lt;/a> &lt;a href="http://en.wikipedia.org/wiki/Massive_open_online_course" rel="external noopener" target="_blank">MOOC&lt;/a>, my imperative standing is in a state of confusion.
Is mutability the devil, should every function not have side-effects, what really is a monad?
Okay, so I may be joking a little with these semi-rhetorical remarks - boy, have I read enough monad posts for a lifetime.
Added to the mainstream application design consensus, the functional paradigm is making inroads out of multi-core necessity (goodbye &lt;a href="http://en.wikipedia.org/wiki/Moore%27s_law" rel="external noopener" target="_blank">Moore&amp;rsquo;s law&lt;/a>).&lt;/p></description></item></channel></rss>