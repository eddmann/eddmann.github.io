<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>QuickSort in Clojure - Edd Mann</title>
<meta name=description content="Discover diverse and efficient implementations of the QuickSort algorithm in Clojure using lazy sequences and functional programming techniques."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="QuickSort in Clojure"><meta itemprop=description content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta itemprop=datePublished content="2016-01-11T00:00:00+00:00"><meta itemprop=dateModified content="2016-01-11T00:00:00+00:00"><meta itemprop=wordCount content="281"><meta itemprop=keywords content="Clojure,Functional-Programming,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/quicksort-in-clojure/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="QuickSort in Clojure"><meta property="og:description" content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2016-01-11T00:00:00+00:00"><meta property="article:tag" content="Clojure"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="QuickSort in Clojure"><meta name=twitter:description content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.385a4c6910ac4090f8725dd12816e7725e21fbe762a09e31f1ece6d5dfebea36.css integrity="sha256-OFpMaRCsQJD4cl3RKBbncl4h++dioJ4x8ezm1d/r6jY="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/quicksort-in-clojure/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.7f6917401c23509595a4da9144cfe3c8fde343c0352e6d627aa366129e1bdb48.js integrity="sha256-f2kXQBwjUJWVpNqRRM/jyP3jQ8A1Lm1ieqNmEp4b20g=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:quicksort-in-clojure>QuickSort in Clojure</h1><time datetime=2016-01-11T00:00:00Z class=published-at>Jan 11, 2016</time></header><main class=u-prose><p>This past weekend I had the opportunity to delve more deeply into Clojure&rsquo;s <a href=https://clojuredocs.org/clojure.core rel="external noopener" target=_blank>core library</a>.
I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways.</p><h2 id=random-number-generation>Random Number Generation</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>numbers [n]
</span></span><span style=display:flex><span>  (take n (<span style=color:#a6e22e>repeatedly</span> <span style=color:#f92672>#</span>(rand-int <span style=color:#ae81ff>100</span>))))
</span></span></code></pre></div><p>Using the above function we are able to take advantage of lazy sequences to create an infinite list of random integers.
This infinite list is made finite (using <code>take</code>) when supplying the function with the desired number of integers required.</p><h2 id=solution-1>Solution 1</h2><p>The first implementation declaratively describes the QuickSort algorithm.
It uses collection filtering to split the input based on the selected pivot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (concat (<span style=color:#a6e22e>quick-sort</span> (filter <span style=color:#f92672>#</span>(&lt; % pivot) coll))
</span></span><span style=display:flex><span>            [pivot]
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>quick-sort</span> (filter <span style=color:#f92672>#</span>(&gt;= % pivot) coll)))))
</span></span></code></pre></div><h2 id=solution-2>Solution 2</h2><p>The second implementation removes the duplication created by the two filtering predicates by specifying a single <code>greater?</code> function.
This function is used for both filtering and subsequently removing (the inverse) from the supplied collection.
We also employ the lazy concatenation function which returns a lazy sequence that is only evaluated when required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>[greater? <span style=color:#f92672>#</span>(&gt; % pivot)]
</span></span><span style=display:flex><span>      (lazy-cat (<span style=color:#a6e22e>quick-sort</span> (remove greater? coll))
</span></span><span style=display:flex><span>                [pivot]
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>quick-sort</span> (filter greater? coll))))))
</span></span></code></pre></div><h2 id=solution-3>Solution 3</h2><p>The final implementation utilises the <code>group-by</code> function provided by the core library.
This function neatly partitions the collection into two separate lists in an extremely expressive manner.
We are then able to destructure the returned map, assigning the true and false values to more clearly named <code>lesser</code> and <code>greater</code> variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>[{lesser false greater true} (<span style=color:#a6e22e>group-by</span> <span style=color:#f92672>#</span>(&gt; % pivot) coll)]
</span></span><span style=display:flex><span>      (lazy-cat (<span style=color:#a6e22e>quick-sort</span> lesser)
</span></span><span style=display:flex><span>                [pivot]
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>quick-sort</span> greater)))))
</span></span></code></pre></div></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/clojure>clojure</a></li><li><a href=/archive/tag/functional-programming>functional-programming</a></li><li><a href=/archive/tag/algorithms>algorithms</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/mergesort-in-clojure-using-post-conditionals/>Mergesort in Clojure using Post Conditionals</a></li><li><a href=/posts/recursive-functions-using-a-trampoline-in-clojure/>Recursive Functions using a Trampoline in Clojure</a></li><li><a href=/posts/infix-calculator-in-clojure/>Infix Calculator in Clojure</a></li><li><a href=/posts/functional-quick-sort-in-scala-and-javascript/>Functional Quick sort in Scala and JavaScript</a></li><li><a href=/posts/reverse-polish-notation-rpn-in-scala/>Reverse Polish Notation (RPN) in Scala</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>