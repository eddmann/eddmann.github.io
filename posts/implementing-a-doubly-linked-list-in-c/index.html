<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Implementing a Doubly Linked List in C - Edd Mann</title>
<meta name=description content="A comprehensive guide to implementing a doubly linked list in C, covering structure, memory management and forward declarations."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Implementing a Doubly Linked List in C"><meta itemprop=description content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta itemprop=datePublished content="2014-01-03T00:00:00+00:00"><meta itemprop=dateModified content="2014-01-03T00:00:00+00:00"><meta itemprop=wordCount content="602"><meta itemprop=keywords content="C,Data-Structures"><meta property="og:url" content="https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Implementing a Doubly Linked List in C"><meta property="og:description" content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2014-01-03T00:00:00+00:00"><meta property="article:tag" content="C"><meta property="article:tag" content="Data-Structures"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Doubly Linked List in C"><meta name=twitter:description content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Implementing a Doubly Linked List in C</h1><time class=post__time>Jan 3, 2014</time></header><main class=prose><p>Following on from the discussion on implementing a <a href=/posts/implementing-a-singly-linked-list-in-c/>singly linked list</a> in C, a logical follow-up data structure is the doubly linked list.</p><p>In a similar fashion to the singly linked list, the structure is composed of a set of sequentially linked nodes, each now containing references (pointers) not only to the next node but also to the previous one.
This structure is useful if the use case requires the ability to traverse the list both forwards and backwards, or to quickly determine preceding and following elements from a given node.
The head and tail nodes can be terminated with either <a href=http://en.wikipedia.org/wiki/Sentinel_node rel="external noopener" target=_blank>sentinel nodes</a> (referred to as <em>circularly linked</em> if only one is used) or, as in the implementation shown below, <code>NULL</code>.
One notable implementation difference between the two structures is that by storing both the previous and next references, the complexity and running time of certain operations (with removal from the tail being the most obvious) can be significantly simplified.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> item;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>prev, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>} node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>node <span style=color:#f92672>*</span>head, <span style=color:#f92672>*</span>tail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>int</span> item, <span style=color:#66d9ef>bool</span> at_tail)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> (node<span style=color:#f92672>*</span>) <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(node));
</span></span><span style=display:flex><span>    ptr<span style=color:#f92672>-&gt;</span>item <span style=color:#f92672>=</span> item;
</span></span><span style=display:flex><span>    ptr<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) {
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> tail <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (at_tail) {
</span></span><span style=display:flex><span>        tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>        ptr<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        ptr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        head<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>bool</span> from_tail)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Empty list.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (from_tail) {
</span></span><span style=display:flex><span>        node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>item;
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> tail) head <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>item;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) tail <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> head<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (NULL <span style=color:#f92672>!=</span> ptr) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d &#34;</span>, ptr<span style=color:#f92672>-&gt;</span>item);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(i, i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list</span>(); <span style=color:#75715e>// 10 9 8 7 6 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list</span>(); <span style=color:#75715e>// 8 7 6 1 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Looking at the implementation above, you will notice the omission of list traversal when removing a node from the tail, as the reference to the previous node is already at hand.
The <code>list</code> function only takes into consideration forward iteration over the list, however, it would be very easy to modify the code to perform backwards traversal.
It is good practice to not only free the memory that is no longer required, but also to set any related pointers to <code>NULL</code>, as these pointers would otherwise still refer to memory that has been deallocated.</p><p>One C implementation detail I would like to discuss is the use of <code>typedef struct</code> when declaring the node structure.
In C, there are two different namespaces: one for <code>struct</code> tags and one for <code>typedef</code> names.
Referring to a <code>struct</code> can be very verbose, and to avoid this we can declare both a node <code>struct</code> and a plain node in the <code>typedef</code> namespace.
Both refer to the same type, allowing us to omit the <code>struct</code> keyword.
However, using only the <code>typedef</code> declaration would not allow us to perform a <a href=http://en.wikipedia.org/wiki/Forward_declaration rel="external noopener" target=_blank>forward declaration</a>, which gives us the ability to use an identifier before providing the complete definition to the compiler.</p><h2 id=resources>Resources</h2><ul><li><a href=http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c rel="external noopener" target=_blank>Difference between &lsquo;struct&rsquo; and &rsquo;typedef struct&rsquo; in C++?</a></li><li><a href=http://en.wikipedia.org/wiki/Forward_declaration rel="external noopener" target=_blank>Forward declaration</a></li></ul></main><footer class=post__tags><a href=/archive/tag/c>c</a><a href=/archive/tag/data-structures>data-structures</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>