<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Determining your closest Parkrun Alphabet Challenge using Python and pandas - Edd Mann</title>
<meta name=description content="Explore how to use Python and pandas to determine the closest Parkrun events for completing the Alphabet Challenge based on your local run."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Determining your closest Parkrun Alphabet Challenge using Python and pandas"><meta itemprop=description content="The Parkrun Alphabet is an unofficial challenge that sees runners complete a Parkrun at locations starting with each letter of the English alphabet. I am a big fan of Parkrun and wanted to work out how feasible it would be for me to complete the challenge based on the closest tourist locations to my local weekly run. I also thought this would be a great opportunity to explore pandas and work with DataFrames."><meta itemprop=datePublished content="2023-07-22T00:00:00+00:00"><meta itemprop=dateModified content="2023-07-22T00:00:00+00:00"><meta itemprop=wordCount content="824"><meta itemprop=keywords content="Python"><meta property="og:url" content="https://eddmann.com/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Determining your closest Parkrun Alphabet Challenge using Python and pandas"><meta property="og:description" content="The Parkrun Alphabet is an unofficial challenge that sees runners complete a Parkrun at locations starting with each letter of the English alphabet. I am a big fan of Parkrun and wanted to work out how feasible it would be for me to complete the challenge based on the closest tourist locations to my local weekly run. I also thought this would be a great opportunity to explore pandas and work with DataFrames."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-07-22T00:00:00+00:00"><meta property="article:modified_time" content="2023-07-22T00:00:00+00:00"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Determining your closest Parkrun Alphabet Challenge using Python and pandas"><meta name=twitter:description content="The Parkrun Alphabet is an unofficial challenge that sees runners complete a Parkrun at locations starting with each letter of the English alphabet. I am a big fan of Parkrun and wanted to work out how feasible it would be for me to complete the challenge based on the closest tourist locations to my local weekly run. I also thought this would be a great opportunity to explore pandas and work with DataFrames."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.c3ee6cab58dd3fee7e6960b0391e996ba9254804702bc60a52ec5e0e3591a018.css integrity="sha256-w+5sq1jdP+5+aWCwOR6Za6klSARwK8YKUuxeDjWRoBg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.164d56ac6f4c8613b0b7109fd1b4d9dfdce1d004edab8e1afb7240013f9221d7.js integrity="sha256-Fk1WrG9MhhOwtxCf0bTZ39zh0ATtq44a+3JAAT+SIdc=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas>Determining your closest Parkrun Alphabet Challenge using Python and pandas</h1><time datetime=2023-07-22T00:00:00Z class=published-at>Jul 22, 2023</time></header><main class=u-prose><p>The Parkrun Alphabet is an <a href=https://blog.parkrun.com/uk/2018/07/18/the-parkrun-alphabet/ rel="external noopener" target=_blank>unofficial challenge</a> that sees runners complete a Parkrun at locations starting with each letter of the English alphabet.
I am a big fan of Parkrun and wanted to work out how feasible it would be for me to complete the challenge based on the closest <em>tourist</em> locations to my <em>local</em> weekly run.
I also thought this would be a great opportunity to explore <a href=https://pandas.pydata.org/ rel="external noopener" target=_blank>pandas</a> and work with <a href=https://pandas.pydata.org/docs/reference/api/pandas.DataFrame.html rel="external noopener" target=_blank>DataFrames</a>.</p><p><picture><source type=image/webp srcset="/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_aaac2a7f0cc91e61.webp 350w, /posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_9ad9e4f6c54b4b70.webp 700w, /posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_c46b487ddbc3a09b.webp 1400w"><source type=image/jpeg srcset="/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_5cb153de115fe6da.jpg 350w, /posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_fe3eef73a9f02eee.jpg 700w, /posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_1cde96092e843668.jpg 1400w"><img src=/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/shoes_hu_fe3eef73a9f02eee.jpg alt="A pair of worn-out running shoes on a colorful map marked with various “parkrun” event locations." loading=lazy></picture></p><p>This post was originally written as a Jupyter Notebook, which can be <a href=/posts/determining-your-closest-parkrun-alphabet-challenge-using-python-and-pandas/closest-parkrun-alphabet-challenge.ipynb>downloaded here</a>.</p><h2 id=the-dataset>The Dataset</h2><p>My first job was to build a dataset of all the current Parkrun events and their locations.
Fortunately, the official Parkrun website provides this dataset indirectly via OpenStreetMap <a href=https://wiki.openstreetmap.org/wiki/Features rel="external noopener" target=_blank>Features</a> in their interactive map.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> requests
</span></span><span style=display:flex><span><span style=color:#f92672>import</span> json
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>events <span style=color:#f92672>=</span> json<span style=color:#f92672>.</span>loads(requests<span style=color:#f92672>.</span>get(<span style=color:#e6db74>&#34;https://images.parkrun.com/events.json&#34;</span>)<span style=color:#f92672>.</span>content)
</span></span></code></pre></div><p>For historical prosperity, I stored a local copy of this dataset.
As it is not an official dataset but rather an implementation detail of another feature, there is a high likelihood it could change.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>with</span> open(<span style=color:#e6db74>&#34;closest-parkrun-alphabet-challenge.json&#34;</span>, <span style=color:#e6db74>&#34;w&#34;</span>) <span style=color:#66d9ef>as</span> file:
</span></span><span style=display:flex><span>    file<span style=color:#f92672>.</span>write(json<span style=color:#f92672>.</span>dumps(events, indent<span style=color:#f92672>=</span><span style=color:#ae81ff>4</span>))
</span></span></code></pre></div><p>This dataset provides the necessary Parkrun event names and location coordinates (longitude and latitude).
Based on a supplied local Parkrun event, I should be able to determine the closest event per letter of the English alphabet to complete the challenge.</p><h2 id=calculating-distances-using-the-haversine-formula>Calculating Distances using the Haversine Formula</h2><p>To calculate the distance between two different events, I will use the Haversine formula.
This formula calculates the shortest distance over the Earth&rsquo;s surface, giving an &lsquo;as-the-crow-flies&rsquo; distance between two points.
Although this does not account for actual travel considerations (such as roads, traffic, etc.), it is a <em>good enough</em> metric to solve the problem.
There are <a href=https://nathanrooy.github.io/posts/2016-09-07/haversine-with-python/ rel="external noopener" target=_blank>many</a> <a href=https://en.wikipedia.org/wiki/Haversine_formula rel="external noopener" target=_blank>other</a> <a href=https://www.movable-type.co.uk/scripts/latlong.html rel="external noopener" target=_blank>resources</a> that explain how this formula works.
Instead of re-implementing it, I have decided to use an <a href=https://pypi.org/project/haversine/ rel="external noopener" target=_blank>existing library</a>.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>!</span>pip install haversine
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>[event_a, event_b, <span style=color:#f92672>*</span>_] <span style=color:#f92672>=</span> events[<span style=color:#e6db74>&#34;events&#34;</span>][<span style=color:#e6db74>&#34;features&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>event_a[<span style=color:#e6db74>&#34;geometry&#34;</span>][<span style=color:#e6db74>&#34;coordinates&#34;</span>]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># [-0.335791, 51.410992]</span>
</span></span></code></pre></div><p>The library I am using appears to require the coordinates to be positioned in the opposite order (latitude, longitude) to what the dataset provides (longitude, latitude).
As such, I will apply a simple transformation over the dataset before using it in the distance calculation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>from</span> haversine <span style=color:#f92672>import</span> haversine
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>flip</span>(coords):
</span></span><span style=display:flex><span>    x, y <span style=color:#f92672>=</span> coords
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> y, x
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>haversine(flip(event_a[<span style=color:#e6db74>&#34;geometry&#34;</span>][<span style=color:#e6db74>&#34;coordinates&#34;</span>]), flip(event_b[<span style=color:#e6db74>&#34;geometry&#34;</span>][<span style=color:#e6db74>&#34;coordinates&#34;</span>]), unit<span style=color:#f92672>=</span><span style=color:#e6db74>&#34;mi&#34;</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e># 4.952173093357963</span>
</span></span></code></pre></div><h2 id=putting-it-all-together-with-pandas>Putting it all together with Pandas</h2><p>Now that we have the core building blocks in place, we can solve the problem using the pandas library.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#f92672>import</span> pandas <span style=color:#66d9ef>as</span> pd
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>frame <span style=color:#f92672>=</span> pd<span style=color:#f92672>.</span>json_normalize(events[<span style=color:#e6db74>&#34;events&#34;</span>][<span style=color:#e6db74>&#34;features&#34;</span>])
</span></span></code></pre></div><p>With the normalised dataset now imported into a DataFrame, I will apply some initial transformations to prepare the data for use.
The first of these is filtering out junior events, as I only want to consider adult events.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>ADULT_PARKRUN <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>
</span></span><span style=display:flex><span>frame <span style=color:#f92672>=</span> frame[frame[<span style=color:#e6db74>&#34;properties.seriesid&#34;</span>] <span style=color:#f92672>==</span> ADULT_PARKRUN]
</span></span></code></pre></div><p>The event names appear to conform to lowercase English alphabet characters (even for international Parkrun events).
We can create a new column from this data to group events alphabetically by their first character.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>frame[<span style=color:#e6db74>&#34;letter&#34;</span>] <span style=color:#f92672>=</span> frame[<span style=color:#e6db74>&#34;properties.eventname&#34;</span>]<span style=color:#f92672>.</span>str[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><p>As discussed before, the final dataset transformation ensures that the coordinates are supplied to the Haversine formula in the expected order.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>frame[<span style=color:#e6db74>&#34;geometry.coordinates&#34;</span>] <span style=color:#f92672>=</span> frame[<span style=color:#e6db74>&#34;geometry.coordinates&#34;</span>]<span style=color:#f92672>.</span>apply(flip)
</span></span></code></pre></div><p>We can now locate the local Parkrun event within the DataFrame.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>local_parkrun <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>loc[frame[<span style=color:#e6db74>&#34;properties.EventShortName&#34;</span>] <span style=color:#f92672>==</span> <span style=color:#e6db74>&#34;Wimbledon Common&#34;</span>]<span style=color:#f92672>.</span>iloc[<span style=color:#ae81ff>0</span>]
</span></span></code></pre></div><pre tabindex=0><code>id                                                          2
type                                                  Feature
geometry.type                                           Point
geometry.coordinates                   (51.442078, -0.232215)
properties.eventname                                wimbledon
properties.EventLongName             Wimbledon Common parkrun
properties.EventShortName                    Wimbledon Common
properties.LocalisedEventLongName                        None
properties.countrycode                                     97
properties.seriesid                                         1
properties.EventLocation                     Wimbledon Common
letter                                                      w
Name: 1, dtype: object
</code></pre><p>Finally, we determine the distance of each <em>tourist</em> event from the local event.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span>frame[<span style=color:#e6db74>&#34;distance&#34;</span>] <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>apply(<span style=color:#66d9ef>lambda</span> parkrun: haversine(parkrun[<span style=color:#e6db74>&#34;geometry.coordinates&#34;</span>], local_parkrun[<span style=color:#e6db74>&#34;geometry.coordinates&#34;</span>], unit<span style=color:#f92672>=</span><span style=color:#e6db74>&#39;mi&#39;</span>), axis<span style=color:#f92672>=</span><span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>challenge <span style=color:#f92672>=</span> frame<span style=color:#f92672>.</span>sort_values([<span style=color:#e6db74>&#39;letter&#39;</span>, <span style=color:#e6db74>&#39;distance&#39;</span>], ascending<span style=color:#f92672>=</span><span style=color:#66d9ef>True</span>)<span style=color:#f92672>.</span>groupby(<span style=color:#e6db74>&#39;letter&#39;</span>)<span style=color:#f92672>.</span>apply(<span style=color:#66d9ef>lambda</span> parkruns: parkruns<span style=color:#f92672>.</span>head(<span style=color:#ae81ff>2</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>challenge[[<span style=color:#e6db74>&#39;properties.EventShortName&#39;</span>, <span style=color:#e6db74>&#39;distance&#39;</span>]]
</span></span></code></pre></div><pre tabindex=0><code>              properties.EventShortName    distance
letter
a      275                   Ally Pally   11.633086
       864                     Aldenham   14.678486
b      0                     Bushy Park    4.952173
       69                     Brockwell    5.505712
c      1317              Clapham Common    3.610917
       344                   Crane Park    6.023641
d      302                      Dulwich    6.590564
       888               Dartford Heath   18.186340
e      462               East Grinstead   23.870382
       2162           Edenbrook Country   29.585593
f      562                Fulham Palace    2.181071
       20                 Finsbury Park   10.390485
g      177                  Gunnersbury    4.729258
       343                    Gladstone    7.940967
h      1637                    Hanworth    7.156085
       65               Hampstead Heath    8.508784
i      1755            Ifield Mill Pond   23.123788
       1876       Itchen Valley Country   59.060942
j      1544                 Jersey Farm   23.143607
       900                       Jersey  177.952723
k      68                      Kingston    3.497859
       1625                     Kingdom   25.778223
l      176                        Lloyd    8.459577
       2272  Lordship Recreation Ground   12.234581
m      301                     Mile End   10.021387
       1292                 Mole Valley   14.049230
n      122                      Nonsuch    5.883647
       566              Northala Fields    9.252729
o      50                 Old Deer Park    3.569700
       524                     Osterley    6.028906
p      668                  Peckham Rye    7.443820
       234                       Pymmes   14.130422
q      481              Queen Elizabeth   46.581142
       309             Queen&#39;s, Belfast  320.843908
r      3                  Richmond Park    2.700374
       15               Roundshaw Downs    7.902912
s      2108                    Southall    7.536143
       199                South Norwood    8.075157
t      972               Tooting Common    3.729324
       2340       Thames Path, Woolwich   13.809657
u      390                  Upton Court   15.324948
       1644                    Uckfield   35.385475
v      1309               Victoria Dock   11.653173
       169                   Valentines   15.691955
w      1               Wimbledon Common    0.000000
       277              Wormwood Scrubs    5.419166
y      2297   Yarborough Leisure Centre  125.414614
       87                          York  176.070534
z      1905                  Zuiderpark  198.046322
       1779                 Ziegelwiese  523.953296
</code></pre><p>This approach provides an efficient way to determine the closest Parkrun events for completing the Alphabet Challenge using Python and pandas.
Happy running!</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/python>python</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/solving-the-advent-of-code-2021-calendar-using-c-in-under-half-a-second/>Solving the Advent of Code 2021 calendar using C in under half-a-second</a></li><li><a href=/posts/advent-of-code-2016-day-11-radioisotope-thermoelectric-generators/>Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators</a></li><li><a href=/posts/advent-of-code-2016-day-10-balance-bots/>Advent of Code 2016 - Day 10 - Balance Bots</a></li><li><a href=/posts/advent-of-code-2016-day-9-explosives-in-cyberspace/>Advent of Code 2016 - Day 9 - Explosives in Cyberspace</a></li><li><a href=/posts/advent-of-code-2016-day-8-two-factor-authentication/>Advent of Code 2016 - Day 8 - Two-Factor Authentication</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>