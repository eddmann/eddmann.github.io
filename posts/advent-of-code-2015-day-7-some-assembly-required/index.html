<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Solving the Advent of Code 2015 Day 7 puzzle using TypeScript.">

    <title>
        
            Advent of Code 2015 - Day 7 - Some Assembly Required &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Advent of Code 2015 - Day 7 - Some Assembly Required</h1>
    <time datetime="2021-01-31T00:00:00+00:00" class="post-date">31 Jan 2021</time>
    <p>On the seventh day of Advent of Code 2015, we are tasked with helping little Bobby Tables assemble a circuit (wires and bitwise logic gates) that Santa brought him for Christmas.</p>



<h2 id="part-1">Part 1</h2>

<p>Our input is an instruction booklet that describes how to connect these parts together.
By following the instructions laid out in the booklet, we are asked to determine what signal is ultimately provided to wire <code class="language-plaintext highlighter-rouge">a</code>.
As before, we will start by parsing the input into a usable form within our solution.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Wire</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Instruction</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Circuit</span> <span class="o">=</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">Wire</span><span class="p">,</span> <span class="nx">Instruction</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">parseCircuit</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Circuit</span> <span class="o">=&gt;</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">).</span><span class="nx">reduce</span><span class="p">((</span><span class="nx">circuit</span><span class="p">,</span> <span class="nx">line</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">instruction</span><span class="p">,</span> <span class="nx">wire</span><span class="p">]</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> -&gt; </span><span class="dl">'</span><span class="p">);</span>
    <span class="k">return</span> <span class="nx">circuit</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">);</span>
  <span class="p">},</span> <span class="k">new</span> <span class="nb">Map</span><span class="p">());</span>
</code></pre></div></div>

<p>The parser above converts the instruction listing into a <code class="language-plaintext highlighter-rouge">Circuit</code> mapping between the defined <code class="language-plaintext highlighter-rouge">Wire</code> and associated actionable <code class="language-plaintext highlighter-rouge">Instruction</code> (i.e. bitwise operation, assignment).
With the input now parsed, we can move on to working out how we wish to emulate this circuit and record the outputted signals.
Reviewing the input leads us to the conclusion that we cannot expect the instructions to be in dependency order like the provided example is - i.e. <code class="language-plaintext highlighter-rouge">b</code> is declared and assigned almost at the end of the listing but is referenced many times before this.
Taking this on board, and as we only wish to determine what a single wire signal is, my initial solution is to begin at wire <code class="language-plaintext highlighter-rouge">a</code>â€™s instruction and recursively build up the resulting signal.
This approach caters for the unsorted ordering and only performs the instructions required to answer the question.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getEmulatedSignal</span> <span class="o">=</span> <span class="p">(</span><span class="nx">circuit</span><span class="p">:</span> <span class="nx">Circuit</span><span class="p">,</span> <span class="nx">wire</span><span class="p">:</span> <span class="nx">Wire</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">emulate</span> <span class="o">=</span> <span class="nx">memoize</span><span class="p">((</span><span class="na">wire</span><span class="p">:</span> <span class="nx">Wire</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="sr">/^</span><span class="se">(\d)</span><span class="sr">+$/</span><span class="p">.</span><span class="nx">test</span><span class="p">(</span><span class="nx">wire</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">toInt</span><span class="p">(</span><span class="nx">wire</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">const</span> <span class="nx">instruction</span> <span class="o">=</span> <span class="nx">circuit</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">wire</span><span class="p">).</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">);</span>

    <span class="k">switch</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">AND</span><span class="dl">'</span><span class="p">):</span>
        <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
      <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">OR</span><span class="dl">'</span><span class="p">):</span>
        <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
      <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">LSHIFT</span><span class="dl">'</span><span class="p">):</span>
        <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
      <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">RSHIFT</span><span class="dl">'</span><span class="p">):</span>
        <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
      <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">NOT</span><span class="dl">'</span><span class="p">):</span>
        <span class="k">return</span> <span class="o">~</span><span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
      <span class="nl">default</span><span class="p">:</span>
        <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">wire</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Based on the currently supplied wire identifier, we provide a base case asserting that if the string value is a number, we simply return the integer equivalent.
All instructions laid out will eventually hit this base case, ensuring that the recursion will stop and the call stack tails can be evaluated.
Upon experimenting with this approach, I noticed that performance was a significant issue when attempting to run this on the actual input instruction booklet.
Due to naively recursing over all instructions, previously evaluated instructions would be unnecessarily recalculated multiple times down different branches.
To resolve this, I employed a small generic <a href="https://en.wikipedia.org/wiki/Memoization">memoization</a> function, which wrapped the closure and opaquely provided a caching mechanism for subsequent calls to the same resolved wire signal.</p>

<p>You will also notice the use of a <code class="language-plaintext highlighter-rouge">0xffff</code> mask when applying the <em>NOT</em> operation on the value.
As explained in the problem statement, the signals are unsigned 16-bit values; however, JavaScript bitwise operators use 32 bits.
To produce the desired results, we must apply the 16-bit mask provided.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span>
  <span class="nx">getEmulatedSignal</span><span class="p">(</span><span class="nx">parseCircuit</span><span class="p">(</span><span class="nx">input</span><span class="p">),</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
</code></pre></div></div>

<p>With the logic in place, we can combine the two functions and determine the resulting signal from wire <code class="language-plaintext highlighter-rouge">a</code> ðŸŒŸ.</p>

<h2 id="part-2">Part 2</h2>

<p>For part two, we are required to replace the original inputâ€™s wire <code class="language-plaintext highlighter-rouge">b</code> value with the resulting signal that we emulated in part one for wire <code class="language-plaintext highlighter-rouge">a</code>.
From this, we are then asked to determine the new resulting signal for wire <code class="language-plaintext highlighter-rouge">a</code>.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">circuit</span> <span class="o">=</span> <span class="nx">parseCircuit</span><span class="p">(</span><span class="nx">input</span><span class="p">);</span>
  <span class="nx">circuit</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="dl">'</span><span class="s1">b</span><span class="dl">'</span><span class="p">,</span> <span class="nx">getEmulatedSignal</span><span class="p">(</span><span class="nx">circuit</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">).</span><span class="nx">toString</span><span class="p">());</span>
  <span class="k">return</span> <span class="nx">getEmulatedSignal</span><span class="p">(</span><span class="nx">circuit</span><span class="p">,</span> <span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>By modifying the parsed circuit mapping before getting the newly emulated signal, we obtain the desired answer ðŸŒŸ.</p>

<h2 id="alternative-solution">Alternative Solution</h2>

<p>Since solving this problem, I re-evaluated the provided input and noticed that it did not include any <a href="https://en.wikipedia.org/wiki/Circular_dependency">circular dependencies</a>!
As such, it could be treated as a <a href="https://en.wikipedia.org/wiki/Directed_acyclic_graph">Directed Acyclic Graph</a> (DAG), which would allow us to perform a <a href="https://en.wikipedia.org/wiki/Topological_sorting">Topological Sort</a> to return the correctly ordered instruction listing.
This would allow us to emulate the circuit without the need for recursion.
I set out to re-implement the solution using this newfound knowledge and approach.</p>

<p>I began by creating the function below, which parses the instruction listing in a very different manner than before.
Instead of simply returning the parsed instructions in an unordered map back to the callee, this function returns an array of the <em>correctly</em> ordered instruction execution.
Correctness, in this case, means that all required wire signal values will have already been emulated before attempting to evaluate the given wire instruction.
As such, we can just iterate through the instruction listing once to return the entire signal value outputs.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Wire</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>
<span class="kd">type</span> <span class="nx">Instruction</span> <span class="o">=</span> <span class="kr">string</span><span class="p">[];</span>

<span class="kd">const</span> <span class="nx">createInstructionExecutionOrder</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">input</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="p">[</span><span class="nx">Wire</span><span class="p">,</span> <span class="nx">Instruction</span><span class="p">][]</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">dependencies</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">Wire</span><span class="p">,</span> <span class="nx">Wire</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="kd">const</span> <span class="nx">instructions</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">Wire</span><span class="p">,</span> <span class="nx">Instruction</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">line</span> <span class="k">of</span> <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">))</span> <span class="p">{</span>
    <span class="kd">const</span> <span class="p">[</span><span class="nx">instruction</span><span class="p">,</span> <span class="nx">wire</span><span class="p">]</span> <span class="o">=</span> <span class="nx">line</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> -&gt; </span><span class="dl">'</span><span class="p">);</span>
    <span class="nx">dependencies</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">match</span><span class="p">(</span><span class="sr">/</span><span class="se">([</span><span class="sr">a-z</span><span class="se">]</span><span class="sr">+</span><span class="se">)</span><span class="sr">/g</span><span class="p">)</span> <span class="o">||</span> <span class="p">[]);</span>
    <span class="nx">instructions</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> </span><span class="dl">'</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kd">const</span> <span class="nx">visited</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="nx">Wire</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="kd">const</span> <span class="na">ordered</span><span class="p">:</span> <span class="nx">Wire</span><span class="p">[]</span> <span class="o">=</span> <span class="p">[];</span>

  <span class="p">[...</span><span class="nx">dependencies</span><span class="p">.</span><span class="nx">keys</span><span class="p">()].</span><span class="nx">forEach</span><span class="p">(</span><span class="kd">function</span> <span class="nx">dfs</span><span class="p">(</span><span class="na">wire</span><span class="p">:</span> <span class="nx">Wire</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">visited</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">wire</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
    <span class="nx">visited</span><span class="p">.</span><span class="nx">add</span><span class="p">(</span><span class="nx">wire</span><span class="p">);</span>
    <span class="nx">dependencies</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">wire</span><span class="p">).</span><span class="nx">forEach</span><span class="p">(</span><span class="nx">dfs</span><span class="p">);</span>
    <span class="nx">ordered</span><span class="p">.</span><span class="nx">push</span><span class="p">(</span><span class="nx">wire</span><span class="p">);</span>
  <span class="p">});</span>

  <span class="k">return</span> <span class="nx">ordered</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">wires</span><span class="p">,</span> <span class="nx">wire</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[...</span><span class="nx">wires</span><span class="p">,</span> <span class="p">[</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instructions</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">wire</span><span class="p">)]],</span>
    <span class="p">[]</span>
  <span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Treating the instruction booklet as a DAG allows us to perform the Topological Sort (opting for the <a href="https://en.wikipedia.org/wiki/Topological_sorting#Depth-first_search">Depth-First Search approach</a>) and return the ordered instructions.
With this in hand, we now need a means to emulate and return the signal value for a given wireâ€™s instruction - based on the signal mapping that we have built up to that point.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Signals</span> <span class="o">=</span> <span class="nb">Map</span><span class="o">&lt;</span><span class="nx">Wire</span><span class="p">,</span> <span class="kr">number</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">emulate</span> <span class="o">=</span> <span class="p">(</span><span class="nx">signals</span><span class="p">:</span> <span class="nx">Signals</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">:</span> <span class="nx">Instruction</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="kd">get</span> <span class="o">=</span> <span class="p">(</span><span class="na">token</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span>
    <span class="nx">signals</span><span class="p">.</span><span class="nx">has</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span> <span class="p">?</span> <span class="nx">signals</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="nx">token</span><span class="p">)</span> <span class="p">:</span> <span class="nx">toInt</span><span class="p">(</span><span class="nx">token</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="kc">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">AND</span><span class="dl">'</span><span class="p">):</span>
      <span class="k">return</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&amp;</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">OR</span><span class="dl">'</span><span class="p">):</span>
      <span class="k">return</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">|</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">LSHIFT</span><span class="dl">'</span><span class="p">):</span>
      <span class="k">return</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">RSHIFT</span><span class="dl">'</span><span class="p">):</span>
      <span class="k">return</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;&gt;</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">2</span><span class="p">]);</span>
    <span class="k">case</span> <span class="nx">instruction</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="dl">'</span><span class="s1">NOT</span><span class="dl">'</span><span class="p">):</span>
      <span class="k">return</span> <span class="o">~</span><span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="nl">default</span><span class="p">:</span>
      <span class="k">return</span> <span class="kd">get</span><span class="p">(</span><span class="nx">instruction</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>We use a local <code class="language-plaintext highlighter-rouge">get</code> helper function to attempt to retrieve the instruction identifier value from the signal mapping; otherwise, we assume it must be an integer value that we must parse.
From here, we can then perform a single reduction over the instruction execution listing, building up the resulting signal mapping along the way.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="na">signals</span><span class="p">:</span> <span class="nx">Signals</span> <span class="o">=</span> <span class="nx">createInstructionExecutionOrder</span><span class="p">(</span><span class="nx">input</span><span class="p">).</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="p">[</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">])</span> <span class="o">=&gt;</span>
      <span class="nx">signals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">)),</span>
    <span class="k">new</span> <span class="nb">Map</span><span class="p">()</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>It is then from this built map that we can get the signal value which has been emulated for wire <code class="language-plaintext highlighter-rouge">a</code>.
Likewise, we can solve part two in a similar manner, except we must first replace the signal value of wire <code class="language-plaintext highlighter-rouge">b</code> with part oneâ€™s answer.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">instructions</span> <span class="o">=</span> <span class="nx">createInstructionExecutionOrder</span><span class="p">(</span>
    <span class="nx">input</span><span class="p">.</span><span class="nx">replace</span><span class="p">(</span><span class="sr">/^</span><span class="se">\d</span><span class="sr">+ -&gt; b$/gm</span><span class="p">,</span> <span class="s2">`</span><span class="p">${</span><span class="nx">part1</span><span class="p">(</span><span class="nx">input</span><span class="p">).</span><span class="nx">toString</span><span class="p">()}</span><span class="s2"> -&gt; b`</span><span class="p">)</span>
  <span class="p">);</span>
  <span class="kd">const</span> <span class="na">signals</span><span class="p">:</span> <span class="nx">Signals</span> <span class="o">=</span> <span class="nx">instructions</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="p">[</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">])</span> <span class="o">=&gt;</span>
      <span class="nx">signals</span><span class="p">.</span><span class="kd">set</span><span class="p">(</span><span class="nx">wire</span><span class="p">,</span> <span class="nx">emulate</span><span class="p">(</span><span class="nx">signals</span><span class="p">,</span> <span class="nx">instruction</span><span class="p">)),</span>
    <span class="k">new</span> <span class="nb">Map</span><span class="p">()</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="nx">signals</span><span class="p">.</span><span class="kd">get</span><span class="p">(</span><span class="dl">'</span><span class="s1">a</span><span class="dl">'</span><span class="p">);</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I really enjoyed exploring the Topological Sorting algorithm to implement the second solution to todayâ€™s problem.
By performing this initial ordering, we can greatly simplify the emulation logic and remove the need for any memoization or recursive calls.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
