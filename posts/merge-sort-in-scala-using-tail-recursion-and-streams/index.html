<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Merge sort in Scala using Tail-recursion and Streams - Edd Mann</title>
<meta name=description content="Discover two optimised implementations of merge sort in Scala using tail recursion and streams, complete with detailed code examples and explanations."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Merge sort in Scala using Tail-recursion and Streams"><meta itemprop=description content="In a previous post I made a rudimentary comparison of Java and Scala using the Merge sort algorithm as a case study. There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list. In this post I wish to describe two very different implementations that resolve this glaring omission."><meta itemprop=datePublished content="2013-12-01T00:00:00+00:00"><meta itemprop=dateModified content="2013-12-01T00:00:00+00:00"><meta itemprop=wordCount content="684"><meta itemprop=keywords content="Scala,Algorithms,Functional-Programming"><meta property="og:url" content="https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Merge sort in Scala using Tail-recursion and Streams"><meta property="og:description" content="In a previous post I made a rudimentary comparison of Java and Scala using the Merge sort algorithm as a case study. There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list. In this post I wish to describe two very different implementations that resolve this glaring omission."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-12-01T00:00:00+00:00"><meta property="article:modified_time" content="2013-12-01T00:00:00+00:00"><meta property="article:tag" content="Scala"><meta property="article:tag" content="Algorithms"><meta property="article:tag" content="Functional-Programming"><meta name=twitter:card content="summary"><meta name=twitter:title content="Merge sort in Scala using Tail-recursion and Streams"><meta name=twitter:description content="In a previous post I made a rudimentary comparison of Java and Scala using the Merge sort algorithm as a case study. There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list. In this post I wish to describe two very different implementations that resolve this glaring omission."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/merge-sort-in-scala-using-tail-recursion-and-streams/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Merge sort in Scala using Tail-recursion and Streams</h1><time class=post__time>Dec 1, 2013</time></header><main class=prose><p>In a previous <a href=/posts/merge-sort-comparison-in-java-and-scala/>post</a> I made a rudimentary comparison of Java and Scala using the <a href=http://en.wikipedia.org/wiki/Merge_sort rel="external noopener" target=_blank>Merge sort</a> algorithm as a case study.
There I described a trivial Scala implementation which did not take into consideration tail recursion, resulting in an unavoidable stack overflow when faced with a sufficiently sized list.
In this post I wish to describe two very different implementations that resolve this glaring omission.</p><h2 id=tail-recursion>Tail-recursion</h2><p>A method call can be categorised as tail-recursive if there is no action to undertake after the method returns, aside from returning its own value.
In such an example, a compiler rewrite (in effect mimicking <a href=http://en.wikipedia.org/wiki/Goto rel="external noopener" target=_blank>Goto</a>) can replace the caller in-place for the callee without any side effects.
As a result, no new stack frame is required (re-using the existing one) per recursive call, providing similar efficiency to a common iteration loop.</p><p>The &lsquo;merge&rsquo; method, which is the point of stack overflow consideration in our example, has been refactored below to instead use an accumulator parameter, now completing all required work before the next call.
The compiler is then able to parse these recursive method calls and run the described optimisation.
In this case, the Scala compiler does not require that an annotation be present as it can deduce this requirement; however, for clarity I have included it.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>implicit</span> <span style=color:#66d9ef>def</span> <span style=color:#a6e22e>IntIntLessThan</span><span style=color:#f92672>(</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> y<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> x <span style=color:#f92672>&lt;</span> y
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> mergeSort<span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>](</span>xs<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>])(</span><span style=color:#66d9ef>implicit</span> pred<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>T</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> m <span style=color:#66d9ef>=</span> xs<span style=color:#f92672>.</span>length <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> xs
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>@scala</span><span style=color:#f92672>.</span>annotation<span style=color:#f92672>.</span>tailrec
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> merge<span style=color:#f92672>(</span>ls<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>],</span> rs<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>],</span> acc<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>List</span><span style=color:#f92672>())</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span>ls<span style=color:#f92672>,</span> rs<span style=color:#f92672>)</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Nil</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> acc <span style=color:#f92672>++</span> rs
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>Nil</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> acc <span style=color:#f92672>++</span> ls
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>l <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ls1</span><span style=color:#f92672>,</span> r <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>rs1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pred<span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>))</span> merge<span style=color:#f92672>(</span>ls1<span style=color:#f92672>,</span> rs<span style=color:#f92672>,</span> acc <span style=color:#66d9ef>:</span><span style=color:#66d9ef>+</span> <span style=color:#66d9ef>l</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> merge<span style=color:#f92672>(</span>ls<span style=color:#f92672>,</span> rs1<span style=color:#f92672>,</span> acc <span style=color:#66d9ef>:</span><span style=color:#66d9ef>+</span> <span style=color:#66d9ef>r</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> xs splitAt m
</span></span><span style=display:flex><span>        merge<span style=color:#f92672>(</span>mergeSort<span style=color:#f92672>(</span>l<span style=color:#f92672>),</span> mergeSort<span style=color:#f92672>(</span>r<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println<span style=color:#f92672>(</span>mergeSort<span style=color:#f92672>(</span><span style=color:#a6e22e>List</span><span style=color:#f92672>(</span><span style=color:#ae81ff>4</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>2</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>,</span> <span style=color:#ae81ff>3</span><span style=color:#f92672>)))</span>
</span></span></code></pre></div><p>A small, example-driven inclusion that I have also made is in the use of an implicit method to provide the less-than predicate.
Implicits are an extremely powerful feature that deserves its own post.
Simply put, the compiler is able to implicitly deduce that I wish to use this comparator method based on its type signature <code>(Int, Int) => Boolean</code>.</p><h2 id=streams>Streams</h2><p>Another example which eliminates the chance of a stack overflow when calling the &lsquo;merge&rsquo; method is with the use of <a href=http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream rel="external noopener" target=_blank>Streams</a>.
From the provided &rsquo;numbers&rsquo; method you can gain a simple understanding that a Stream is basically a lazily evaluated sequence that only does the work (the generator method) when it is required.
This property does not particularly help us in this case, as we are required to know the finite length of the list for the divide step.
What we can take advantage of is the implicit conversion that occurs with the call #:: to a <a href=http://www.scala-lang.org/api/current/index.html#scala.collection.immutable.Stream$$ConsWrapper rel="external noopener" target=_blank>ConsWrapper</a>.
Calling this operator creates a new &lsquo;Cons&rsquo; object via the application <code>cons.apply[A](hd: A, tl -> Stream[A]): Cons[A]</code>, and due to the second argument being called-by-name, it does not get evaluated at this time on the stack.
As all objects on the JVM are created on the much larger heap, we in essence are indirectly transferring this work.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>def</span> mergeSort<span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>](</span>pred<span style=color:#66d9ef>:</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>T</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>T</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#a6e22e>Boolean</span><span style=color:#f92672>)(</span>xs<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> m <span style=color:#66d9ef>=</span> xs<span style=color:#f92672>.</span>length <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>m <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> xs
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>def</span> merge<span style=color:#f92672>(</span>ls<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>],</span> rs<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>])</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>T</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>(</span>ls<span style=color:#f92672>,</span> rs<span style=color:#f92672>)</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span><span style=color:#a6e22e>Stream</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Empty</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> rs
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>,</span> <span style=color:#a6e22e>Stream</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Empty</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> ls
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>l <span style=color:#f92672>#</span><span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>ls1</span><span style=color:#f92672>,</span> r <span style=color:#f92672>#</span><span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>rs1</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>pred<span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>))</span> l <span style=color:#f92672>#</span><span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>merge</span><span style=color:#f92672>(</span><span style=color:#66d9ef>ls1</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>rs</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>else</span> r <span style=color:#f92672>#</span><span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>merge</span><span style=color:#f92672>(</span><span style=color:#66d9ef>ls</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>rs1</span><span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>val</span> <span style=color:#f92672>(</span>l<span style=color:#f92672>,</span> r<span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> xs splitAt m
</span></span><span style=display:flex><span>        merge<span style=color:#f92672>(</span>mergeSort<span style=color:#f92672>(</span>pred<span style=color:#f92672>)(</span>l<span style=color:#f92672>),</span> mergeSort<span style=color:#f92672>(</span>pred<span style=color:#f92672>)(</span>r<span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>}</span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>def</span> numbers<span style=color:#f92672>(</span>remain<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Stream</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Int</span><span style=color:#f92672>]</span> <span style=color:#66d9ef>=</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>remain <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span><span style=color:#f92672>)</span> <span style=color:#a6e22e>Stream</span><span style=color:#f92672>.</span><span style=color:#a6e22e>Empty</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span> <span style=color:#a6e22e>Stream</span><span style=color:#f92672>.</span>cons<span style=color:#f92672>(</span>util<span style=color:#f92672>.</span><span style=color:#a6e22e>Random</span><span style=color:#f92672>.</span>nextInt<span style=color:#f92672>(</span><span style=color:#ae81ff>100</span><span style=color:#f92672>),</span> numbers<span style=color:#f92672>(</span>remain <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span><span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>println<span style=color:#f92672>(</span>mergeSort<span style=color:#f92672>((</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>,</span> y<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Int</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> x <span style=color:#f92672>&lt;</span> y<span style=color:#f92672>)(</span>numbers<span style=color:#f92672>(</span><span style=color:#ae81ff>4</span><span style=color:#f92672>)).</span>toList<span style=color:#f92672>)</span>
</span></span></code></pre></div><p>I should note, however, that although the above example is very crafty in its attempt to eliminate a stack overflow, it does, of course, move this issue over to the heap.
As a result, it is recommended to use the first example (tail-recursive optimisations) and enjoy the ninja-esque skills of the second one.</p></main><footer class=post__tags><a href=/archive/tag/scala>scala</a><a href=/archive/tag/algorithms>algorithms</a><a href=/archive/tag/functional-programming>functional-programming</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;setTimeout(()=>{const s=window.pageYOffset;n.classList.toggle("is-sticky",t>s),t=s,e=!1},500),e=!0})})()</script></body></html>