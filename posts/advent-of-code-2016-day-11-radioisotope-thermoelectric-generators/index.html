<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2016 Day 11 puzzle using Python."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators"><meta itemprop=description content="On the eleventh day of Advent of Code 2016, we are tasked with moving all the supplied Generators and Microchips to the top floor using a single elevator."><meta itemprop=datePublished content="2021-04-07T00:00:00+00:00"><meta itemprop=dateModified content="2021-04-07T00:00:00+00:00"><meta itemprop=wordCount content="862"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2016,Python"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2016-day-11-radioisotope-thermoelectric-generators/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators"><meta property="og:description" content="On the eleventh day of Advent of Code 2016, we are tasked with moving all the supplied Generators and Microchips to the top floor using a single elevator."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-04-07T00:00:00+00:00"><meta property="article:modified_time" content="2021-04-07T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2016"><meta property="article:tag" content="Python"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators"><meta name=twitter:description content="On the eleventh day of Advent of Code 2016, we are tasked with moving all the supplied Generators and Microchips to the top floor using a single elevator."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6c18b9cbfe138a24784e64860eaa9d70076170f03c68d8be3b3f1ae99e51df9f.css integrity="sha256-bBi5y/4TiiR4TmSGDqqdcAdhcPA8aNi+Oz8a6Z5R358="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x3x.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2016-day-11-radioisotope-thermoelectric-generators/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Advent of Code 2016 - Day 11 - Radioisotope Thermoelectric Generators</h1><time class=post__time>Apr 7, 2021</time></header><main class=prose><p>On the eleventh day of Advent of Code 2016, we are tasked with moving all the supplied Generators and Microchips to the top floor using a single elevator.</p><p>Having since read through some of the AoC subreddit, I can see that this is an <em>infamous</em> AoC day puzzle.
The puzzle description itself is <a href=https://adventofcode.com/2016/day/11 rel="external noopener" target=_blank>rather detailed</a>, so I would delegate to this to get an understanding of the problem at hand.
In summary, we are required to move all the Generators and Microchips to the top floor of a four-floor building.
To achieve this, we are provided with a single elevator, which can go up or down one level at a time, moving one or two objects in the process.
There are a couple of rules surrounding how a floor can be left upon each transition (which the problem definition lays out).
This initially reminded me of the <a href=https://www.mathsisfun.com/chicken_crossing_solution.html rel="external noopener" target=_blank>Chicken Crossing</a> puzzle.</p><h2 id=part-1>Part 1</h2><p>For part one, we are required to determine the minimum number of steps required to bring all of the objects to the fourth floor.
We will begin (as we always do) by parsing the supplied input (the initial object floor states) into a representation we can process going forward.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>parse_floors</span>(input):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> [set(re<span style=color:#f92672>.</span>findall(<span style=color:#e6db74>r</span><span style=color:#e6db74>&#39;(\w+)(?:-compatible)? (microchip|generator)&#39;</span>, line))
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> line <span style=color:#f92672>in</span> input<span style=color:#f92672>.</span>splitlines()]
</span></span></code></pre></div><p>This will return a list of all the floors&rsquo; initial states (zero-indexed) as sets in the form <code>NAME microchip</code> and <code>NAME generator</code>.
From here, we can begin to model the rules surrounding a valid floor transition.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_valid_transition</span>(floor):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> len(set(type <span style=color:#66d9ef>for</span> _, type <span style=color:#f92672>in</span> floor)) <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span> <span style=color:#f92672>or</span> \
</span></span><span style=display:flex><span>           all((obj, <span style=color:#e6db74>&#39;generator&#39;</span>) <span style=color:#f92672>in</span> floor
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>for</span> (obj, type) <span style=color:#f92672>in</span> floor
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span> type <span style=color:#f92672>==</span> <span style=color:#e6db74>&#39;microchip&#39;</span>)
</span></span></code></pre></div><p>At a high level, a floor is deemed valid if it is empty, only contains a single type (generators/microchips) of object, or, if there are multiple types, every microchip has its associated generator on that floor.
With the ability to now verify if a supplied floor is valid or not, we can continue modelling a means to generate all the possible transitions based on a supplied state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>next_states</span>(state):
</span></span><span style=display:flex><span>    moves, elevator, floors <span style=color:#f92672>=</span> state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    possible_moves <span style=color:#f92672>=</span> chain(combinations(floors[elevator], <span style=color:#ae81ff>2</span>), combinations(floors[elevator], <span style=color:#ae81ff>1</span>))
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> move <span style=color:#f92672>in</span> possible_moves:
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> direction <span style=color:#f92672>in</span> [<span style=color:#f92672>-</span><span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>1</span>]:
</span></span><span style=display:flex><span>            next_elevator <span style=color:#f92672>=</span> elevator <span style=color:#f92672>+</span> direction
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>not</span> <span style=color:#ae81ff>0</span> <span style=color:#f92672>&lt;=</span> next_elevator <span style=color:#f92672>&lt;</span> len(floors):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>continue</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            next_floors <span style=color:#f92672>=</span> floors<span style=color:#f92672>.</span>copy()
</span></span><span style=display:flex><span>            next_floors[elevator] <span style=color:#f92672>=</span> next_floors[elevator]<span style=color:#f92672>.</span>difference(move)
</span></span><span style=display:flex><span>            next_floors[next_elevator] <span style=color:#f92672>=</span> next_floors[next_elevator]<span style=color:#f92672>.</span>union(move)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (is_valid_transition(next_floors[elevator]) <span style=color:#f92672>and</span> is_valid_transition(next_floors[next_elevator])):
</span></span><span style=display:flex><span>                <span style=color:#66d9ef>yield</span> (moves <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>, next_elevator, next_floors)
</span></span></code></pre></div><p>The function above takes in a state (total moves performed, position of the elevator, and floor objects) as a tuple and yields all the possible valid state transitions we could perform from this position.
Thanks to Python&rsquo;s out-of-the-box combinatorics support, we can leverage this to simplify our solution.
With the ability to generate the next possible states from a given initial state, we now need a means of verifying if we have met our end goal state.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>is_all_top_level</span>(floors):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> all(<span style=color:#f92672>not</span> floor
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>for</span> number, floor <span style=color:#f92672>in</span> enumerate(floors)
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>if</span> number <span style=color:#f92672>&lt;</span> len(floors) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span></code></pre></div><p>From here, we can now create a <a href=https://en.wikipedia.org/wiki/Breadth-first_search rel="external noopener" target=_blank>BFS</a> implementation that traverses all the possible state transitions until it finally meets our end goal state.
Using BFS, we can be sure that this results in the shortest possible move total.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>min_moves_to_top_level</span>(floors):
</span></span><span style=display:flex><span>    seen <span style=color:#f92672>=</span> set()
</span></span><span style=display:flex><span>    queue <span style=color:#f92672>=</span> deque([(<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>, floors)])
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> queue:
</span></span><span style=display:flex><span>        state <span style=color:#f92672>=</span> queue<span style=color:#f92672>.</span>popleft()
</span></span><span style=display:flex><span>        moves, _, floors <span style=color:#f92672>=</span> state
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> is_all_top_level(floors):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> moves
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> next_state <span style=color:#f92672>in</span> next_states(state):
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> (key <span style=color:#f92672>:=</span> count_floor_objects(next_state)) <span style=color:#f92672>not</span> <span style=color:#f92672>in</span> seen:
</span></span><span style=display:flex><span>                seen<span style=color:#f92672>.</span>add(key)
</span></span><span style=display:flex><span>                queue<span style=color:#f92672>.</span>append(next_state)
</span></span></code></pre></div><p>But wait, what is this <code>count_floor_objects</code> function?!
So&mldr; to cut a long story short, I initially went about running this solution <em>pruning</em> any exact floor states that we had already encountered to help performance.
This, sadly, did not provide a solution reaching the end goal in an adequate amount of time ðŸ˜¢.
After pondering other techniques to help effectively prune the search space, I resorted to finding some clues online.
The clue I found asked the question, <em>&lsquo;what classifies a unique floor state?&rsquo;</em>.
After even more pondering and experimentation, I finally landed on what this clue meant.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>count_floor_objects</span>(state):
</span></span><span style=display:flex><span>    _, elevator, floors <span style=color:#f92672>=</span> state
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> elevator, tuple(tuple(Counter(type <span style=color:#66d9ef>for</span> _, type <span style=color:#f92672>in</span> floor)<span style=color:#f92672>.</span>most_common()) <span style=color:#66d9ef>for</span> floor <span style=color:#f92672>in</span> floors)
</span></span></code></pre></div><p>Providing that the floor state is valid (which all are when returned from <code>next_states</code>), we do not care about the <em>name</em> of the actual objects.
What this means is that a floor can simply be represented as a unique state based on the total number of generators and microchips that are on that floor (each pair is replaceable).
In doing this, we cut the search space down dramatically ðŸŽ‰.</p><p>With all the building blocks now in place, we can parse the input and call <code>min_moves_to_top_level</code>.
In doing so, we are returned the desired answer to this super-tough problem ðŸŒŸ!</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part1</span>(input):
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> min_moves_to_top_level(parse_floors(input))
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><p>Fortunately, part two is only a small <em>spin</em> on what is asked in part one.
We are now asked to calculate the minimum number of moves required based on the input state, along with two additional object pairs found on the first floor.
With a small addition, we can answer this question using the same <code>min_moves_to_top_level</code> function ðŸŒŸ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-python data-lang=python><span style=display:flex><span><span style=color:#66d9ef>def</span> <span style=color:#a6e22e>part2</span>(input):
</span></span><span style=display:flex><span>    floors <span style=color:#f92672>=</span> parse_floors(input)
</span></span><span style=display:flex><span>    floors[<span style=color:#ae81ff>0</span>] <span style=color:#f92672>=</span> floors[<span style=color:#ae81ff>0</span>]<span style=color:#f92672>.</span>union([(<span style=color:#e6db74>&#39;elerium&#39;</span>, <span style=color:#e6db74>&#39;generator&#39;</span>), (<span style=color:#e6db74>&#39;elerium&#39;</span>, <span style=color:#e6db74>&#39;microchip&#39;</span>),
</span></span><span style=display:flex><span>                                 (<span style=color:#e6db74>&#39;dilithium&#39;</span>, <span style=color:#e6db74>&#39;generator&#39;</span>), (<span style=color:#e6db74>&#39;dilithium&#39;</span>, <span style=color:#e6db74>&#39;microchip&#39;</span>)])
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> min_moves_to_top_level(floors)
</span></span></code></pre></div><p>What a day!</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/advent-of-code-2016>advent-of-code-2016</a><a href=/archive/tag/python>python</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>