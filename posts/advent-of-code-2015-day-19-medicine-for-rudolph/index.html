<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Solving the Advent of Code 2015 Day 19 puzzle using TypeScript.">

    <title>
        
            Advent of Code 2015 - Day 19 - Medicine for Rudolph &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Advent of Code 2015 - Day 19 - Medicine for Rudolph</h1>
    <time datetime="2021-02-12T00:00:00+00:00" class="post-date">12 Feb 2021</time>
    <p>On the nineteenth day of Advent of Code 2015, Rudolph is sick, and we have been tasked with helping develop the <em>custom-made</em> medicine required.</p>



<h2 id="part-1">Part 1</h2>

<p>We are tasked with helping calibrate the machine that is capable of constructing any Red-Nosed Reindeer molecule required to make the medicine.
As input, we are provided with an initial medicine molecule and a list of replacements that we need to apply.
For part one, we need to determine how many distinct molecules can be created using the replacements provided.
We begin, as always, by parsing this input into a form we can work with.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Replacement</span> <span class="o">=</span> <span class="p">[</span><span class="k">from</span><span class="p">:</span> <span class="kr">string</span><span class="p">,</span> <span class="nx">to</span><span class="p">:</span> <span class="kr">string</span><span class="p">];</span>
<span class="kd">type</span> <span class="nx">Molecule</span> <span class="o">=</span> <span class="kr">string</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">parseReplacementsAndMolecule</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">input</span><span class="p">:</span> <span class="kr">string</span>
<span class="p">):</span> <span class="p">{</span> <span class="nl">replacements</span><span class="p">:</span> <span class="nx">Replacement</span><span class="p">[];</span> <span class="nl">molecule</span><span class="p">:</span> <span class="nx">Molecule</span> <span class="p">}</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">[</span><span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span><span class="p">]</span> <span class="o">=</span> <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n\n</span><span class="dl">'</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">{</span>
    <span class="na">replacements</span><span class="p">:</span> <span class="nx">replacements</span>
      <span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">)</span>
      <span class="p">.</span><span class="nx">map</span><span class="p">(</span><span class="nx">r</span> <span class="o">=&gt;</span> <span class="nx">r</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="s1"> =&gt; </span><span class="dl">'</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="k">as</span> <span class="nx">Replacement</span><span class="p">),</span>
    <span class="nx">molecule</span><span class="p">,</span>
  <span class="p">};</span>
<span class="p">};</span>
</code></pre></div></div>

<p>With a listing of all the replacements and the initial molecule now available, we can use these values to determine all the possible molecule variants.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">getMoleculeVariants</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span>
  <span class="nx">m</span><span class="p">:</span> <span class="nx">Molecule</span><span class="p">,</span>
  <span class="p">[</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">]:</span> <span class="nx">Replacement</span>
<span class="p">):</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">Molecule</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">pattern</span> <span class="o">=</span> <span class="k">new</span> <span class="nb">RegExp</span><span class="p">(</span><span class="k">from</span><span class="p">,</span> <span class="dl">'</span><span class="s1">g</span><span class="dl">'</span><span class="p">);</span>

  <span class="kd">let</span> <span class="na">o</span><span class="p">:</span> <span class="nx">RegExpExecArray</span> <span class="o">|</span> <span class="kc">null</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">((</span><span class="nx">o</span> <span class="o">=</span> <span class="nx">pattern</span><span class="p">.</span><span class="nx">exec</span><span class="p">(</span><span class="nx">m</span><span class="p">)))</span> <span class="p">{</span>
    <span class="k">yield</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">o</span><span class="p">.</span><span class="nx">index</span><span class="p">)</span> <span class="o">+</span> <span class="nx">to</span> <span class="o">+</span> <span class="nx">m</span><span class="p">.</span><span class="nx">substr</span><span class="p">(</span><span class="nx">o</span><span class="p">.</span><span class="nx">index</span> <span class="o">+</span> <span class="k">from</span><span class="p">.</span><span class="nx">length</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Given the molecule and the desired replacement, we return a Generator that provides the caller with all the possible variants (based on individual occurrences) within the string.
This allows us to maintain the current position within the Generator and not muddle this logic into the callerâ€™s responsibility.</p>

<p>We can then combine these two functions and determine how many distinct molecule variants there are ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">parseReplacementsAndMolecule</span><span class="p">(</span>
    <span class="nx">input</span>
  <span class="p">);</span>

  <span class="kd">const</span> <span class="na">variants</span><span class="p">:</span> <span class="nx">Molecule</span><span class="p">[]</span> <span class="o">=</span> <span class="nx">replacements</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span>
    <span class="p">(</span><span class="nx">molecules</span><span class="p">,</span> <span class="nx">replacement</span><span class="p">)</span> <span class="o">=&gt;</span> <span class="p">[</span>
      <span class="p">...</span><span class="nx">molecules</span><span class="p">,</span>
      <span class="p">...</span><span class="nx">getMoleculeVariants</span><span class="p">(</span><span class="nx">molecule</span><span class="p">,</span> <span class="nx">replacement</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="p">[]</span>
  <span class="p">);</span>

  <span class="k">return</span> <span class="k">new</span> <span class="nb">Set</span><span class="o">&lt;</span><span class="nx">Molecule</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">variants</span><span class="p">).</span><span class="nx">size</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>I initially used a <code class="language-plaintext highlighter-rouge">Set</code> within the reduction, but due to the ease of combining arrays within JavaScript, I found it more readable to first get all possible variants and then return the <code class="language-plaintext highlighter-rouge">Set</code> (the deduplication process) at the end.</p>

<h2 id="part-2">Part 2</h2>

<p>For part two, with the machine now calibrated, we are required to help with the fabrication process.
Molecule fabrication always begins with just a single electron, <em>e</em>, and involves applying replacements one at a time, just like during calibration.
We are required to determine how many steps it will take to go from <em>e</em> to the provided molecule.</p>

<p>My initial thought was to begin at <em>e</em> and apply all possible variants until we landed on the desired molecule (as the problem states).
However, the distinct number of possibilities grows too fast, making this an unviable solution.
After a little thought, I decided to flip this problem around and, based on the molecule provided, determine how many replacements would be required to get back to <em>e</em>.
I opted for a <em>greedy approach</em>, sorting the replacements in descending length order.
By doing so, we can then count the steps required and return the desired total to answer part two ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="p">{</span> <span class="nx">replacements</span><span class="p">,</span> <span class="nx">molecule</span> <span class="p">}</span> <span class="o">=</span> <span class="nx">parseReplacementsAndMolecule</span><span class="p">(</span>
    <span class="nx">input</span>
  <span class="p">);</span>
  <span class="kd">const</span> <span class="nx">replacementsByLength</span> <span class="o">=</span> <span class="nx">replacements</span><span class="p">.</span><span class="nx">sort</span><span class="p">(</span>
    <span class="p">([,</span> <span class="nx">x</span><span class="p">],</span> <span class="p">[,</span> <span class="nx">y</span><span class="p">])</span> <span class="o">=&gt;</span> <span class="nx">y</span><span class="p">.</span><span class="nx">length</span> <span class="o">-</span> <span class="nx">x</span><span class="p">.</span><span class="nx">length</span>
  <span class="p">);</span>

  <span class="kd">let</span> <span class="nx">variant</span> <span class="o">=</span> <span class="nx">molecule</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">steps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="nx">variant</span> <span class="o">!==</span> <span class="dl">'</span><span class="s1">e</span><span class="dl">'</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="p">[</span><span class="k">from</span><span class="p">,</span> <span class="nx">to</span><span class="p">]</span> <span class="k">of</span> <span class="nx">replacementsByLength</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">r</span> <span class="k">of</span> <span class="nx">getMoleculeVariants</span><span class="p">(</span><span class="nx">variant</span><span class="p">,</span> <span class="p">[</span><span class="nx">to</span><span class="p">,</span> <span class="k">from</span><span class="p">]))</span> <span class="p">{</span>
        <span class="nx">variant</span> <span class="o">=</span> <span class="nx">r</span><span class="p">;</span>
        <span class="nx">steps</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">steps</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>The input has been constructed in such a way that there is no possibility for ambiguity, with only one path back to <em>e</em>.
An interesting optimisation I made was that in a previous solution, I broke out of both the variant and replacement loops upon finding a match.
This ensured that we performed the largest replacement possible at every step.
However, I experimented with what we now have above and instead allowed it to continue to the next possible replacement.
This appears to have sped up the solution while still returning the correct answer.</p>

<p>I really enjoyed todayâ€™s challenge and would highly recommend checking out the discussion on the <a href="https://www.reddit.com/r/adventofcode/comments/3xflz8/day_19_solutions/">/r/adventofcode</a> subreddit.
It details some interesting ways in which people have solved the problem by hand!</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
