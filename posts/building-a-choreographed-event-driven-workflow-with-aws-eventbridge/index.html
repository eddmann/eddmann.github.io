<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Building a Choreographed, Event-Driven Workflow with AWS EventBridge - Edd Mann</title>
<meta name=description content="Learn how to design and build a choreographed event-driven order fulfilment system using AWS EventBridge, Lambda, and SQS. Explore choreography vs orchestration, idempotency, observability, and IaC examples with CloudFormation and Terraform."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Building a Choreographed, Event-Driven Workflow with AWS EventBridge"><meta itemprop=description content="This post walks through building a choreographed, event-driven order fulfilment system on AWS using EventBridge, Lambda, and SQS. It covers how events propagate between subdomains, the trade-offs between choreography and orchestration, and how to handle idempotency, observability, and event schema design. Inspired by a real-world example in Monolith to Microservices, the post also includes infrastructure-as-code examples using both CloudFormation and Terraform."><meta itemprop=datePublished content="2024-06-20T00:00:00+00:00"><meta itemprop=dateModified content="2024-06-20T00:00:00+00:00"><meta itemprop=wordCount content="2198"><meta itemprop=keywords content="Serverless,Aws,Microservices,Eda"><meta property="og:url" content="https://eddmann.com/posts/building-a-choreographed-event-driven-workflow-with-aws-eventbridge/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Building a Choreographed, Event-Driven Workflow with AWS EventBridge"><meta property="og:description" content="This post walks through building a choreographed, event-driven order fulfilment system on AWS using EventBridge, Lambda, and SQS. It covers how events propagate between subdomains, the trade-offs between choreography and orchestration, and how to handle idempotency, observability, and event schema design. Inspired by a real-world example in Monolith to Microservices, the post also includes infrastructure-as-code examples using both CloudFormation and Terraform."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-06-20T00:00:00+00:00"><meta property="article:modified_time" content="2024-06-20T00:00:00+00:00"><meta property="article:tag" content="Serverless"><meta property="article:tag" content="Aws"><meta property="article:tag" content="Microservices"><meta property="article:tag" content="Eda"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Choreographed, Event-Driven Workflow with AWS EventBridge"><meta name=twitter:description content="This post walks through building a choreographed, event-driven order fulfilment system on AWS using EventBridge, Lambda, and SQS. It covers how events propagate between subdomains, the trade-offs between choreography and orchestration, and how to handle idempotency, observability, and event schema design. Inspired by a real-world example in Monolith to Microservices, the post also includes infrastructure-as-code examples using both CloudFormation and Terraform."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.4c8b66c005db4efc68625e4ceed190f2dc110d342d05ffb19ba924cc13c3ef15.css integrity="sha256-TItmwAXbTvxoYl5M7tGQ8twRDTQtBf+xm6kkzBPD7xU="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/building-a-choreographed-event-driven-workflow-with-aws-eventbridge/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.da71ac9c7b8bd4e644618df0ab735aed1393aad3cb5e5c57e5adc300fe7c8209.js integrity="sha256-2nGsnHuL1OZEYY3wq3Na7ROTqtPLXlxX5a3DAP58ggk=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li><li><a href=/cv.html>CV</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:building-a-choreographed-event-driven-workflow-with-aws-eventbridge>Building a Choreographed, Event-Driven Workflow with AWS EventBridge</h1><time datetime=2024-06-20T00:00:00Z class=published-at>Jun 20, 2024</time></header><main class=u-prose><p>Event-driven architectures (EDA) are a powerful asynchronous communication pattern, making them an excellent way to model real-world business processes.
Recently, whilst reading <a href=https://samnewman.io/books/monolith-to-microservices/ rel="external noopener" target=_blank>Monolith to Microservices</a> by Sam Newman, I came across a clear example of coordinating order fulfilment across multiple subdomains using a <em>choreographed</em> workflow.
This inspired me to explore how such an example could be built using AWS - leveraging EventBridge, SQS, and Lambda to model a distributed, yet coordinated, order fulfilment process.</p><p>In this post we&rsquo;ll explore how events propagate across subdomains and bounded contexts, the trade-offs between choreography and orchestration, and practical implementation details around event delivery, idempotency, and observability.</p><p>If you&rsquo;re interested in exploring the full working example, including both CloudFormation and Terraform infrastructure-as-code implementations, you can find the complete project on <a href=https://github.com/eddmann/aws-eventbridge-choreographed-workflow rel="external noopener" target=_blank>GitHub</a>.</p><h2 id=coordinating-events-choreography-or-orchestration>Coordinating Events: Choreography or Orchestration?</h2><p>When designing workflows that span multiple services or bounded contexts, there are two main approaches to coordination: <strong>choreography</strong> and <strong>orchestration</strong>.
Each comes with its own strengths and trade-offs, and interestingly, many real-world business processes actually blend both patterns at different levels of granularity.</p><h3 id=orchestration>Orchestration</h3><p>In this approach, a central component (the &ldquo;orchestrator&rdquo;) explicitly controls the workflow, telling each participant what to do, in what order, and when - much like a conductor leading an orchestra.</p><ul><li><em>Pros</em>: Clear visibility into the process flow, easier to manage complex or conditional logic, and centralised error handling.</li><li><em>Cons</em>: Tighter coupling between services and the orchestrator, which can become a single point of failure or a bottleneck.
Changes to the workflow often require changes to the orchestrator.</li></ul><h3 id=choreography>Choreography</h3><p>Here, each service listens for and reacts to events, knowing its own responsibilities.
There&rsquo;s no central authority; the &ldquo;music&rdquo; (events) guides the participants, and each service plays its part independently.</p><ul><li><em>Pros</em>: Loose coupling between services, allowing each subdomain (like Order, Warehouse, Payment, Loyalty) to evolve, fail, or scale independently.
This flexibility is a core strength of event-driven architectures.</li><li><em>Cons</em>: The overall process flow can be harder to visualise and reason about, and debugging cross-service flows may require more observability tooling.</li></ul><p>It&rsquo;s worth noting that in practice, many business processes leverage both orchestration and choreography - sometimes using choreography for high-level process management, while individual steps or subdomains interact via orchestration.
This hybrid approach can offer the best of both worlds: centralised control where it&rsquo;s needed, and flexibility and independence elsewhere.</p><p>For this project, I wanted to embrace the flexibility and independence of choreography, letting each subdomain contribute to the business process without a central controller. B
ut it&rsquo;s important to recognise that both approaches have their place, and the right choice (or combination) depends on your system&rsquo;s needs.</p><h2 id=the-business-process-the-happy-path-walkthrough>The Business Process: The &ldquo;Happy Path&rdquo; Walkthrough</h2><p>Here&rsquo;s the typical order fulfilment flow I wanted to model:</p><ol><li><strong>Order is placed</strong> by the customer (via an HTTP endpoint).</li><li><strong>Stock is reserved</strong> in the warehouse (via an SQS FIFO Lambda worker; deduplication at the queue level).</li><li><strong>Payment is taken</strong> (via an SQS Lambda worker with idempotency logic).</li><li><strong>Loyalty points are awarded</strong> (via an internal Loyalty Event Bus; direct Lambda integration with code-level deduplication).</li><li><strong>Order is shipped</strong> (via SQS FIFO Lambda worker).</li><li><strong>Order notifications</strong> are sent out (API endpoint is notified of the shipped order).</li></ol><p><img src=./order-fulfilment.png alt="Order Fulfilment Choreography Diagram" loading=lazy></p><p>This process is modelled across the following <em>discovered</em> subdomains:</p><ul><li><strong>Order</strong> - handles incoming customer requests.</li><li><strong>Warehouse</strong> - manages stock and shipping operations.</li><li><strong>Payment</strong> - processes financial transactions.</li><li><strong>Loyalty</strong> - awards points for completed orders.</li></ul><p>Each subdomain is responsible for reacting to relevant events and publishing new ones as the workflow progresses.
The key events in this process include:</p><ul><li><code>order.placed</code></li><li><code>warehouse.stock-reserved</code></li><li><code>payment.taken</code></li><li><code>loyalty.points-awarded</code></li><li><code>warehouse.order-shipped</code></li></ul><p>Note: In practice, the boundaries between subdomains and bounded contexts are not always so clearly defined.</p><h2 id=event-bus-design-public-private-and-cross-bus-propagation>Event Bus Design: Public, Private, and Cross-Bus Propagation</h2><p>I wanted to explore using both a <em>global event bus</em> for inter-domain communication and <em>private</em> (subdomain) event buses for internal events.
Here&rsquo;s how I approached it:</p><ul><li><strong>Global Event Bus</strong>: Used for events that cross between subdomains, such as order placement, stock reservation, and payment taken.</li><li><strong>Private (Subdomain) Event Buses</strong>: Used for events that are internal to a given subdomain, and possibly only of interest to bounded contexts (and in-turn services) within that subdomain.</li></ul><h3 id=propagating-events-across-buses>Propagating Events Across Buses</h3><p>AWS EventBridge allows you to set up rules that forward events from one bus to another.
For example, once the Payment service emits a <code>payment.taken</code> event on the global bus, a rule forwards it to the Loyalty Event Bus, where the Loyalty service can react accordingly.
This approach gives us fine-grained control: we can decide exactly which global event bus events each subdomain is interested in (by configuring rules to forward only relevant events to the subdomain&rsquo;s private event bus), and we can also choose which subdomain-specific events should be relayed back onto the global event bus for broader consumption. This selective propagation helps keep event flows clear and prevents unnecessary noise between subdomains.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>GlobalToLoyaltyEventBusEventRule</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>Type</span>: <span style=color:#ae81ff>AWS::Events::Rule</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Properties</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>EventBusName</span>: !<span style=color:#ae81ff>GetAtt GlobalEventBus.Name</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>EventPattern</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>source</span>:
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#39;payment&#39;</span>
</span></span><span style=display:flex><span>      <span style=color:#f92672>detail-type</span>:
</span></span><span style=display:flex><span>        - <span style=color:#e6db74>&#39;payment.taken&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>Targets</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>Id</span>: <span style=color:#e6db74>&#39;LoyaltyEventBus&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>Arn</span>: !<span style=color:#ae81ff>GetAtt LoyaltyEventBus.Arn</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>RoleArn</span>: !<span style=color:#ae81ff>GetAtt CrossEventBusRole.Arn</span>
</span></span></code></pre></div><h2 id=consumer-message-delivery-strategies>Consumer Message Delivery Strategies</h2><p>As I explored how best to deliver events to consumers, I experimented with two primary patterns: point-to-point queues using SQS and direct Lambda integration.</p><h3 id=1-using-sqs-as-a-delivery-buffer>1. Using SQS as a Delivery Buffer</h3><p>For services found in the Warehouse and Payment subdomains, I used Amazon SQS as a buffer between EventBridge and the worker Lambdas.
This approach proved effective in handling bursty workloads by decoupling the rate of event production from consumption.
It also provided built-in support for retries and dead-letter queues (DLQs), making error handling and recovery more straightforward.
Additionally, by using FIFO queues with content-based deduplication, I was able to ensure idempotency at the infrastructure level - an important consideration when dealing with exactly-once semantics in distributed systems.
This topic is discussed more <a href=/posts/building-a-choreographed-event-driven-workflow-with-aws-eventbridge/#handling-idempotency-handling-idempotency>below</a>.</p><p>Despite these benefits, this setup does introduce a bit more operational complexity.
It requires managing additional infrastructure components such as queues, Lambda triggers, and appropriate IAM permissions.
However, in most cases, the trade-off is well worth it for the added reliability and observability.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#75715e># Warehouse SQS FIFO queue and EventBridge target</span>
</span></span><span style=display:flex><span><span style=color:#f92672>WarehouseQueue</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>Type</span>: <span style=color:#ae81ff>AWS::SQS::Queue</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Properties</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>QueueName</span>: <span style=color:#e6db74>&#39;Warehouse.fifo&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>FifoQueue</span>: <span style=color:#66d9ef>true</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>ContentBasedDeduplication</span>: <span style=color:#66d9ef>true</span>
</span></span></code></pre></div><h3 id=2-direct-lambda-invocation-from-eventbridge>2. Direct Lambda Invocation from EventBridge</h3><p>The service found in the Loyalty sudomain uses direct integration between EventBridge and a Lambda function, without an intermediary queue.
This setup is straightforward to configure and offers low latency, making it well-suited to simple or low-throughput scenarios where the risk of overload is minimal.</p><p>That said, this pattern comes with some important trade-offs.
Without a buffer, it&rsquo;s more vulnerable to bursty traffic or scaling limitations - Lambda concurrency limits can be reached, and events may be dropped if not properly retried.
Additionally, if downstream processing fails, there&rsquo;s no built-in mechanism for retries or dead-letter handling.
While it can be appropriate for lightweight internal flows, this approach lacks the resilience and operational control typically needed for production workloads.</p><h3 id=why-i-prefer-a-queue>Why I Prefer a Queue</h3><p>I would tend to avoid relying on direct Lambda integration without a buffer.
Adding an SQS queue between EventBridge and consumers offers both robustness and resilience: it absorbs traffic spikes, smooths out the processing rate, and prevents downstream services from being overwhelmed.
Just as importantly, it provides built-in support for retries, delayed processing, and dead-letter queues - eliminating the need for custom failure handling logic.</p><h2 id=event-formats-cloudevents-and-the-double-envelope>Event Formats: CloudEvents and the Double Envelope</h2><p>To keep events standards-compliant and interoperable, I chose to format all domain events using the <a href=https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md rel="external noopener" target=_blank>CloudEvents</a> <a href=https://github.com/cloudevents/spec/blob/main/cloudevents/spec.md#message rel="external noopener" target=_blank>structured mode</a>.
These CloudEvents are then placed inside the <code>Detail</code> field when publishing to EventBridge (&ldquo;double envelope&rdquo;).</p><p>Here&rsquo;s a snippet from the <code>order.js</code> Lambda:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>event</span> <span style=color:#f92672>=</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>specversion</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;1.0&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>source</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;order&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;order.placed&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>data</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>order</span><span style=color:#f92672>:</span> {
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>id</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>items</span><span style=color:#f92672>:</span> [{ <span style=color:#a6e22e>sku</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;123&#39;</span>, <span style=color:#a6e22e>price</span><span style=color:#f92672>:</span> <span style=color:#ae81ff>123</span> }],
</span></span><span style=display:flex><span>    },
</span></span><span style=display:flex><span>  },
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>time</span><span style=color:#f92672>:</span> <span style=color:#66d9ef>new</span> Date().<span style=color:#a6e22e>toISOString</span>(),
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>dataschema</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;&#39;</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>correlationid</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>randomUUID</span>(),
</span></span><span style=display:flex><span>};
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>await</span> <span style=color:#a6e22e>client</span>.<span style=color:#a6e22e>send</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>PutEventsCommand</span>({
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>Entries</span><span style=color:#f92672>:</span> [
</span></span><span style=display:flex><span>      {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>EventBusName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>GLOBAL_EVENT_BUS_ARN</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Source</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>source</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>DetailType</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>event</span>.<span style=color:#a6e22e>type</span>,
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>Detail</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>event</span>),
</span></span><span style=display:flex><span>      },
</span></span><span style=display:flex><span>    ],
</span></span><span style=display:flex><span>  })
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>This approach lets you take advantage of EventBridge&rsquo;s native routing and filtering, using fields like <code>Source</code> and <code>DetailType</code>, while still embedding a full CloudEvent inside the <code>Detail</code> payload.
This means consumers can filter and subscribe based on either the top-level EventBridge metadata or specific fields within the CloudEvent structure (<code>detail.type</code>, <code>detail.source</code>, etc.).</p><p>While EventBridge is great for routing within AWS, it&rsquo;s fundamentally an infrastructure concern.
CloudEvents, on the other hand, is a vendor-neutral, portable event format.
Using it inside your payloads helps decouple your domain event schema from AWS-specific constructs.</p><h2 id=handling-idempotency-handling-idempotency>Handling Idempotency, Handling Idempotency</h2><p><a href=https://serverlessland.com/event-driven-architecture/idempotency rel="external noopener" target=_blank>Idempotency</a> is a critical concern in distributed systems, especially when using <em>at-least-once</em> delivery semantics.
Without it, retry mechanisms - whether triggered by network failures, throttling, or transient errors - can lead to duplicate processing, resulting in incorrect state transitions or unintended side effects like duplicate charges or loyalty point inflation.</p><p>At the infrastructure level, features like SQS FIFO queues with content-based deduplication offer a convenient way to suppress duplicate messages.
This can be particularly effective when messages are deterministic and well-bounded in time.
It&rsquo;s a valuable tool, but not without trade-offs.</p><p>While infrastructure-based deduplication helps improve robustness, we should be cautious about relying on it exclusively to enforce critical business rules.
Handling duplicate processing is often a domain concern - something that defines how the business behaves in edge cases.
If this logic is handled only by the infrastructure, it becomes invisible to the application, untested by business logic tests, and easily overlooked as the system evolves.
This separation can introduce fragility, especially when refactoring, introducing new consumers, or switching delivery mechanisms.</p><p>This is a classic example of the &ldquo;dumb pipe, smart endpoint&rdquo; principle in <a href=https://martinfowler.com/articles/microservices.html#SmartEndpointsAndDumbPipes rel="external noopener" target=_blank>microservices</a>: infrastructure should remain simple and reliable, while business rules - like idempotency - should be explicitly modelled in the domain code.</p><p>For that reason, I preferred to implement idempotency in code, using tools like <a href=https://docs.powertools.aws.dev/lambda/typescript/latest/ rel="external noopener" target=_blank>AWS Lambda Powertools</a> and DynamoDB.
This makes the logic explicit, testable, and resilient - regardless of how events are delivered or what the infrastructure layer does.</p><p>Here&rsquo;s a simplified example from the <code>loyalty.js</code> worker:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>makeIdempotent</span>,
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>IdempotencyConfig</span>,
</span></span><span style=display:flex><span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-lambda-powertools/idempotency&#39;</span>);
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>DynamoDBPersistenceLayer</span>,
</span></span><span style=display:flex><span>} <span style=color:#f92672>=</span> <span style=color:#a6e22e>require</span>(<span style=color:#e6db74>&#39;@aws-lambda-powertools/idempotency/dynamodb&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>persistenceStore</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>DynamoDBPersistenceLayer</span>({
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>tableName</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>process</span>.<span style=color:#a6e22e>env</span>.<span style=color:#a6e22e>IDEMPOTENCY_TABLE_NAME</span>,
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>config</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>IdempotencyConfig</span>({});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>handleEvent</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>makeIdempotent</span>(
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>async</span> (<span style=color:#a6e22e>_idempotencyId</span>, <span style=color:#a6e22e>event</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#75715e>// ... business logic ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>  },
</span></span><span style=display:flex><span>  { <span style=color:#a6e22e>persistenceStore</span>, <span style=color:#a6e22e>config</span> }
</span></span><span style=display:flex><span>);
</span></span></code></pre></div><p>In short, infrastructure can help, but idempotency is ultimately a business concern - and it belongs in the domain code where it&rsquo;s visible, maintainable, and under your control.</p><h2 id=observability-sqs-polling-worker-and-cloudwatch-logs>Observability: SQS Polling Worker and CloudWatch Logs</h2><p>To better understand and debug the flow of events across the system, I explored different ways to gain visibility into what was happening within the workflow.
Observability is especially important in event-driven architectures, where control flow is implicit and state changes are distributed across multiple services.</p><p>I set up two complementary mechanisms for capturing and inspecting events flowing through the global event bus.</p><p>The first is a polling-based observability worker, implemented as a simple Node.js process.
It continuously polls a dedicated SQS queue and prints incoming CloudEvents for real-time inspection.
This offers a quick way to see the live stream of events and monitor how different services interact across the workflow.
It can be run with a single command:</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-sh data-lang=sh><span style=display:flex><span>QUEUE<span style=color:#f92672>=</span>sqs_arn node ./observability-polling-worker/app.js
</span></span></code></pre></div><p>The second mechanism is an AWS CloudWatch Logs integration, where all events published to the global bus are forwarded to a dedicated log group.
This provides a persistent, searchable history of all system events - making it easy to trace workflows, correlate actions across subdomains, and identify issues retrospectively.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-yaml data-lang=yaml><span style=display:flex><span><span style=color:#f92672>GlobalObservabilityEventRule</span>:
</span></span><span style=display:flex><span>  <span style=color:#f92672>Type</span>: <span style=color:#ae81ff>AWS::Events::Rule</span>
</span></span><span style=display:flex><span>  <span style=color:#f92672>Properties</span>:
</span></span><span style=display:flex><span>    <span style=color:#f92672>EventBusName</span>: !<span style=color:#ae81ff>GetAtt GlobalEventBus.Name</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>EventPattern</span>:
</span></span><span style=display:flex><span>      <span style=color:#f92672>account</span>:
</span></span><span style=display:flex><span>        - !<span style=color:#ae81ff>Sub &#39;${AWS::AccountId}&#39;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>Targets</span>:
</span></span><span style=display:flex><span>      - <span style=color:#f92672>Id</span>: <span style=color:#e6db74>&#39;GlobalObservabilityLogGroup&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>Arn</span>: !<span style=color:#ae81ff>GetAtt GlobalObservabilityLogGroup.Arn</span>
</span></span><span style=display:flex><span>      - <span style=color:#f92672>Id</span>: <span style=color:#e6db74>&#39;GlobalObservabilityQueue&#39;</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>Arn</span>: !<span style=color:#ae81ff>GetAtt GlobalObservabilityQueue.Arn</span>
</span></span></code></pre></div><p>Together, these two mechanisms gave me real-time insight and historical context.
They helped me understand how events propagated across the example architecture and made it much easier to debug, reason about system behaviour, and confirm that services were communicating as intended.</p><h2 id=reflections-and-future-work>Reflections and Future Work</h2><p>Building this system was a genuinely rewarding learning experience.
What made it especially interesting was taking a conceptual example from Monolith to Microservices and translating it into a concrete, working implementation using AWS technologies.
It gave me a much deeper appreciation for how abstract patterns like event choreography, message routing, and domain separation play out in practice - especially when layered onto real infrastructure like EventBridge, SQS, and Lambda.</p><p>Along the way, I gained insight into the subtle decisions required around idempotency, observability, and event design.
Seeing events flow through the system in real time, and connecting those flows back to the original example, made the architecture feel far more tangible and approachable.</p><h3 id=whats-next>What&rsquo;s Next?</h3><p>There&rsquo;s a lot of scope for further exploration:</p><ul><li>Handling failure paths and recovery using <a href=https://microservices.io/patterns/data/saga.html rel="external noopener" target=_blank>saga patterns</a> and compensating actions.</li><li>Dealing with <a href=https://serverlessland.com/event-driven-architecture/ordering rel="external noopener" target=_blank>out-of-order</a> processing, especially in cases where event sequencing matters.
Since we&rsquo;re using an event bus and leaning into the &ldquo;dumb pipes, smart endpoints&rdquo; philosophy, we can&rsquo;t rely on infrastructure-level guarantees for message ordering.
Instead, this needs to be handled explicitly within the domain logic - whether through causal ordering, time-based buffer windows, or event correlation mechanisms.</li><li>Introducing an event catalogue and schema definitions to keep producers and consumers aligned.</li><li>Exploring event versioning strategies and setting up cross-account or cross-region event propagation.</li></ul></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/serverless>serverless</a></li><li><a href=/archive/tag/aws>aws</a></li><li><a href=/archive/tag/microservices>microservices</a></li><li><a href=/archive/tag/eda>eda</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/serverless-transactional-outbox-pattern-two-practical-approaches/>Serverless Transactional Outbox Pattern: Two Practical Approaches</a></li><li><a href=/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/>Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB</a></li><li><a href=/posts/managing-long-running-aws-fargate-ecs-tasks-within-your-serverless-project/>Managing long-running AWS Fargate ECS tasks within your Serverless project</a></li><li><a href=/posts/separating-out-the-lambda-bref-runtime-from-your-projects-composer-dependencies/>Separating out the Lambda Bref runtime from your project's Composer dependencies</a></li><li><a href=/posts/mince-pie-challenge-viewing-and-removing-mince-pies-with-amazon-dynamodb/>Mince Pie Challenge: Viewing and Removing Mince Pies with Amazon DynamoDB</a></li></ul></div></footer></article><div class="podcast-ad u-overlay-wrapper"><div class=podcast-ad__artwork><img src=https://compiledconversations.com/album-art.jpg alt="Compiled Conversations podcast album art" class=podcast-ad__artwork-image></div><div class=podcast-ad__content><h3 class=podcast-ad__title>Compiled Conversations</h3><p class=podcast-ad__description>Podcast I host, featuring conversations with the people shaping software and technology.</p><div class=podcast-ad__link>Check out the show</a></div><a class=u-overlay href=https://compiledconversations.com target=_blank>Listen to Compiled Conversations</a></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2026, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>