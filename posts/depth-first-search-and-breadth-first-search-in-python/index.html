<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="An in-depth guide to implementing Depth-First Search and Breadth-First Search in Python, exploring graph theory, connected components and pathfinding algorithms.">

    <title>
        
            Depth-First Search and Breadth-First Search in Python &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Depth-First Search and Breadth-First Search in Python</h1>
    <time datetime="2014-03-05T00:00:00+00:00" class="post-date">05 Mar 2014</time>
    <p>Graph theory and, in particular, the graph ADT (abstract data type) is widely explored and implemented in the field of Computer Science and Mathematics.
Consisting of vertices (nodes) and the edges (optionally directed or weighted) that connect them, the data structure is effectively able to represent and solve many problem domains.
One of the most popular areas of algorithm design within this space is the problem of checking for the existence of, or the (shortest) path between, two or more vertices in the graph. 
Properties such as edge weighting and direction are two factors that the algorithm designer can take into consideration.
In this post I will be exploring two of the simpler available algorithms, Depth-First and Breadth-First search, to achieve the goals highlighted below:</p>

<ul>
  <li>Find all vertices in a subject vertex’s <a href="http://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected component</a>.</li>
  <li>Return all available paths between two vertices.</li>
  <li>And, in the case of BFS, return the shortest path (with length measured by the number of path edges).</li>
</ul>

<h2 id="the-graph">The Graph</h2>

<p>So as to clearly discuss each algorithm, I have crafted a <a href="http://mathworld.wolfram.com/ConnectedGraph.html">connected graph</a> with six vertices and six incident edges.
The resulting graph is undirected with no assigned edge weightings, as length will be evaluated based on the number of path edges traversed.
There are two popular options for representing a graph: the first is an <a href="http://en.wikipedia.org/wiki/Adjacency_matrix">adjacency matrix</a> (effective with dense graphs) and the second is an <a href="http://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a> (effective with sparse graphs).
I have opted to implement an adjacency list which stores each node in a dictionary along with a set containing its adjacent nodes.
As the graph is undirected, each edge is stored in both incident nodes’ adjacent sets.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">graph</span> <span class="o">=</span> <span class="p">{</span><span class="s">'A'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'C'</span><span class="p">]),</span>
         <span class="s">'B'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'D'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">]),</span>
         <span class="s">'C'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'A'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">]),</span>
         <span class="s">'D'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'B'</span><span class="p">]),</span>
         <span class="s">'E'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'B'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">]),</span>
         <span class="s">'F'</span><span class="p">:</span> <span class="nb">set</span><span class="p">([</span><span class="s">'C'</span><span class="p">,</span> <span class="s">'E'</span><span class="p">])}</span>
</code></pre></div></div>

<p>Looking at the graph depiction below, you will also notice the inclusion of a cycle, by the adjacent connections between ‘F’ and ‘C/E’.
This has been purposely included to provide the algorithms with the option to return multiple paths between two desired nodes.</p>

<p><img src="/uploads/depth-first-search-and-breadth-first-search-in-python/graph.png" alt="Graph" /></p>

<h2 id="depth-first-search">Depth-First Search</h2>

<p>The first algorithm I will be discussing is Depth-First search, which, as the name hints, explores possible vertices (from a supplied root) down each branch before backtracking.
This property allows the algorithm to be implemented succinctly in both iterative and recursive forms.
Below is a listing of the actions performed upon each visit to a node:</p>

<ul>
  <li>Mark the current vertex as visited.</li>
  <li>Explore each adjacent vertex that is not included in the visited set.</li>
</ul>

<h3 id="connected-component">Connected Component</h3>

<p>The implementation below uses the stack data structure to build up and return a set of vertices that are accessible within the subject’s connected component.
Using Python’s overloading of the subtraction operator to remove items from a set, we are able to add only the unvisited adjacent vertices.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">,</span> <span class="n">stack</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="n">stack</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">visited</span>

<span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'A'</span><span class="p">)</span> <span class="c1"># {'E', 'D', 'F', 'A', 'C', 'B'}
</span></code></pre></div></div>

<p>The second implementation provides the same functionality as the first; however, this time we are using the more succinct recursive form.
Due to a common Python gotcha with <a href="http://developmentality.wordpress.com/2010/08/23/python-gotcha-default-arguments/">default parameter values</a> being created only once, we are required to create a new visited set on each user invocation.
Another Python language detail is that function variables are passed by reference, resulting in the visited mutable set not having to be reassigned upon each recursive call.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">visited</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">visited</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">start</span><span class="p">)</span>
    <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">:</span>
        <span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">visited</span>

<span class="n">dfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'C'</span><span class="p">)</span> <span class="c1"># {'E', 'D', 'F', 'A', 'C', 'B'}
</span></code></pre></div></div>

<h3 id="paths">Paths</h3>

<p>We are able to tweak both of the previous implementations to return all possible paths between a start and goal vertex.
The implementation below uses the stack data structure again to iteratively solve the problem, yielding each possible path when we locate the goal.
Using a <a href="https://wiki.python.org/moin/Generators">generator</a> allows the user to compute only the desired number of alternative paths.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="n">stack</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">])]</span>
    <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
        <span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
        <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">next</span> <span class="o">==</span> <span class="n">goal</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="nb">next</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">]))</span>

<span class="nb">list</span><span class="p">(</span><span class="n">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">))</span> <span class="c1"># [['A', 'C', 'F'], ['A', 'B', 'E', 'F']]
</span></code></pre></div></div>

<p>The implementation below uses the recursive approach, calling the ‘yield from’ <a href="http://legacy.python.org/dev/peps/pep-0380/">PEP 380</a> addition to return the located paths.
Unfortunately, the version of <a href="http://pygments.org/">Pygments</a> installed on the server at this time does not include the updated keyword combination.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="bp">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
        <span class="n">path</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">start</span> <span class="o">==</span> <span class="n">goal</span><span class="p">:</span>
        <span class="k">yield</span> <span class="n">path</span>
    <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">start</span><span class="p">]</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
        <span class="k">yield</span> <span class="k">from</span> <span class="n">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="nb">next</span><span class="p">,</span> <span class="n">goal</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">])</span>

<span class="nb">list</span><span class="p">(</span><span class="n">dfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'C'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">))</span> <span class="c1"># [['C', 'F'], ['C', 'A', 'B', 'E', 'F']]
</span></code></pre></div></div>

<h2 id="breadth-first-search">Breadth-First Search</h2>

<p>An alternative algorithm called Breadth-First search provides us with the ability to return the same results as DFS, but with the added guarantee of returning the shortest path first.
This algorithm is a little more tricky to implement in a recursive manner; instead, using the queue data structure is preferable, as such I will only be documenting the iterative approach.
The actions performed per each explored vertex are the same as the Depth-First implementation, however, replacing the stack with a queue will instead explore the breadth of a vertex’s depth before moving on.
This behaviour guarantees that the first path located is one of the shortest paths present, based on the number of edges being the cost factor.</p>

<h3 id="connected-component-1">Connected Component</h3>

<p>Similar to the iterative DFS implementation, the only alteration required is to remove the next item from the beginning of the list structure instead of the stack’s last item.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">):</span>
    <span class="n">visited</span><span class="p">,</span> <span class="n">queue</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(),</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="n">vertex</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">vertex</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
            <span class="n">visited</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">vertex</span><span class="p">)</span>
            <span class="n">queue</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">-</span> <span class="n">visited</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">visited</span>

<span class="n">bfs</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'A'</span><span class="p">)</span> <span class="c1"># {'B', 'C', 'A', 'F', 'D', 'E'}
</span></code></pre></div></div>

<h3 id="paths-1">Paths</h3>

<p>This implementation can again be altered slightly to instead return all possible paths between two vertices, the first of which is one of the shortest such paths.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">bfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="n">queue</span> <span class="o">=</span> <span class="p">[(</span><span class="n">start</span><span class="p">,</span> <span class="p">[</span><span class="n">start</span><span class="p">])]</span>
    <span class="k">while</span> <span class="n">queue</span><span class="p">:</span>
        <span class="p">(</span><span class="n">vertex</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span> <span class="o">=</span> <span class="n">queue</span><span class="p">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">next</span> <span class="ow">in</span> <span class="n">graph</span><span class="p">[</span><span class="n">vertex</span><span class="p">]</span> <span class="o">-</span> <span class="nb">set</span><span class="p">(</span><span class="n">path</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">next</span> <span class="o">==</span> <span class="n">goal</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">queue</span><span class="p">.</span><span class="n">append</span><span class="p">((</span><span class="nb">next</span><span class="p">,</span> <span class="n">path</span> <span class="o">+</span> <span class="p">[</span><span class="nb">next</span><span class="p">]))</span>

<span class="nb">list</span><span class="p">(</span><span class="n">bfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">))</span> <span class="c1"># [['A', 'C', 'F'], ['A', 'B', 'E', 'F']]
</span></code></pre></div></div>

<p>Knowing that the shortest path will be returned first from the BFS path generator method, we can create a useful method which simply returns the shortest path found, or ‘None’ if no path exists.
As we are using a generator, this in theory should provide similar performance results to just breaking out and returning the first matching path in the BFS implementation.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">def</span> <span class="nf">shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">next</span><span class="p">(</span><span class="n">bfs_paths</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">goal</span><span class="p">))</span>
    <span class="k">except</span> <span class="nb">StopIteration</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">None</span>

<span class="n">shortest_path</span><span class="p">(</span><span class="n">graph</span><span class="p">,</span> <span class="s">'A'</span><span class="p">,</span> <span class="s">'F'</span><span class="p">)</span> <span class="c1"># ['A', 'C', 'F']
</span></code></pre></div></div>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://jeremykun.com/2013/01/22/depth-and-breadth-first-search/">Depth-and Breadth-First Search</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Connected_component_(graph_theory)">Connected component</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Adjacency_matrix">Adjacency matrix</a></li>
  <li><a href="http://en.wikipedia.org/wiki/Adjacency_list">Adjacency list</a></li>
  <li><a href="http://developmentality.wordpress.com/2010/08/23/python-gotcha-default-arguments/">Python Gotcha: Default arguments and mutable data structures</a></li>
  <li><a href="http://legacy.python.org/dev/peps/pep-0380/">PEP 380</a></li>
  <li><a href="https://wiki.python.org/moin/Generators">Generators</a></li>
</ul>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
