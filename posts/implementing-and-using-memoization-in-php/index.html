<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Implementing and Using Memoization in PHP - Edd Mann</title>
<meta name=description content="Learn how to implement memoization in PHP with simple examples and recursive calls, improving performance through caching."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Implementing and Using Memoization in PHP"><meta itemprop=description content="Memoization is a simple optimisation technique to understand and, in most cases, implement. The base idea is to speed up function calls by avoiding the re-calculation of previously processed input results (very cache-like). Storing these results in a key-value lookup store can result in major speed increases when repetitive function calls occur."><meta itemprop=datePublished content="2014-01-13T00:00:00+00:00"><meta itemprop=dateModified content="2014-01-13T00:00:00+00:00"><meta itemprop=wordCount content="634"><meta itemprop=keywords content="Php"><meta property="og:url" content="https://eddmann.com/posts/implementing-and-using-memoization-in-php/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Implementing and Using Memoization in PHP"><meta property="og:description" content="Memoization is a simple optimisation technique to understand and, in most cases, implement. The base idea is to speed up function calls by avoiding the re-calculation of previously processed input results (very cache-like). Storing these results in a key-value lookup store can result in major speed increases when repetitive function calls occur."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-01-13T00:00:00+00:00"><meta property="article:modified_time" content="2014-01-13T00:00:00+00:00"><meta property="article:tag" content="Php"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing and Using Memoization in PHP"><meta name=twitter:description content="Memoization is a simple optimisation technique to understand and, in most cases, implement. The base idea is to speed up function calls by avoiding the re-calculation of previously processed input results (very cache-like). Storing these results in a key-value lookup store can result in major speed increases when repetitive function calls occur."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6349357a7c7c5fccfe48c11ed795a2d71fd809d82eefa5bc95dddd1002c18057.css integrity="sha256-Y0k1enx8X8z+SMEe15Wi1x/YCdgu76W8ld3dEALBgFc="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/implementing-and-using-memoization-in-php/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Implementing and Using Memoization in PHP</h1><time class=post__time>Jan 13, 2014</time></header><main class=prose><p>Memoization is a simple optimisation technique to understand and, in most cases, implement.
The base idea is to speed up function calls by avoiding the re-calculation of previously processed input results (very cache-like).
Storing these results in a key-value lookup store can result in major speed increases when repetitive function calls occur.</p><p><a href=http://en.wikipedia.org/wiki/Dynamic_programming rel="external noopener" target=_blank>Dynamic programming</a> algorithms such as the <a href=http://en.wikipedia.org/wiki/Knapsack_problem rel="external noopener" target=_blank>Knapsack problem</a> benefit greatly from using this technique.
However, the trade-off is that due to its caching underpinnings, functions with side-effects and reliance on external factors such as the current time may return incorrect results.
I have spent some time looking into languages such as <a href=http://groovy.codehaus.org/ rel="external noopener" target=_blank>Groovy</a> which include this <a href=http://mrhaki.blogspot.co.uk/2011/05/groovy-goodness-cache-closure-results.html rel="external noopener" target=_blank>functionality</a> out of the box, and I wished to see if it was possible to create an implementation in PHP.
Further research found <a href=http://github.com/arraypad/php-memoize rel="external noopener" target=_blank>php-memoize</a> which looks like a great C module, showing promise in implementing the concept at a language library level.
Although I am impressed with the discussed module, I wished to see if it was possible to create an implementation in PHP userspace.</p><h2 id=implementation>Implementation</h2><p>Below depicts a simple example implementation of a memoization function which takes advantage of PHP&rsquo;s first-class function support.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$memoize <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>($func)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() <span style=color:#66d9ef>use</span> ($func)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>static</span> $cache <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        $args <span style=color:#f92672>=</span> <span style=color:#a6e22e>func_get_args</span>();
</span></span><span style=display:flex><span>        $key <span style=color:#f92672>=</span> <span style=color:#a6e22e>md5</span>(<span style=color:#a6e22e>serialize</span>($args));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ( <span style=color:#f92672>!</span> <span style=color:#a6e22e>isset</span>($cache[$key])) {
</span></span><span style=display:flex><span>            $cache[$key] <span style=color:#f92672>=</span> <span style=color:#a6e22e>call_user_func_array</span>($func, $args);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $cache[$key];
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>Using a static <code>$cache</code> array allows us to keep a persistent lookup table between calls of the returned function.
In conjunction with this, hashing the serialised arguments array allows us to create a unique key we can set and lookup in the associative array per call.
The method supports either anonymous or string-identified functions, using the <code>call_user_func_array</code> method.</p><h2 id=profiling>Profiling</h2><p>Now that we have an implementation, it is time to benchmark its performance, to see the resulting gains.
Below is a simple function which prints out the time duration taken for the supplied function to run.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$timer <span style=color:#f92672>=</span> <span style=color:#66d9ef>function</span>($func)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>function</span>() <span style=color:#66d9ef>use</span> ($func)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        $start <span style=color:#f92672>=</span> <span style=color:#a6e22e>microtime</span>(<span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>        $result <span style=color:#f92672>=</span> <span style=color:#a6e22e>call_user_func_array</span>($func, <span style=color:#a6e22e>func_get_args</span>());
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>echo</span> <span style=color:#a6e22e>sprintf</span>(<span style=color:#e6db74>&#34;%f</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#a6e22e>microtime</span>(<span style=color:#66d9ef>true</span>) <span style=color:#f92672>-</span> $start);
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $result;
</span></span><span style=display:flex><span>    };
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>We can now use the above function to benchmark the performance of the <code>sleepz</code> function declared below.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>sleepz</span>($time)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sleep</span>($time);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$sleepz <span style=color:#f92672>=</span> $timer(<span style=color:#e6db74>&#39;sleepz&#39;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// No Memoize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>$sleepz(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1.001020
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>$sleepz <span style=color:#f92672>=</span> $timer($memoize(<span style=color:#e6db74>&#39;sleepz&#39;</span>));
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 1st Memoize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>$sleepz(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 1.001016
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 2nd Memoize
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>$sleepz(<span style=color:#ae81ff>1</span>); <span style=color:#75715e>// 0.000028
</span></span></span></code></pre></div><p>As you can deduce from the output, the second call to the memoized function is significantly quicker than the first.
Comparing the non-memoized and first memoized function calls results in very similar time durations, as they are doing the same work.
Once the function call result has been stored in the memoized cache, the second call simply needs to look up the result and return the contents.
At an API level, this call looks the same as any other, but thanks to the cache, performance gains occur.</p><h2 id=recursive-calls>Recursive Calls</h2><p>One issue that appears when you spend a little time with the above implementation is recursive function calls.
Unlike in other languages, this high-level implementation is unable to rewrite internal function calls.
However, to get around this, we are able to use PHP&rsquo;s first-class function support.
Declaring the use of a reference to the function assignment variable successfully allows us to recursively call the memoized implementation.
This detail now requires the code logic to be present in an anonymous function.
As this is a thought exercise rather than a production-ready implementation, I am happy with the capabilities currently available in the language.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$factorial <span style=color:#f92672>=</span> $memoize(<span style=color:#66d9ef>function</span>($n) <span style=color:#66d9ef>use</span> (<span style=color:#f92672>&amp;</span>$factorial)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ($n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> <span style=color:#ae81ff>1</span> <span style=color:#f92672>:</span> $n <span style=color:#f92672>*</span> $factorial($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$fibonacci <span style=color:#f92672>=</span> $memoize(<span style=color:#66d9ef>function</span>($n) <span style=color:#66d9ef>use</span> (<span style=color:#f92672>&amp;</span>$fibonacci)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> ($n <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#f92672>?</span> $n <span style=color:#f92672>:</span> $fibonacci($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>) <span style=color:#f92672>+</span> $fibonacci($n <span style=color:#f92672>-</span> <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>});
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>$factorial(<span style=color:#ae81ff>10</span>); <span style=color:#75715e>// 3628800
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>$fibonacci(<span style=color:#ae81ff>10</span>); <span style=color:#75715e>// 55
</span></span></span></code></pre></div><h2 id=resources>Resources</h2><ul><li><a href=http://en.wikipedia.org/wiki/Memoization rel="external noopener" target=_blank>Memoization</a></li><li><a href=http://en.wikipedia.org/wiki/Dynamic_programming rel="external noopener" target=_blank>Dynamic programming</a></li><li><a href=http://github.com/arraypad/php-memoize rel="external noopener" target=_blank>php-memoize</a></li></ul></main><footer class=post__tags><a href=/archive/tag/php>php</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>