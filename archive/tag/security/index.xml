<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Security on Edd Mann</title><link>https://eddmann.com/archive/tag/security/</link><description>Recent content in Security on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Tue, 26 Jun 2018 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/security/index.xml" rel="self" type="application/rss+xml"/><item><title>Mince Pie Challenge: Authentication with Amazon Cognito and JSON Web Tokens</title><link>https://eddmann.com/posts/mince-pie-challenge-authentication-with-amazon-cognito-and-json-web-tokens/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-authentication-with-amazon-cognito-and-json-web-tokens/</guid><description>&lt;p>Now that we have set up the Serverless Framework, we can go about investigating how Authentication and Authorisation will be handled within the application.
For this, we will be using &lt;a href="https://aws.amazon.com/cognito/" rel="external noopener" target="_blank">Amazon Cognito&lt;/a>, a fully managed web service which handles the user sign-up, sign-in and management processes.&lt;/p></description></item><item><title>Unlocking the AWS WAF Logs</title><link>https://eddmann.com/posts/unlocking-the-aws-waf-logs/</link><pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/unlocking-the-aws-waf-logs/</guid><description>&lt;p>In this post we discuss our recent move to route all requests through &lt;a href="https://aws.amazon.com/cloudfront/" rel="external noopener" target="_blank">CloudFront&lt;/a>.
This allows us to parse all traffic through the &lt;a href="https://aws.amazon.com/waf/" rel="external noopener" target="_blank">AWS Web Application Firewall&lt;/a> (WAF).
We highlight the reasoning behind this change, and some issues and remedies encountered when trying to garner concrete logs from the WAF instance.&lt;/p></description></item><item><title>Securing Sessions in PHP</title><link>https://eddmann.com/posts/securing-sessions-in-php/</link><pubDate>Wed, 09 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/securing-sessions-in-php/</guid><description>&lt;p>Following on from my previous post on &lt;a href="https://eddmann.com/posts/self-signed-ssl-certificates-with-nginx-and-apache/">Self-signed SSL certificates&lt;/a>, I would now like to address the second most common Web application vulnerability (&lt;a href="https://www.owasp.org/index.php/Top_10_2013-A2-Broken_Authentication_and_Session_Management" rel="external noopener" target="_blank">Broken Authentication and Session Management&lt;/a>).
When delving into the subject I was unable to find a definitive resource for a PHP implementation.
Due to this, I set out to combine all the best practice I could find into a single session handler, to help protect against the common attack vectors.
Since PHP 5.4, you are able to set the session handler based on a class instance that extends the default &lt;code>SessionHandler&lt;/code> class.&lt;/p></description></item><item><title>PHPass, the go-to password hashing library</title><link>https://eddmann.com/posts/phpass-the-go-to-password-hashing-library/</link><pubDate>Thu, 28 Jun 2012 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/phpass-the-go-to-password-hashing-library/</guid><description>&lt;p>It is becoming a scarily common occurrence to read about &lt;a href="http://www.guardian.co.uk/technology/us-news-blog/2012/jun/07/blogpost-eharmony-linkedin-hacked-leaked" rel="external noopener" target="_blank">yet&lt;/a> &lt;a href="http://www.bbc.co.uk/news/technology-18338956" rel="external noopener" target="_blank">another&lt;/a> &lt;a href="http://www.pcworld.com/article/257178/music_site_lastfm_joins_the_passwordleak_parade.html" rel="external noopener" target="_blank">batch&lt;/a> of high-profile websites&amp;rsquo; users&amp;rsquo; passwords being leaked online - for everyone&amp;rsquo;s cracking pleasure.
What&amp;rsquo;s even more shocking is how poorly these sites are storing them.
In the case of LinkedIn, it turned out that they had stored them as unsalted, plain MD5 hashes, which any Joe Bloggs could easily crack using a rainbow table.
The tried and tested means of storing passwords in today&amp;rsquo;s web applications is to create a hash from the user&amp;rsquo;s input, and then compare any attempted authentication with this stored value.
The trouble and confusion arise, however, in how to actually achieve this, as there are so many incorrect methods available.&lt;/p></description></item></channel></rss>