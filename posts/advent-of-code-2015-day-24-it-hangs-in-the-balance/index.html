<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Solving the Advent of Code 2015 Day 24 puzzle using TypeScript.">

    <title>
        
            Advent of Code 2015 - Day 24 - It Hangs in the Balance &middot; Edd Mann
        
    </title>

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script>
    <script>
       window.dataLayer = window.dataLayer || [];
       function gtag(){dataLayer.push(arguments);}
       gtag('js', new Date());
       gtag('config', 'G-ZPQ7WHNXH4');
    </script>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Advent of Code 2015 - Day 24 - It Hangs in the Balance</h1>
    <time datetime="2021-02-19T00:00:00+00:00" class="post-date">19 Feb 2021</time>
    <p>On the twenty-fourth day of Advent of Code 2015, we are asked to help Santa balance his sleigh based on all the presents he has to carry.</p>



<h2 id="part-1">Part 1</h2>

<p>We are told that the presents need to be evenly divided into three groups based on their weight (which is provided as input).
Along with this, we are required to ensure that the first grouping (which goes in the passenger compartment of the sleigh) includes the minimal number of packages possible.
To resolve conflicts when multiple package combinations meet the first groupingâ€™s criteria, we consider the grouping with the smallest <em>quantum entanglement</em> (i.e. the product of their weights) to be the winner.
For part one, we need to determine what the <em>quantum entanglement</em> of the first group will be based on these criteria.</p>

<p>To begin, we will parse the provided package weights into a form we can process henceforth.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Weight</span> <span class="o">=</span> <span class="kr">number</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">parsePackageWeights</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="nx">Weight</span><span class="p">[]</span> <span class="o">=&gt;</span>
  <span class="nx">input</span><span class="p">.</span><span class="nx">split</span><span class="p">(</span><span class="dl">'</span><span class="se">\n</span><span class="dl">'</span><span class="p">).</span><span class="nx">map</span><span class="p">(</span><span class="nx">toInt</span><span class="p">);</span>
</code></pre></div></div>

<p>From here, we will create a function that, based on a given total weight and available packages, yields all the possible matching groups.
This function will return groupings in size order.
For example, all groupings of two will be yielded before any groups of three are considered (this is important for the final solution).</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">type</span> <span class="nx">Group</span> <span class="o">=</span> <span class="nx">Weight</span><span class="p">[];</span>

<span class="kd">const</span> <span class="nx">groupsOfWeight</span> <span class="o">=</span> <span class="kd">function</span><span class="o">*</span> <span class="p">(</span>
  <span class="nx">packages</span><span class="p">:</span> <span class="nx">Weight</span><span class="p">[],</span>
  <span class="nx">weightPerGroup</span><span class="p">:</span> <span class="nx">Weight</span>
<span class="p">):</span> <span class="nx">Generator</span><span class="o">&lt;</span><span class="nx">Group</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kd">let</span> <span class="nx">groupSize</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">groupSize</span> <span class="o">&lt;=</span> <span class="nx">packages</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span> <span class="nx">groupSize</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">group</span> <span class="k">of</span> <span class="nx">combinations</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">groupSize</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="nx">group</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">===</span> <span class="nx">weightPerGroup</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">yield</span> <span class="nx">group</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

<p>With the ability to determine valid package groupings, we will create a function that recursively validates whether, based on a supplied total group weight and available packages, the required number of groups can be met.
This will ensure that once we have determined a candidate compartment package grouping, the remaining packages can be evenly distributed within the other groupings.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">sub</span> <span class="o">=</span> <span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span><span class="nx">xs</span><span class="p">:</span> <span class="nx">T</span><span class="p">[],</span> <span class="nx">ys</span><span class="p">:</span> <span class="nx">T</span><span class="p">[])</span> <span class="o">=&gt;</span> <span class="nx">xs</span><span class="p">.</span><span class="nx">filter</span><span class="p">(</span><span class="nx">x</span> <span class="o">=&gt;</span> <span class="o">!</span><span class="nx">ys</span><span class="p">.</span><span class="nx">includes</span><span class="p">(</span><span class="nx">x</span><span class="p">));</span>

<span class="kd">const</span> <span class="nx">canGroup</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">packages</span><span class="p">:</span> <span class="nx">Weight</span><span class="p">[],</span>
  <span class="nx">numOfGroups</span><span class="p">:</span> <span class="kr">number</span><span class="p">,</span>
  <span class="nx">weightPerGroup</span><span class="p">:</span> <span class="nx">Weight</span>
<span class="p">):</span> <span class="nx">boolean</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="nx">numOfGroups</span> <span class="o">===</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nx">packages</span><span class="p">.</span><span class="nx">length</span> <span class="o">===</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">group</span> <span class="k">of</span> <span class="nx">groupsOfWeight</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">weightPerGroup</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">canGroup</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">group</span><span class="p">),</span> <span class="nx">numOfGroups</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">weightPerGroup</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>This now allows us to determine what the <em>ideal</em> first grouping will be.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">idealFirstGroupQE</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">packages</span><span class="p">:</span> <span class="nx">Weight</span><span class="p">[],</span>
  <span class="nx">numOfGroups</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">weightPerGroup</span> <span class="o">=</span> <span class="nx">packages</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nx">numOfGroups</span><span class="p">;</span>

  <span class="kd">let</span> <span class="nx">minQE</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>
  <span class="kd">let</span> <span class="nx">prevGroupSize</span> <span class="o">=</span> <span class="kc">Infinity</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">group</span> <span class="k">of</span> <span class="nx">groupsOfWeight</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">weightPerGroup</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nx">minQE</span> <span class="o">!==</span> <span class="kc">Infinity</span> <span class="o">&amp;&amp;</span> <span class="nx">prevGroupSize</span> <span class="o">&lt;</span> <span class="nx">group</span><span class="p">.</span><span class="nx">length</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>

    <span class="kd">const</span> <span class="nx">candidateQE</span> <span class="o">=</span> <span class="nx">group</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span>
      <span class="nx">candidateQE</span> <span class="o">&lt;</span> <span class="nx">minQE</span> <span class="o">&amp;&amp;</span>
      <span class="nx">canGroup</span><span class="p">(</span><span class="nx">sub</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">group</span><span class="p">),</span> <span class="nx">numOfGroups</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nx">weightPerGroup</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
      <span class="nx">minQE</span> <span class="o">=</span> <span class="nx">candidateQE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="nx">prevGroupSize</span> <span class="o">=</span> <span class="nx">group</span><span class="p">.</span><span class="nx">length</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nx">minQE</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Using the characteristics discussed above regarding the yielded package grouping sizes, we first determine what the <em>weight per group</em> needs to be.
From here, we iterate through possible groupings, checking whether the remaining available packages can be evenly distributed into the other groups.
To avoid needless checks, we only perform this validation if the groupingâ€™s <em>quantum entanglement</em> is less than the one we have already recorded.
Once we find a minimum <em>quantum entanglement</em> and the yielded group size increases, we can determine that this is the smallest possible value.</p>

<p>Finally, we put all these building blocks together to return the desired answer we are looking for ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part1</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span>
  <span class="nx">idealFirstGroupQE</span><span class="p">(</span><span class="nx">parsePackageWeights</span><span class="p">(</span><span class="nx">input</span><span class="p">),</span> <span class="mi">3</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="part-2">Part 2</h2>

<p>For part two, we need to cater for an additional package grouping (four groupings instead of the original three).
Based on how our solution has been modelled, we can simply supply an updated <code class="language-plaintext highlighter-rouge">numOfGroups</code> and return this revised value ðŸŒŸ.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">part2</span> <span class="o">=</span> <span class="p">(</span><span class="nx">input</span><span class="p">:</span> <span class="kr">string</span><span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span>
  <span class="nx">idealFirstGroupQE</span><span class="p">(</span><span class="nx">parsePackageWeights</span><span class="p">(</span><span class="nx">input</span><span class="p">),</span> <span class="mi">4</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="alternative-solution">Alternative Solution</h2>

<p>The solution above provides a <em>belt and braces</em> approach to handling the provided package weight input.
It considers all possible combinations based on a given group size while ensuring that the remaining packages can also be grouped correctly.
However, through experimentation with the input, I discovered an additional solution that returns the correct answers without needing this additional validation.</p>

<p>Based on the provided input, we do not need to consider the above concerns and can instead return the first grouping we encounter.
This approach yields the correct answer for both parts.
However, since it takes advantage of the specific input (rather than handling any arbitrary input), I do not believe it is a desirable solution.</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">idealFirstGroupQE</span> <span class="o">=</span> <span class="p">(</span>
  <span class="nx">packages</span><span class="p">:</span> <span class="nx">Weight</span><span class="p">[],</span>
  <span class="nx">numOfGroups</span><span class="p">:</span> <span class="kr">number</span>
<span class="p">):</span> <span class="kr">number</span> <span class="o">=&gt;</span> <span class="p">{</span>
  <span class="kd">const</span> <span class="nx">weightPerGroup</span> <span class="o">=</span> <span class="nx">packages</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">sum</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="nx">numOfGroups</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kd">const</span> <span class="nx">group</span> <span class="k">of</span> <span class="nx">groupsOfWeight</span><span class="p">(</span><span class="nx">packages</span><span class="p">,</span> <span class="nx">weightPerGroup</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nx">group</span><span class="p">.</span><span class="nx">reduce</span><span class="p">(</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
</code></pre></div></div>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
