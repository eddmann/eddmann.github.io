<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Solving the Advent of Code 2022 calendar using my own programming language, santa-lang - Edd Mann</title>
<meta name=description content="Discover how I tackled the Advent of Code 2022 calendar using my own programming language, santa-lang - detailing its strengths, challenges, and improvements made along the way."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Solving the Advent of Code 2022 calendar using my own programming language, santa-lang"><meta itemprop=description content="December has come and gone, and the dust has settled on completing the Advent of Code 2022 calendar. As highlighted in my previous post, I wanted to complete this yearâ€™s puzzles using my own programming language, santa-lang, which I have tailored to help aid in solving such problems. In this post, I want to discuss this experience, how the language aided in solution development, and where additions or changes were made to improve it along the way."><meta itemprop=datePublished content="2023-01-28T00:00:00+00:00"><meta itemprop=dateModified content="2023-01-28T00:00:00+00:00"><meta itemprop=wordCount content="3712"><meta itemprop=keywords content="Advent-of-Code,Santa-Lang"><meta property="og:url" content="https://eddmann.com/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Solving the Advent of Code 2022 calendar using my own programming language, santa-lang"><meta property="og:description" content="December has come and gone, and the dust has settled on completing the Advent of Code 2022 calendar. As highlighted in my previous post, I wanted to complete this yearâ€™s puzzles using my own programming language, santa-lang, which I have tailored to help aid in solving such problems. In this post, I want to discuss this experience, how the language aided in solution development, and where additions or changes were made to improve it along the way."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-01-28T00:00:00+00:00"><meta property="article:modified_time" content="2023-01-28T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Santa-Lang"><meta name=twitter:card content="summary"><meta name=twitter:title content="Solving the Advent of Code 2022 calendar using my own programming language, santa-lang"><meta name=twitter:description content="December has come and gone, and the dust has settled on completing the Advent of Code 2022 calendar. As highlighted in my previous post, I wanted to complete this yearâ€™s puzzles using my own programming language, santa-lang, which I have tailored to help aid in solving such problems. In this post, I want to discuss this experience, how the language aided in solution development, and where additions or changes were made to improve it along the way."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Solving the Advent of Code 2022 calendar using my own programming language, santa-lang</h1><time class=post__time>Jan 28, 2023</time></header><main class=prose><p>December has come and gone, and the dust has settled on completing the Advent of Code 2022 calendar.
As highlighted in my <a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/>previous post</a>, I wanted to complete this year&rsquo;s puzzles using my own programming language, santa-lang, which I have tailored to help aid in solving such problems.
In this post, I want to discuss this experience, how the language aided in solution development, and where additions or changes were made to improve it along the way.</p><h2 id=where-we-left-off>Where We Left Off</h2><p>The design of the language had been formed based on my previous experience in solving <a href=https://github.com/eddmann/advent-of-code rel="external noopener" target=_blank>several years&rsquo; worth</a> of Advent of Code calendars in multiple different languages.
During the development phase, I had employed regular checkpoints to re-solve previous calendar puzzles in santa-lang to validate the path I was taking.
The 2022 calendar would be the first set of unknown puzzles that the language would have faced.
More so, it would be the first time primarily using the language to solve these puzzles.
I was initially wary of not being capable of completing each day in the language, perhaps even having to resort to another one.</p><p>Fortunately, this was not the case, and the <em>TL;DR</em> of this post would be that I was able to successfully implement each puzzle solution using santa-lang as my primary language ðŸŽ‰.
Throughout the calendar, I made a conscious effort to note down interesting aspects of the experience, which I have since categorised and wish to present below.</p><h2 id=the-journey>The Journey</h2><p>As an aside, no discussion of the Advent of Code 2022 calendar would be complete without sharing my <a href=https://www.reddit.com/r/adventofcode/comments/zsct8w/comment/j17pijh/ rel="external noopener" target=_blank>day 22 cube</a>!</p><p><picture><source type=image/webp srcset="/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_db4f866b78722630.webp 350w, /posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_1caebc93c4eb83ee.webp 700w, /posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_609d4580be1f3697.webp 1400w"><source type=image/jpeg srcset="/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_a9be791060a13c43.jpg 350w, /posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_bb1560f545c766e8.jpg 700w, /posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_58217b3b9cb1c2bf.jpg 1400w"><img src=/posts/solving-the-advent-of-code-2022-calendar-using-my-own-programming-language-santa-lang/day22-cube_hu_bb1560f545c766e8.jpg alt="Day 22 Cube" loading=lazy></picture></p><p>Now that is out of the way, we can begin&mldr;</p><h3 id=running-with-the-runner>Running with the Runner</h3><p>Most of this post&rsquo;s discussion will no doubt be centred around the language and standard library.
Upon reviewing my notes, I realised that I had not given much thought towards <a href=/posts/designing-santa-lang-a-language-for-solving-advent-of-code-puzzles/#the-aoc-runner>the runner</a> itself ðŸ˜¢.
In hindsight, I think the reason for this was probably the biggest compliment I could give - it just worked!
I spent the majority of my time using the CLI runtime, and with the combination of the test runner and in-built means of downloading the puzzle input, I was able to get <em>up n&rsquo; problem-solving</em> very quickly each day.
The <em>REPL</em> developed over the course of the calendar, from developing each part&rsquo;s solution to validating both the test and puzzle input, was a frictionless experience.
As a consequence, I did not need to revise it, which, in turn, meant I did not write many notes about it.
It is for this reason that I want to highlight this success first!</p><h3 id=sometimes-you-need-mutation>Sometimes You Need Mutation</h3><p>One of the design goals for the language was - <em>No mutation, opting for readability and correctness over outright speed</em>.
Throughout the course of completing the calendar, there arose certain situations where readability would be negatively impacted if I did not employ some form of mutation ðŸ˜±.
This need was only directed at the ability to re-define <code>let</code> bindings, as opposed to providing a means to mutate data structures.
I did go back and forth on the idea of including such a feature, balancing the purity of the language over its practical nature to help solve puzzles.
I ended up being reassured, however, based on how Clojure handles <a href=https://clojure.org/reference/transients rel="external noopener" target=_blank>transient data structures</a>.</p><blockquote><p>If a tree falls in the woods, does it make a sound? If a pure function mutates some local data in order to produce an immutable return value, is that ok?</p></blockquote><p>Mutation as a whole is not a <em>bad thing</em>; in fact, it is an incredibly useful tool.
Although this statement is directed at data structures, the rationale that location and scope play a significant role in its viability is very apt.
Typically, concerns with mutation arise when its use occurs (often implicitly) across a large scope.
As such, if we keep the mutation scope small, we can harness the benefits it gives us without being hindered by the negatives.</p><p>One such example of its use was in solving <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day19.santa rel="external noopener" target=_blank>day 19</a> while employing the <a href=https://en.wikipedia.org/wiki/Branch_and_bound rel="external noopener" target=_blank>Branch and Bound</a> algorithm design paradigm.</p><pre tabindex=0><code>let collect_max_geodes = |minutes, blueprint| {
  let mut max_geodes = 0;

  let recur = |state| {
    max_geodes = max(max_geodes, state[&#34;geodes&#34;]);
    next_robot_states(blueprint, state)
      |&gt; filter(|next_state| estimate_geode_collection(blueprint, next_state) &gt; max_geodes)
      |&gt; each(recur);
  };

  // ..

  max_geodes;
}
</code></pre><p>You can see that the mutable <code>let</code> binding is local (co-located) to the pure function in which it resides.
It has a very small, focused scope, which only spans several lines of code and aids in the overall readability of the solution.</p><p>Another important consideration I made when deciding to add this feature to the language was to ensure that its intent was explicit.
In contrast to C-like languages of the past, I favoured immutability by default and explicitly (using the <code>mut</code> keyword) <em>&lsquo;opted in&rsquo;</em> to mutation.
This helps instruct the reader that its use is a <em>special case</em> and different from the conventional immutable behaviour.</p><p>Finally, I feel like a saying that comes up in the Python world a lot - <em><a href=https://docs.python-guide.org/writing/style/#we-are-all-responsible-users rel="external noopener" target=_blank>&lsquo;We are all responsible users&rsquo;</a></em> - is a compelling point to reflect upon.
A language is a tool, with certain syntax and runtime-level guardrails devised to assist in solving problems.
But at the end of the day, it is up to the code author to be responsible with the functionality that is available to them.
Any language, no matter how <em>strict</em> or <em>pure</em>, can be abused if the code author does not make responsible choices.</p><h3 id=recursion-over-stateful-loops>Recursion Over Stateful Loops</h3><p>As I had intentionally omitted standard loop constructs (<code>for</code>, <code>while</code>) from the language (which are inherently mutable), I found myself leaning heavily on recursion to provide the same means to an end.
The calendar had many maze puzzles, in which we were required to find (in varying masqueraded forms) the <em>shortest path</em> between two states; this meant employing the <a href=https://en.wikipedia.org/wiki/Breadth-first_search rel="external noopener" target=_blank>breadth-first search</a> (BFS) algorithm.
Unlike <a href=https://en.wikipedia.org/wiki/Depth-first_search rel="external noopener" target=_blank>depth-first search</a> (DFS), which is inherently recursive by nature (taking advantage of call stack properties), BFS <em>work</em> is stored in a FIFO queue.
Below is a snippet of my <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day24.santa rel="external noopener" target=_blank>day 24</a> solution, which documents the key characteristics of the BFS algorithm and how recursion is used as a looping construct.</p><pre tabindex=0><code>let recur = |queue, seen| {
  let [time, position] = first(queue);

  if position == end {
    return time;
  }

  let next_positions = [[0, 1], [0, -1], [-1, 0], [1, 0], [0, 0]]
    // ..
    |&gt; map(|bounded_position| [time + 1, bounded_position])
    |&gt; filter(|next_position| seen `excludes?` next_position);

  recur(
    rest(queue) + next_positions,
    seen + next_positions
  );
};

recur([[initial_time, start]], {});
</code></pre><p><strong>Note:</strong> I have been lazy within this implementation and excluded the base case that the queue is empty, assuming that the algorithm will eventually find the end position before exhausting the queue.</p><p>As you can see, this follows what you would typically see in a conventional looping implementation.
We dequeue an item, check if it matches our desired end state, find the next unseen items to be visited, and repeat.</p><p>While developing the initial solution using this algorithm (<a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day12.santa rel="external noopener" target=_blank>day 12</a>), I encountered a <code>Maximum call stack size exceeded</code> exception in the host language (JavaScript) when running it on a sufficiently large input set.
This introduced me to the world of <em>tail-call optimisation</em>, which can be defined as:</p><blockquote><p>Tail-call optimisation is where you are able to avoid allocating a new stack frame for a function because the calling function will simply return the value that it gets from the called function.
The most common use is tail recursion, where a recursive function written to take advantage of tail-call optimisation can use constant stack space.</p></blockquote><p>Looking at the BFS implementation above, you can see this follows the described pattern, in which we are doing no other work within the current stack frame before returning the recursive invocation.
As such, we can optimally reuse the same stack frame for the next recursive call without incurring any performance penalty.
It was here that I put aside my calendar solution and headed to the language evaluator to implement <em>tail-call optimisation</em>.
This was a lot of fun to do, and it highlighted how the evaluator itself could be improved to help significantly speed up the code written in the subject language without any modification.</p><h3 id=functions-functions-functions>Functions, Functions, Functions</h3><p>When reviewing my notes, one topic I knew I could not miss was touching upon the desired goal of having <em>cheap functions</em>.
Opting for a syntax similar to how Rust defines functions was an ideal choice.
The syntax itself is lightweight and readable, which in turn makes it <em>cheap</em> to use.
An example of this would be defining the identity function like so: <code>|a| a</code>.</p><p>I did not know how much traction infix function invocation would get throughout the course of the calendar.
Turns out, I used it a lot!
Although you have the option to invoke functions like <code>vec_add(a, b)</code>, some expressions are more readable in infix form, like <code>a `vec_add` b</code>.
The ability to do this with user-land/standard library functions and not only special operators was especially powerful.</p><p>Placeholder syntax is something I had been introduced to through Scala several years back and had greatly enjoyed.
This functionality gave the ability to succinctly express the <em>open</em> argument positions.
For example, combined with infix function invocation: <code>includes?(collection)</code> vs <code>collection `includes?` _</code>, or <code>_ `includes?` 2</code>.
Additionally, I was able to use placeholder arguments within conventional function calls like <code>get(_, collection)</code>, when it improved readability.
This syntax is very concise and feels more like a custom DSL for the given puzzle problem as opposed to a function definition.</p><p>With the formation of these <em>cheap functions</em>, I was subsequently able to compose <code>>></code> and thread <code>|></code> them together to complete the puzzle problem at hand.
Again, I was unsure how much usage function composition would get, as the puzzles were very specific.
However, I was able to treat much of the standard library as building blocks for <em>cheaply</em> composing higher-level functionality.
This can be seen many times throughout the course of the calendar, especially when parsing the puzzle input.</p><pre tabindex=0><code>// aoc2022_day01.santa
let parse_inventories = split(&#34;\n\n&#34;) &gt;&gt; map(ints &gt;&gt; sum);

// aoc2022_day20.santa
let parse_numbers = |decryption_key| {
  ints &gt;&gt; map(_ * decryption_key) &gt;&gt; zip(0.., _);
}
</code></pre><p>Finally, function threading was something introduced to me by Clojure whilst solving the <a href=https://github.com/eddmann/advent-of-code/tree/master/2020/clojure rel="external noopener" target=_blank>2020 calendar</a>, and I relied heavily on it in this calendar too.
It is pure syntactic sugar over nested function invocations, but the conciseness and readability benefits it adds are undeniable.
I could show many, many examples of its use, but one place where it played a key role was in solving <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day24.santa rel="external noopener" target=_blank>day 24</a>.</p><pre tabindex=0><code>// ..
let trip = travel(blizzards, boundary);
trip(start, end, 0) |&gt; trip(end, start) |&gt; trip(start, end);
</code></pre><p>Threading combined with partial application provided a crisp means in which to define the problem&rsquo;s intent - <em>travelling</em> from the start to the end, back to the start, and then finally to the end again.</p><h3 id=dont-sleep-on-lazy-sequences>Don&rsquo;t Sleep on Lazy Sequences</h3><p>Lazy sequences allow you to express a class of problems very succinctly.
I had included the concept of infinite lazy ranges (<code>1..</code>) in the initial language design, but a pattern soon emerged where I wished to perform some form of operation multiple times (dependent on the previous output) and compute the <em>nth-term</em>.
It was for this that I decided to add the <code>iterate</code> function to the language, inspired by Clojure&rsquo;s <a href=https://clojuredocs.org/clojure.core/iterate rel="external noopener" target=_blank>implementation</a> of the same name.
Defining a <a href=https://en.wikipedia.org/wiki/Referential_transparency rel="external noopener" target=_blank>referentially transparent</a> function (input and output) for handling a single operation, we can supply this to <em>iterate</em> and expand it to however many <em>iterations</em> we wish to achieve, either until a certain <em>nth-term</em> (<code>get</code>) or a term predicate holds true (<code>find</code>).
Its use is documented widely throughout the calendar, none more so than in <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day09.santa rel="external noopener" target=_blank>day 9</a>.
Here we were required to perform a single <code>knot_tail</code> operation in part 1 and then expand upon this to find the <em>9th term</em> in part 2.</p><pre tabindex=0><code>part_one: {
  parse_motions(input)
    |&gt; knot_head
    |&gt; knot_tail
    |&gt; visits;
}

part_two: {
  parse_motions(input)
    |&gt; knot_head
    |&gt; iterate(knot_tail)
    |&gt; get(9)
    |&gt; visits;
}
</code></pre><p>In <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day14.santa rel="external noopener" target=_blank>day 14</a>, we were asked to apply a <em>pour</em> operation until some predicate held true based on the current term (in this case <code>sand</code>).</p><pre tabindex=0><code>part_one: {
  // ..
  iterate(pour(top, rock + void), {})
    |&gt; find(|sand| lowest_height(sand) == lowest_height(rock))
}

part_two: {
  // ..
  iterate(pour(top, rock + floor), {})
    |&gt; find(_ `includes?` top)
}
</code></pre><p>Another form of lazy sequence that was added during the month was <code>cycle</code>.
There were several problems that required <em>cycling</em> through a defined finite list.
In a typical stateful implementation, you would pass along the list and current index, which is subsequently <em>modulo</em> to cycle back through the list upon exhaustion.
Employing <code>cycle</code>, however, abstracts away these requirements, whereby we can use conventional <code>first</code>/<code>rest</code> collection primitives to consume the list as we desire.
Below is one such use case in <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day17.santa rel="external noopener" target=_blank>day 17</a>, where we were required to perform a Tetris-style simulation based on rock/jet patterns.</p><pre tabindex=0><code>let parse_jet_pattern = split(&#34;&#34;) &gt;&gt; map(|d| if d == &#34;&lt;&#34; { [0, -1] } else { [0, 1] }) &gt;&gt; cycle;
</code></pre><h3 id=removing-boilerplate-with-sequence-transformations>Removing Boilerplate with Sequence Transformations</h3><p>One aspect of the initial language design phase was the importance of <code>map</code>, <code>filter</code>, <code>fold</code>, and <code>reduce</code> to transform sequences due to the omission of typical stateful looping constructs.
I rely heavily on these primitives in daily development, and how they abstract away boilerplate code and the intricacies of looping and branching into commonly agreed/understood behaviours.
The ability to perform such transformations over both finite and infinite sequences was very useful.</p><p>Whilst working my way through the calendar, I noticed several transformation patterns that later were distilled down into their own constructs.
The first was the concept of <em>mapping</em> and then immediately <em>filtering</em> over the transformed collection.
Instead of having to chain these two operations together, I took inspiration from Rust and added a <code>filter_map</code> function, which includes <em>truthy</em> mapped values in the resulting sequence.
This again can be seen in my <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day17.santa rel="external noopener" target=_blank>day 17</a> solution, which required us to find a state cycle within the Tetris-style simulation.</p><pre tabindex=0><code>let cycle_state = iterate(drop_rock, [jets, rocks, {}])
  |&gt; filter_map(cycle_detector())
  |&gt; first;
</code></pre><p>In a similar manner, I noticed that I used <em>map</em> and then immediately <em>find</em> in several solutions.
This too was more succinctly written as <code>find_map</code> (again found in Rust), which performed the combination of the two.
Use of this can be seen in <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day15.santa rel="external noopener" target=_blank>day 15</a>, when attempting to find the first mapped value which &lsquo;uncovers&rsquo; x.</p><pre tabindex=0><code>parse_row(input)..
  |&gt; find_map(|y| {
    if let x = sensor_ranges(reports, y) |&gt; uncovered_x {
      [x, y]
    }
  })
  |&gt; tuning_frequency;
</code></pre><p>Finally, I noticed another pattern whereby I was <em>filtering</em> and then immediately returning the <em>size</em> of the given collection.
Taking inspiration from Ruby, I added a high-level <code>count</code> transformation which, based on a predicate (similar to how <code>filter</code> works), would tally up a finite sequence&rsquo;s items that matched that predicate.
This can be seen in the solution for <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day04.santa rel="external noopener" target=_blank>day 4</a>.</p><pre tabindex=0><code>part_two: {
  parse_assignments(input)
    |&gt; count(|[[x1, y1], [x2, y2]]| max(x1, x2) &lt;= min(y1, y2));
}
</code></pre><h3 id=the-expressiveness-of-ranges>The Expressiveness of Ranges</h3><p>I had used ranges in both Rust and Python before, the former having the syntax that inspired this language&rsquo;s design choice (<code>1..10</code>).
In the initial release, I had tried to simplify the specification by only including a single range <code>..</code>, which was inclusive of both the lower and upper bounds.
Throughout the calendar, however, I soon realised that having to decrement some values, especially when zero-indexed, was negatively impacting readability.
As such, I decided to additionally add <code>..=</code> which would replace my current implementation of <code>..</code>.
The <code>..</code> would now signify lower inclusive, upper exclusive - which is in keeping with how other languages define the behaviour.
This was an initial design decision that backfired on me and required amendment when spending more time within the language.
One puzzle that highlighted how useful range sequences were was in <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day15.santa rel="external noopener" target=_blank>day 15</a>, when we had to deduce all possible &lsquo;x&rsquo; positions.</p><pre tabindex=0><code>let xs = sensor_ranges(reports, y)
  |&gt; map(|[start, end]| start..=end)
  |&gt; union;
</code></pre><p>The use of ranges was applied in many areas of the calendar.
Another common example was when producing indexed sequences.
This behaviour is found in other languages (like <code>enumerate</code> in Python), but being able to provide such functionality on top of standard library constructs was empowering.
Furthermore, the resulting index/item tuple lists could be passed to the <code>hash</code> function to produce lookup tables.</p><pre tabindex=0><code>// aoc2022_day03.santa
let priorities = zip(&#34;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&#34;, 1..) |&gt; hash;

// aoc2022_day12.santa
let elevation = zip(&#34;SabcdefghijklmnopqrstuvwxyzE&#34;, 0..) |&gt; hash;
</code></pre><p>Another use of ranges was within pattern matching.
For <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day22.santa rel="external noopener" target=_blank>day 22</a>&rsquo;s infamous cube puzzle, I initially used <em>if guards</em> to handle point ranges, but again felt that the readability of the end solution was negatively impacted.
Instead, I decided to implement the ability to express ranges within pattern match statements, similar to how Rust does.
This resulted in a far more concise solution, as demonstrated in the snippet from day 22 below.</p><pre tabindex=0><code>let step_3d = |facing, [y, x]| {
  match [facing, [y, x]] {
    [&#34;N&#34;, [0, 50..100]]  { [&#34;E&#34;, [150 + (x - 50), 0]] }
    [&#34;N&#34;, [0, 100..150]] { [&#34;N&#34;, [199, x - 100]] }
    [&#34;N&#34;, [100, 0..50]]  { [&#34;E&#34;, [50 + x, 50]] }
    [&#34;N&#34;, _]             { [&#34;N&#34;, [y - 1, x]] }
    // ..
  }
}
</code></pre><h3 id=memoization-as-a-language-keyword>Memoization as a Language Keyword?!</h3><p>Every AoC calendar, you can expect to see one problem that lends itself to <a href=https://en.wikipedia.org/wiki/Dynamic_programming rel="external noopener" target=_blank>Dynamic Programming</a>.
These can be summarised as breaking up a larger problem into smaller sub-problems, which in turn can be used to help solve the original larger problem.
This year was no exception, and as such, I was required to invest some time in adding the ability to memoize functions within santa-lang.
For this, I added a function called <code>memoize</code>, which is a higher-order function that caches results (based on argument values) of the pure function that is supplied to it.
The inclusion of this function is not that significant, but what I really wish to highlight is how trailing lambda syntax provides for such a rich DSL, making the function invocation feel like a language construct.
This can be seen in an extract from the <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/aoc2022_day16.santa rel="external noopener" target=_blank>day 16</a> puzzle.</p><pre tabindex=0><code>let recur = memoize |valve, time, open_valves| {
  // ..
}
</code></pre><p>Although this simply means <code>memoize(|..| ..)</code>, the omission of the call parenthesis is very powerful.
It also lends itself well to <em>decorating</em> functions, in a similar manner to how Python provides such functionality.</p><h2 id=conclusion>Conclusion</h2><p>Having spent some time now reflecting on my experience solving the 2022 calendar in santa-lang, I am very pleased with how many of the fundamental decisions made upfront paid off.
Aside from the small additions discussed in this post, much of the language and its underlying philosophy have held up.
The one possible argument against this claim would be the inclusion of mutable <code>let</code> bindings, but after going back and forth on this decision, I feel that it has a deserved place in the language.</p><h3 id=possible-improvements>Possible Improvements</h3><p>Despite being happy with the current state of the language, there are several areas in which I feel time could be spent to improve it further.
One category of puzzle problem that we encountered in many variations this year was maze traversal.
Throughout the course of the month, I toyed with the idea of enriching the language with concepts and types that would aid in such problem-solving.
These were centred around the possible addition of a <code>Point</code> type and associated helper functions (i.e. <code>neighbours</code>, <code>bounded_neighbours</code>).
However, I could not settle on what I would deem to be the <em>best fit</em> for the language, as it would ideally cater to both 2D and 3D planes.
As such, I felt it best to omit such a concept for the time being and possibly revisit it in several months.
This would give me time to explore a more generalised approach to solving such problems, suitable for the many different AoC maze puzzles that exist.</p><p>Another area I feel could be improved is input parsing.
Although greatly simplified with the addition of <code>regex_*</code> helper functions (such as <code>ints</code>) and function composition, I believe a more radical change could be explored.
It would be interesting to experiment with embedding a <a href=https://en.wikipedia.org/wiki/Parser_combinator rel="external noopener" target=_blank>parser combinator</a> library into the runner, which would provide a clear means of defining how to transform the input into a parsed form used for computation.
Having seen examples in other languages such as Rust using libraries like <a href=https://docs.rs/nom/latest/nom/ rel="external noopener" target=_blank>nom</a>, I feel there could be a place for expressing such parsing rules in an Advent of Code DSL.</p><h3 id=whats-next>What&rsquo;s Next?</h3><p>Something I did not really touch upon throughout this post was performance.
This was intentional, as it was not a fundamental goal of the language, opting instead for readability and correctness.
As such, not much work was done (other than tail-recursive calls, which were more of a necessity at the time) within language evaluation to improve this.
I did <a href=https://github.com/eddmann/advent-of-code/blob/master/2022/santa-lang/benchmark.txt rel="external noopener" target=_blank>benchmark</a> each solution to see how the language/runtime implementation fared, and in some cases, the solution performance was in the 5-minute range ðŸ˜¬.
I briefly explored further data structure mutation, similar to Clojure (<a href=https://clojuredocs.org/clojure.core/assoc! rel="external noopener" target=_blank><code>assoc!</code></a>, <code>update!</code>), but this did not feel like the right path to take.
In some cases, this may have been due to suboptimal solutions, but I was sure there was room within the runtime to improve this.
To validate this, I reimplemented some of these solutions in Python and JavaScript, reflecting as closely as I could on the santa-lang implementation.
Within the CPython and Node v8 runtimes, these solutions were orders of magnitude faster! ðŸ˜®</p><p>This brings us to the next chapter of this project&mldr;
I now wish to take the language specification and defined standard library functions and reimplement them in a more performant, lower-level language.
For this, I have chosen Rust, as I feel it is a great fit for this purpose.
I also enjoyed using the language to build a <a href=/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/>Rubik&rsquo;s Cube Solver</a> several years back.</p><p>Along the way, I want to rethink the underlying abstractions in the TypeScript implementation, as it currently feels more like a proof of concept rather than a runtime I intend to maintain long-term.
I hope that through this process, I can improve the benchmark performance of these solutions, without changing anything about the actual solutions themselves - only the runtimes and associated internals.</p><p><strong>Update</strong>: You can read about this experience in the following <a href=/archive/tag/santa-lang-in-rust-series>blog series</a>.</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/santa-lang>santa-lang</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;setTimeout(()=>{const s=window.pageYOffset;n.classList.toggle("is-sticky",s>0&&t>s),t=s,e=!1},500),e=!0})})()</script></body></html>