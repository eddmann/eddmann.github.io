<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Clojure on Edd Mann</title><link>https://eddmann.com/archive/tag/clojure/</link><description>Recent content in Clojure on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Fri, 23 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/clojure/index.xml" rel="self" type="application/rss+xml"/><item><title>Allocating and Notifying Secret Santas via Email using Clojure</title><link>https://eddmann.com/posts/allocating-and-notifying-secret-santas-via-email-using-clojure/</link><pubDate>Fri, 23 Oct 2020 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/allocating-and-notifying-secret-santas-via-email-using-clojure/</guid><description>&lt;p>My close family have been doing Secret Santa over the past couple of years, and although there are plenty of free services out there to solve the problem of allocating and notifying participants, I thought it would be a great opportunity to explore building a solution using Clojure and Lein.&lt;/p></description></item><item><title>Allocating Secret Santas with a Substitution Cipher using Clojure</title><link>https://eddmann.com/posts/allocating-secret-santas-with-a-substitution-cipher-using-clojure/</link><pubDate>Sat, 09 Feb 2019 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/allocating-secret-santas-with-a-substitution-cipher-using-clojure/</guid><description>&lt;p>Over Christmas I found myself delving back into a bit of Clojure.
One such problem I stumbled upon solving was allocating &lt;a href="https://en.wikipedia.org/wiki/Secret_Santa" rel="external noopener" target="_blank">Secret Santas&lt;/a>.
In this post I will discuss how I went about grouping a given list of names based on certain criteria, and then correctly pairing up each person.
From here, I will highlight how I expanded upon the solution to allow these allocations to be distributed and hidden from prying eyes using a simple &lt;a href="https://en.wikipedia.org/wiki/ROT13" rel="external noopener" target="_blank">ROT13&lt;/a> substitution cipher.&lt;/p></description></item><item><title>AVL Trees in Clojure</title><link>https://eddmann.com/posts/avl-trees-in-clojure/</link><pubDate>Sat, 03 Sep 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/avl-trees-in-clojure/</guid><description>An AVL tree is a self-balancing binary search tree, whereby the height of a node&amp;rsquo;s children differs by at most one. In the event that this property is violated, a rebalancing process takes place.</description></item><item><title>Anagram Solver in Clojure</title><link>https://eddmann.com/posts/anagram-solver-in-clojure/</link><pubDate>Mon, 15 Aug 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/anagram-solver-in-clojure/</guid><description>&lt;p>This past week, a discussion around solving anagrams was brought up.
I thought it would be interesting to devise a couple of methods for computationally achieving such a task.
Providing an anagram string and a dictionary file, I wished to return all possible matching words from the dictionary.&lt;/p></description></item><item><title>Insertion Sort in Clojure</title><link>https://eddmann.com/posts/insertion-sort-in-clojure/</link><pubDate>Mon, 22 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/insertion-sort-in-clojure/</guid><description>&lt;p>The next sorting algorithm I have decided to explore is the Insertion Sort.
This sorting technique can be completed in-place.
However, using Clojure, we will instead use &lt;code>reduce&lt;/code> to accumulate the final sorted collection.
Each element is iteratively inserted into a &amp;rsquo;new&amp;rsquo; collection, which maintains a sorted invariant, as shown in the implementation documented below.&lt;/p></description></item><item><title>Bubble Sort in Clojure... again</title><link>https://eddmann.com/posts/bubble-sort-in-clojure-again/</link><pubDate>Sun, 21 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/bubble-sort-in-clojure-again/</guid><description>&lt;p>Following on from my &lt;a href="https://eddmann.com/posts/bubble-sort-in-clojure/">previous solution&lt;/a> to implementing the Bubble Sort algorithm in Clojure, I thought it would be interesting to experiment with a different approach.
Taking advantage of lists and vectors&amp;rsquo; respective cheap head and tail insertions, we can use these two properties to good effect, as shown below.&lt;/p></description></item><item><title>Bubble Sort in Clojure</title><link>https://eddmann.com/posts/bubble-sort-in-clojure/</link><pubDate>Fri, 19 Feb 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/bubble-sort-in-clojure/</guid><description>&lt;p>Following on with my exploration into implementing common sorting algorithms in Clojure, today we have the Bubble Sort.
This sort works by iteratively passing through the supplied sequence, swapping the current element with the next if it is comparably greater.
The operation is complete when a pass through the sequence does not result in a swap occurring.&lt;/p></description></item><item><title>Creating a IPersistentSet compatible Binary Tree in Clojure</title><link>https://eddmann.com/posts/creating-a-ipersistentset-compatible-binary-tree-in-clojure/</link><pubDate>Wed, 27 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/creating-a-ipersistentset-compatible-binary-tree-in-clojure/</guid><description>Following on from my post on Binary Search Trees last week, I decided to explore how I could use types and interfaces to implement the glue required to make the Binary Tree implementation compatible with the &lt;code>clojure.lang.IPersistentSet&lt;/code> interface.</description></item><item><title>Exploring Multi-Methods in Clojure</title><link>https://eddmann.com/posts/exploring-multi-methods-in-clojure/</link><pubDate>Thu, 21 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/exploring-multi-methods-in-clojure/</guid><description>&lt;p>Currently reading through the &lt;a href="https://www.manning.com/books/the-joy-of-clojure" rel="external noopener" target="_blank">Joy of Clojure&lt;/a> book, I have recently been introduced to Clojure&amp;rsquo;s multi-method support.
I decided that it would be interesting to see this feature in action, so I opened up LightTable and codified some example use-cases.&lt;/p></description></item><item><title>Binary Search Trees in Clojure</title><link>https://eddmann.com/posts/binary-search-trees-in-clojure/</link><pubDate>Wed, 20 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/binary-search-trees-in-clojure/</guid><description>&lt;p>This weekend I was able to spend some more time exploring Clojure.
I decided that it would be interesting to reimplement some of the &lt;a href="https://eddmann.com/posts/insertion-removal-and-inversion-operations-on-binary-search-trees-in-php/">Binary Search Tree work&lt;/a> I had previously done in PHP.
We start by creating a simple record definition which describes the contents of a Node.&lt;/p></description></item><item><title>Recreating 'Let' using a Macro in Clojure</title><link>https://eddmann.com/posts/recreating-let-using-a-macro-in-clojure/</link><pubDate>Fri, 15 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/recreating-let-using-a-macro-in-clojure/</guid><description>Inspired by a good friend&amp;rsquo;s recent Gist on how the functionality of the special form &lt;code>let&lt;/code> could be achieved using a little Lambda trickery, I decided to write a simple macro that would do this transformation.</description></item><item><title>Checking for Balanced Parentheses in Clojure</title><link>https://eddmann.com/posts/checking-for-balanced-parentheses-in-clojure/</link><pubDate>Wed, 13 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/checking-for-balanced-parentheses-in-clojure/</guid><description>&lt;p>This lunchtime I decided to implement a solution to the balanced parentheses (brackets) problem in Clojure.
Looking at the code below, you can see that I took advantage of the &lt;code>cond&lt;/code> macro to more clearly express the recursive algorithm&amp;rsquo;s intent.
I have also provided a couple of test assertions which are stored in the vars metadata and called using the core library&amp;rsquo;s &lt;code>test&lt;/code> function.&lt;/p></description></item><item><title>QuickSort in Clojure</title><link>https://eddmann.com/posts/quicksort-in-clojure/</link><pubDate>Mon, 11 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/quicksort-in-clojure/</guid><description>&lt;p>This past weekend I had the opportunity to delve more deeply into Clojure&amp;rsquo;s &lt;a href="https://clojuredocs.org/clojure.core" rel="external noopener" target="_blank">core library&lt;/a>.
I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways.&lt;/p></description></item><item><title>Recursive Functions using a Trampoline in Clojure</title><link>https://eddmann.com/posts/recursive-functions-using-a-trampoline-in-clojure/</link><pubDate>Thu, 07 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/recursive-functions-using-a-trampoline-in-clojure/</guid><description>&lt;p>Following on from yesterday&amp;rsquo;s post that discussed &lt;a href="https://eddmann.com/posts/recursive-functions-using-a-trampoline-in-javascript/">&amp;lsquo;Trampolining&amp;rsquo; in JavaScript&lt;/a>, I thought it would be interesting to see what Clojure has to offer.&lt;/p></description></item><item><title>Mergesort in Clojure using Post Conditionals</title><link>https://eddmann.com/posts/mergesort-in-clojure-using-post-conditionals/</link><pubDate>Tue, 05 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mergesort-in-clojure-using-post-conditionals/</guid><description>&lt;p>Whilst currently reading through &lt;a href="https://www.manning.com/books/the-joy-of-clojure" rel="external noopener" target="_blank">The Joy of Clojure&lt;/a> book I was introduced to the concept of pre and post-conditionals, similar to another language called &lt;a href="https://en.wikipedia.org/wiki/Eiffel_%28programming_language%29" rel="external noopener" target="_blank">Eiffel&lt;/a>.
To experiment with this feature I decided to create a simple merge-sort algorithm implementation which ensured that its returned values were sorted by the provided predicate.&lt;/p></description></item><item><title>Infix Calculator in Clojure</title><link>https://eddmann.com/posts/infix-calculator-in-clojure/</link><pubDate>Sun, 03 Jan 2016 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/infix-calculator-in-clojure/</guid><description>&lt;p>Following on from my previous post, I have continued my exploration into Clojure by implementing a simple infix calculator - using the Shunting Yard algorithm and RPN evaluation.
The documented implementation is split into three distinct parts, of which I will describe piece-by-piece before composing them together to result in the final calculator.&lt;/p></description></item><item><title>FizzBuzz in Clojure</title><link>https://eddmann.com/posts/fizzbuzz-in-clojure/</link><pubDate>Thu, 31 Dec 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/fizzbuzz-in-clojure/</guid><description>&lt;p>This past Christmas break I had the chance to finally pick up &lt;a href="https://www.manning.com/books/the-joy-of-clojure" rel="external noopener" target="_blank">The Joy of Clojure&lt;/a> book and delve into the world of Lisp.
Along with the commonplace merge-sort algorithm, I find it beneficial to explore a new language and its capabilities by solving the &lt;a href="http://rosettacode.org/wiki/FizzBuzz" rel="external noopener" target="_blank">FizzBuzz&lt;/a> code kata.
In this post I will be explaining a couple of the implementations that I created.&lt;/p></description></item></channel></rss>