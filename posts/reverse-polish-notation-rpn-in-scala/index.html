<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Reverse Polish Notation (RPN) in Scala - Edd Mann</title>
<meta name=description content="Learn how to evaluate Reverse Polish Notation (RPN) expressions in Scala using both mutable stack and functional programming approaches with practical code examples."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Reverse Polish Notation (RPN) in Scala"><meta itemprop=description content="Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical Reverse Polish notation string. Popularised by its use in the HP-10C series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation)."><meta itemprop=datePublished content="2013-12-15T00:00:00+00:00"><meta itemprop=dateModified content="2013-12-15T00:00:00+00:00"><meta itemprop=wordCount content="438"><meta itemprop=keywords content="Scala,Functional-Programming,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Reverse Polish Notation (RPN) in Scala"><meta property="og:description" content="Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical Reverse Polish notation string. Popularised by its use in the HP-10C series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation)."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-12-15T00:00:00+00:00"><meta property="article:modified_time" content="2013-12-15T00:00:00+00:00"><meta property="article:tag" content="Scala"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reverse Polish Notation (RPN) in Scala"><meta name=twitter:description content="Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical Reverse Polish notation string. Popularised by its use in the HP-10C series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation)."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.094c8c11875f4921a4fa157fbb0e4a483b9d415d48f335d2effb5818cee90471.css integrity="sha256-CUyMEYdfSSGk+hV/uw5KSDudQV1I8zXS7/tYGM7pBHE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/reverse-polish-notation-rpn-in-scala/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.164d56ac6f4c8613b0b7109fd1b4d9dfdce1d004edab8e1afb7240013f9221d7.js integrity="sha256-Fk1WrG9MhhOwtxCf0bTZ39zh0ATtq44a+3JAAT+SIdc=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:reverse-polish-notation-rpn-in-scala>Reverse Polish Notation (RPN) in Scala</h1><time datetime=2013-12-15T00:00:00Z class=published-at>Dec 15, 2013</time></header><main class=u-prose><p>Continuing on with my exploration of the Scala language, I decided to solve the widely documented problem of evaluating a mathematical <a href=http://en.wikipedia.org/wiki/Reverse_Polish_Notation rel="external noopener" target=_blank>Reverse Polish notation</a> string.
Popularised by its use in the <a href=http://en.wikipedia.org/wiki/HP-10C_series rel="external noopener" target=_blank>HP-10C</a> series of calculators from the 1980s, the notation requires that every operator follow its operands (otherwise called postfix notation).</p><p>For simplification, both discussed solutions use the partially-applied &lsquo;parse&rsquo; function below, which is simply an alias for Java&rsquo;s &lsquo;parseDouble&rsquo; method.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>def</span> parse <span style=color:#66d9ef>=</span> java<span style=color:#f92672>.</span>lang<span style=color:#f92672>.</span><span style=color:#a6e22e>Double</span><span style=color:#f92672>.</span>parseDouble <span style=color:#66d9ef>_</span>
</span></span></code></pre></div><h2 id=mutable-stack>Mutable Stack</h2><p>A typical solution to this problem is to use a mutable stack, which, based on the current token, either pushes the parsed number or the operator result back onto the stack.
Once you have iterated over each of the split string tokens, you will be left with a single item, which is your result.
Although this solution uses mutability (a big functional no-no), I was able to take advantage of Scala&rsquo;s first-class function support for the operator map.
As addition and multiplication operations both have the symmetric property, I was able to ignore the stack&rsquo;s last-in-first-out (LIFO) nature in this case.
However, regarding the minus and divide operations, I was required to swap the parameter values around before evaluating and returning the result.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>def</span> rpn<span style=color:#f92672>(</span>str<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> ops <span style=color:#66d9ef>=</span> <span style=color:#a6e22e>Map</span><span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;+&#34;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>((</span><span style=color:#66d9ef>_:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)</span> <span style=color:#f92672>+</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>_:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)),</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;*&#34;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>((</span><span style=color:#66d9ef>_:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)</span> <span style=color:#f92672>*</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>_:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)),</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;-&#34;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>((</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>,</span> y<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> y <span style=color:#f92672>-</span> x<span style=color:#f92672>),</span>
</span></span><span style=display:flex><span>        <span style=color:#e6db74>&#34;/&#34;</span> <span style=color:#f92672>-&gt;</span> <span style=color:#f92672>((</span>x<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>,</span> y<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>Double</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> y <span style=color:#f92672>/</span> x<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>val</span> stack <span style=color:#66d9ef>=</span> <span style=color:#66d9ef>new</span> scala<span style=color:#f92672>.</span>collection<span style=color:#f92672>.</span>mutable<span style=color:#f92672>.</span><span style=color:#a6e22e>Stack</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Double</span><span style=color:#f92672>]</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    str<span style=color:#f92672>.</span>split<span style=color:#f92672>(</span><span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>).</span>foreach<span style=color:#f92672>(</span>token <span style=color:#66d9ef>=&gt;</span>
</span></span><span style=display:flex><span>        stack<span style=color:#f92672>.</span>push<span style=color:#f92672>(</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>if</span> <span style=color:#f92672>(</span>ops<span style=color:#f92672>.</span>contains<span style=color:#f92672>(</span>token<span style=color:#f92672>))</span> ops<span style=color:#f92672>(</span>token<span style=color:#f92672>)(</span>stack<span style=color:#f92672>.</span>pop<span style=color:#f92672>,</span> stack<span style=color:#f92672>.</span>pop<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>else</span> parse<span style=color:#f92672>(</span>token<span style=color:#f92672>)</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>))</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    stack<span style=color:#f92672>.</span>pop
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><h2 id=pattern-matching>Pattern-Matching</h2><p>Following on from the above mutable approach, I was able to implement a solution that follows the side-effect-free functional paradigm.
In this instance, I am instead performing a left-fold over the split string, then using pattern matching to evaluate each token and the current state of the stack (list).
By this use of pattern matching, I am similarly, in effect, &lsquo;popping&rsquo; off the last two operands when I encounter an operator token.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span><span style=color:#66d9ef>def</span> rpn<span style=color:#f92672>(</span>str<span style=color:#66d9ef>:</span> <span style=color:#66d9ef>String</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    str<span style=color:#f92672>.</span>split<span style=color:#f92672>(</span><span style=color:#e6db74>&#39; &#39;</span><span style=color:#f92672>).</span>toList<span style=color:#f92672>.</span>foldLeft<span style=color:#f92672>(</span><span style=color:#a6e22e>List</span><span style=color:#f92672>[</span><span style=color:#66d9ef>Double</span><span style=color:#f92672>]())(</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> token<span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>list<span style=color:#f92672>,</span> token<span style=color:#f92672>)</span> <span style=color:#66d9ef>match</span> <span style=color:#f92672>{</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>x <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>y</span> <span style=color:#66d9ef>::</span> <span style=color:#66d9ef>zs</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;*&#34;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>y <span style=color:#f92672>*</span> x<span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>zs</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>x <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>y</span> <span style=color:#66d9ef>::</span> <span style=color:#66d9ef>zs</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;+&#34;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>y <span style=color:#f92672>+</span> x<span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>zs</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>x <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>y</span> <span style=color:#66d9ef>::</span> <span style=color:#66d9ef>zs</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;-&#34;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>y <span style=color:#f92672>-</span> x<span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>zs</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span>x <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>y</span> <span style=color:#66d9ef>::</span> <span style=color:#66d9ef>zs</span><span style=color:#f92672>,</span> <span style=color:#e6db74>&#34;/&#34;</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> <span style=color:#f92672>(</span>y <span style=color:#f92672>/</span> x<span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>zs</span>
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>case</span> <span style=color:#f92672>(</span><span style=color:#66d9ef>_</span><span style=color:#f92672>,</span> <span style=color:#66d9ef>_</span><span style=color:#f92672>)</span> <span style=color:#66d9ef>=&gt;</span> parse<span style=color:#f92672>(</span>token<span style=color:#f92672>)</span> <span style=color:#66d9ef>:</span><span style=color:#66d9ef>:</span> <span style=color:#66d9ef>list</span>
</span></span><span style=display:flex><span>        <span style=color:#f92672>}).</span>head
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#f92672>}</span>
</span></span></code></pre></div><p>Finally, both implementations, when run with the following RPN string argument, will return a double value of 8.0.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-scala data-lang=scala><span style=display:flex><span>rpn<span style=color:#f92672>(</span><span style=color:#e6db74>&#34;4 2 * 8 + 2 /&#34;</span><span style=color:#f92672>)</span> <span style=color:#75715e>// 8.0
</span></span></span></code></pre></div></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/scala>scala</a></li><li><a href=/archive/tag/functional-programming>functional-programming</a></li><li><a href=/archive/tag/algorithms>algorithms</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/merge-sort-in-scala-using-tail-recursion-and-streams/>Merge sort in Scala using Tail-recursion and Streams</a></li><li><a href=/posts/merge-sort-comparison-in-java-and-scala/>Merge sort comparison in Java and Scala</a></li><li><a href=/posts/using-for-comprehensions-in-scala/>Using For-Comprehensions in Scala</a></li><li><a href=/posts/solving-the-k-combinations-problem-in-scala/>Solving the k-combinations problem in Scala</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>