<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Reversing a Unicode String in PHP using UTF-16BE/LE - Edd Mann</title>
<meta name=description content="Learn how to reverse a Unicode string in PHP using UTF-16 endianness conversion for accurate results."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Reversing a Unicode String in PHP using UTF-16BE/LE"><meta itemprop=description content="Last week I was bitten by the Unicode encoding issue when trying to naively manipulate a user’s input using PHP’s built-in string functions. PHP simply assumes that all characters are a single byte (octet) and the provided functions use this assumption when processing a string. In this post I will not be going into depth on the subject of Unicode representations. I feel this topic deserves its own series of articles. However, you should be aware that in ‘Western Europe’ we commonly only use the basic ASCII character-set (consisting of 7 bytes). This makes the transition to the popular ‘UTF-8’ Unicode representation almost seamless, as the two map one-to-one. I wish to, however, discuss how to reverse a Unicode string (UTF-8) using a combination of endianness magic and the ‘strrev’ function."><meta itemprop=datePublished content="2014-05-11T00:00:00+00:00"><meta itemprop=dateModified content="2014-05-11T00:00:00+00:00"><meta itemprop=wordCount content="432"><meta itemprop=keywords content="Php"><meta property="og:url" content="https://eddmann.com/posts/reversing-a-unicode-string-in-php-using-utf-16-be-le/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Reversing a Unicode String in PHP using UTF-16BE/LE"><meta property="og:description" content="Last week I was bitten by the Unicode encoding issue when trying to naively manipulate a user’s input using PHP’s built-in string functions. PHP simply assumes that all characters are a single byte (octet) and the provided functions use this assumption when processing a string. In this post I will not be going into depth on the subject of Unicode representations. I feel this topic deserves its own series of articles. However, you should be aware that in ‘Western Europe’ we commonly only use the basic ASCII character-set (consisting of 7 bytes). This makes the transition to the popular ‘UTF-8’ Unicode representation almost seamless, as the two map one-to-one. I wish to, however, discuss how to reverse a Unicode string (UTF-8) using a combination of endianness magic and the ‘strrev’ function."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-05-11T00:00:00+00:00"><meta property="article:modified_time" content="2014-05-11T00:00:00+00:00"><meta property="article:tag" content="Php"><meta name=twitter:card content="summary"><meta name=twitter:title content="Reversing a Unicode String in PHP using UTF-16BE/LE"><meta name=twitter:description content="Last week I was bitten by the Unicode encoding issue when trying to naively manipulate a user’s input using PHP’s built-in string functions. PHP simply assumes that all characters are a single byte (octet) and the provided functions use this assumption when processing a string. In this post I will not be going into depth on the subject of Unicode representations. I feel this topic deserves its own series of articles. However, you should be aware that in ‘Western Europe’ we commonly only use the basic ASCII character-set (consisting of 7 bytes). This makes the transition to the popular ‘UTF-8’ Unicode representation almost seamless, as the two map one-to-one. I wish to, however, discuss how to reverse a Unicode string (UTF-8) using a combination of endianness magic and the ‘strrev’ function."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.ddd6f4a6dba0446b8511d9836c8d0225808e1ec03aeda5cef7f72ad0c51ad86a.css integrity="sha256-3db0ptugRGuFEdmDbI0CJYCOHsA67aXO9/cq0MUa2Go="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/reversing-a-unicode-string-in-php-using-utf-16-be-le/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.1052707861642a4eb63c758a2c16cbf5deb3b3ea2582f09f743a7d4c55fb9828.js integrity="sha256-EFJweGFkKk62PHWKLBbL9d6zs+olgvCfdDp9TFX7mCg=" defer></script></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1 class=transition-between-pages style=--id:reversing-a-unicode-string-in-php-using-utf-16-be-le>Reversing a Unicode String in PHP using UTF-16BE/LE</h1><time datetime=2014-05-11T00:00:00Z class=post__time>May 11, 2014</time></header><main class=prose><p>Last week I was bitten by the Unicode encoding issue when trying to naively manipulate a user&rsquo;s input using PHP&rsquo;s built-in string functions.
PHP simply assumes that all characters are a single byte (octet) and the provided functions use this assumption when processing a string.
In this post I will not be going into depth on the subject of Unicode representations.
I feel this topic deserves its own series of articles.
However, you should be aware that in &lsquo;Western Europe&rsquo; we commonly only use the basic <a href=http://en.wikipedia.org/wiki/ASCII rel="external noopener" target=_blank>ASCII</a> character-set (consisting of 7 bytes).
This makes the transition to the popular &lsquo;UTF-8&rsquo; Unicode representation almost seamless, as the two map one-to-one.
I wish to, however, discuss how to reverse a Unicode string (UTF-8) using a combination of <a href=http://en.wikipedia.org/wiki/Endianness rel="external noopener" target=_blank>endianness</a> magic and the <a href=http://www.php.net/manual/en/function.strrev.php rel="external noopener" target=_blank>&lsquo;strrev&rsquo;</a> function.</p><p>To clearly highlight the examples, the function below is used throughout the post, returning how the string is represented in binary.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>str2bin</span>($str)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>array_reduce</span>(<span style=color:#a6e22e>unpack</span>(<span style=color:#e6db74>&#39;C*&#39;</span>, $str), <span style=color:#66d9ef>function</span>($bin, $chr)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> $bin <span style=color:#f92672>.</span> <span style=color:#a6e22e>str_pad</span>(<span style=color:#a6e22e>decbin</span>($chr), <span style=color:#ae81ff>8</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>STR_PAD_LEFT</span>);
</span></span><span style=display:flex><span>    }, <span style=color:#e6db74>&#39;&#39;</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=naive-approach>Naive Approach</h2><p>With many encodings that only include single-byte character representations (i.e. ASCII, ISO 8859-*), using the in-built <code>strrev</code> function will work fine.
However, the constructed UTF-8 string below contains a combination of ASCII-compatible characters and a multi-byte &lsquo;Black Star&rsquo; character.
You will notice that the two first bytes represent the &lsquo;a&rsquo; and &lsquo;b&rsquo; characters, and as they fit inside a single octet each they are not affected.
The issue arises, however, with the &lsquo;Black Star&rsquo; character, which requires a three-byte representation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$str <span style=color:#f92672>=</span> <span style=color:#a6e22e>json_decode</span>(<span style=color:#e6db74>&#39;&#34;ab\\u2605&#34;&#39;</span>); <span style=color:#75715e>// ab★
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>str2bin</span>($str); <span style=color:#75715e>// 01100001 01100010 11100010 10011000 10000101
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>$naive <span style=color:#f92672>=</span> <span style=color:#a6e22e>strrev</span>($str); <span style=color:#75715e>// ???ba
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>str2bin</span>($str); <span style=color:#75715e>// 10000101 10011000 11100010 01100010 01100001
</span></span></span></code></pre></div><p>If we naively use the &lsquo;strrev&rsquo; function you will notice (aided by the binary representation) that the multi-byte character is corrupted.</p><h2 id=endianness-approach>Endianness Approach</h2><p>This is a huge pain, but taking advantage of UTF-16&rsquo;s two-byte representation and endianness we are able to successfully reverse the string.
The first step is to convert the UTF-8 representation to a big-endian (most significant byte) UTF-16 representation.
The endianness is important, as you will notice that when we perform the transformation the resulting representation is changed to little-endian (least significant byte).
As we know this is the case we can specify this to encode back to UTF-8.
Finally, we are left with a string which has been correctly reversed without any corruption.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span>$be <span style=color:#f92672>=</span> <span style=color:#a6e22e>iconv</span>(<span style=color:#e6db74>&#39;UTF-8&#39;</span>, <span style=color:#e6db74>&#39;UTF-16BE&#39;</span>, $str);
</span></span><span style=display:flex><span><span style=color:#a6e22e>str2bin</span>($be); <span style=color:#75715e>// 00000000 01100001 00000000 01100010 00100110 00000101
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>$tmp <span style=color:#f92672>=</span> <span style=color:#a6e22e>strrev</span>($be);
</span></span><span style=display:flex><span><span style=color:#a6e22e>str2bin</span>($tmp); <span style=color:#75715e>// 00000101 00100110 01100010 00000000 01100001 00000000
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>$res <span style=color:#f92672>=</span> <span style=color:#a6e22e>iconv</span>(<span style=color:#e6db74>&#39;UTF-16LE&#39;</span>, <span style=color:#e6db74>&#39;UTF-8&#39;</span>, $tmp); <span style=color:#75715e>// ★ba
</span></span></span><span style=display:flex><span><span style=color:#75715e></span><span style=color:#a6e22e>str2bin</span>($res); <span style=color:#75715e>// 11100010 10011000 10000101 01100010 01100001
</span></span></span></code></pre></div></main><footer class=post__tags><a href=/archive/tag/php>php</a></footer></article><div class="related-posts prose"><h3>Related Posts</h3><ul><li><a href=/posts/reversing-a-string-in-php/>Reversing a String in PHP</a></li><li><a href=/posts/tuples-in-php/>Tuples in PHP</a></li><li><a href=/posts/storing-php-sessions-file-caches-in-memory-using-tmpfs/>Storing PHP Sessions/File Caches in Memory using TMPFS</a></li><li><a href=/posts/securing-sessions-in-php/>Securing Sessions in PHP</a></li><li><a href=/posts/the-y-fixed-point-combinator-in-php/>The Y (Fixed-Point) Combinator in PHP</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div><button class=theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>