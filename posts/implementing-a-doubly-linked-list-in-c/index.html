<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Implementing a Doubly Linked List in C - Edd Mann</title>
<meta name=description content="A comprehensive guide to implementing a doubly linked list in C, covering structure, memory management and forward declarations."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Implementing a Doubly Linked List in C"><meta itemprop=description content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta itemprop=datePublished content="2014-01-03T00:00:00+00:00"><meta itemprop=dateModified content="2014-01-03T00:00:00+00:00"><meta itemprop=wordCount content="602"><meta itemprop=keywords content="C,Data-Structures"><meta property="og:url" content="https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Implementing a Doubly Linked List in C"><meta property="og:description" content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2014-01-03T00:00:00+00:00"><meta property="article:tag" content="C"><meta property="article:tag" content="Data-Structures"><meta name=twitter:card content="summary"><meta name=twitter:title content="Implementing a Doubly Linked List in C"><meta name=twitter:description content="Following on from the discussion on implementing a singly linked list in C, a logical follow-up data structure is the doubly linked list."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.6d190498ff3baf1368714fe1529fcd878be7d3fe03d6a837007b47c1a5dbe5b7.css integrity="sha256-bRkEmP87rxNocU/hUp/Nh4vn0/4D1qg3AHtHwaXb5bc="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/implementing-a-doubly-linked-list-in-c/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.c886797fe1c76f3a5cace46b687d1d56b58c9e0df4f37c62bffbcda7eb40fce8.js integrity="sha256-yIZ5f+HHbzpcrORraH0dVrWMng3083xiv/vNp+tA/Og=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:implementing-a-doubly-linked-list-in-c>Implementing a Doubly Linked List in C</h1><time datetime=2014-01-03T00:00:00Z class=time>Jan 3, 2014</time></header><main class=u-prose><p>Following on from the discussion on implementing a <a href=/posts/implementing-a-singly-linked-list-in-c/>singly linked list</a> in C, a logical follow-up data structure is the doubly linked list.</p><p>In a similar fashion to the singly linked list, the structure is composed of a set of sequentially linked nodes, each now containing references (pointers) not only to the next node but also to the previous one.
This structure is useful if the use case requires the ability to traverse the list both forwards and backwards, or to quickly determine preceding and following elements from a given node.
The head and tail nodes can be terminated with either <a href=http://en.wikipedia.org/wiki/Sentinel_node rel="external noopener" target=_blank>sentinel nodes</a> (referred to as <em>circularly linked</em> if only one is used) or, as in the implementation shown below, <code>NULL</code>.
One notable implementation difference between the two structures is that by storing both the previous and next references, the complexity and running time of certain operations (with removal from the tail being the most obvious) can be significantly simplified.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdio.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdlib.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;stdbool.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>typedef</span> <span style=color:#66d9ef>struct</span> node {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span> item;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> node <span style=color:#f92672>*</span>prev, <span style=color:#f92672>*</span>next;
</span></span><span style=display:flex><span>} node;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>node <span style=color:#f92672>*</span>head, <span style=color:#f92672>*</span>tail;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>insert</span>(<span style=color:#66d9ef>int</span> item, <span style=color:#66d9ef>bool</span> at_tail)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> (node<span style=color:#f92672>*</span>) <span style=color:#a6e22e>malloc</span>(<span style=color:#66d9ef>sizeof</span>(node));
</span></span><span style=display:flex><span>    ptr<span style=color:#f92672>-&gt;</span>item <span style=color:#f92672>=</span> item;
</span></span><span style=display:flex><span>    ptr<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) {
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> tail <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (at_tail) {
</span></span><span style=display:flex><span>        tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>        ptr<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        ptr<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        head<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> ptr;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>delete</span>(<span style=color:#66d9ef>bool</span> from_tail)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;Empty list.</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>exit</span>(<span style=color:#ae81ff>1</span>);
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> <span style=color:#66d9ef>if</span> (from_tail) {
</span></span><span style=display:flex><span>        node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>item;
</span></span><span style=display:flex><span>        tail <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>prev;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> tail) head <span style=color:#f92672>=</span> tail;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> tail<span style=color:#f92672>-&gt;</span>next <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    } <span style=color:#66d9ef>else</span> {
</span></span><span style=display:flex><span>        node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> item <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>item;
</span></span><span style=display:flex><span>        head <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (NULL <span style=color:#f92672>==</span> head) tail <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>else</span> head<span style=color:#f92672>-&gt;</span>prev <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>free</span>(ptr);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> NULL;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> item;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> <span style=color:#a6e22e>list</span>()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    node <span style=color:#f92672>*</span>ptr <span style=color:#f92672>=</span> head;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (NULL <span style=color:#f92672>!=</span> ptr) {
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;%d &#34;</span>, ptr<span style=color:#f92672>-&gt;</span>item);
</span></span><span style=display:flex><span>        ptr <span style=color:#f92672>=</span> ptr<span style=color:#f92672>-&gt;</span>next;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>printf</span>(<span style=color:#e6db74>&#34;</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>(<span style=color:#66d9ef>int</span> argc, <span style=color:#66d9ef>char</span> <span style=color:#f92672>*</span>argv[])
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>10</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>insert</span>(i, i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>6</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list</span>(); <span style=color:#75715e>// 10 9 8 7 6 1 2 3 4 5
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> <span style=color:#ae81ff>1</span>; i <span style=color:#f92672>&lt;=</span> <span style=color:#ae81ff>4</span>; i<span style=color:#f92672>++</span>)
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>delete</span>(i <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>3</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>list</span>(); <span style=color:#75715e>// 8 7 6 1 2 3
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>}
</span></span></code></pre></div><p>Looking at the implementation above, you will notice the omission of list traversal when removing a node from the tail, as the reference to the previous node is already at hand.
The <code>list</code> function only takes into consideration forward iteration over the list, however, it would be very easy to modify the code to perform backwards traversal.
It is good practice to not only free the memory that is no longer required, but also to set any related pointers to <code>NULL</code>, as these pointers would otherwise still refer to memory that has been deallocated.</p><p>One C implementation detail I would like to discuss is the use of <code>typedef struct</code> when declaring the node structure.
In C, there are two different namespaces: one for <code>struct</code> tags and one for <code>typedef</code> names.
Referring to a <code>struct</code> can be very verbose, and to avoid this we can declare both a node <code>struct</code> and a plain node in the <code>typedef</code> namespace.
Both refer to the same type, allowing us to omit the <code>struct</code> keyword.
However, using only the <code>typedef</code> declaration would not allow us to perform a <a href=http://en.wikipedia.org/wiki/Forward_declaration rel="external noopener" target=_blank>forward declaration</a>, which gives us the ability to use an identifier before providing the complete definition to the compiler.</p><h2 id=resources>Resources</h2><ul><li><a href=http://stackoverflow.com/questions/612328/difference-between-struct-and-typedef-struct-in-c rel="external noopener" target=_blank>Difference between &lsquo;struct&rsquo; and &rsquo;typedef struct&rsquo; in C++?</a></li><li><a href=http://en.wikipedia.org/wiki/Forward_declaration rel="external noopener" target=_blank>Forward declaration</a></li></ul></main><footer class=post__tags><a href=/archive/tag/c>c</a><a href=/archive/tag/data-structures>data-structures</a></footer></article><div class="related-posts u-prose"><h3>Related Posts</h3><ul><li><a href=/posts/implementing-a-xor-doubly-linked-list-in-c/>Implementing a XOR Doubly Linked-List in C</a></li><li><a href=/posts/implementing-a-singly-linked-list-in-c/>Implementing a Singly Linked-List in C</a></li><li><a href=/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/>Implementing a Queue in Java using Arrays and Linked Lists</a></li><li><a href=/posts/implementing-a-stack-in-java-using-arrays-and-linked-lists/>Implementing a Stack in Java using Arrays and Linked Lists</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>