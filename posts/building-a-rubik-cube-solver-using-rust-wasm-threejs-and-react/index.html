<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Building a Rubik's Cube Solver using Rust/WASM and Three.js/React - Edd Mann</title>
<meta name=description content="Explore the process of building a Rubik's Cube (3x3x3) solver using Rust, WebAssembly (WASM), Three.js, and React."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Building a Rubik's Cube Solver using Rust/WASM and Three.js/React"><meta itemprop=description content="After building the Pocket Cube Solver, I wished to expand upon this design and cater for a conventional 3x3x3 Rubik’s Cube. In this post, I discuss the process I went through in designing and building the solver and visual client alike - taking the learnings garnered from implementing the previous solver."><meta itemprop=datePublished content="2021-07-06T00:00:00+00:00"><meta itemprop=dateModified content="2021-07-06T00:00:00+00:00"><meta itemprop=wordCount content="856"><meta itemprop=keywords content="Rubiks-Cube,Typescript,Rust,React,Threejs"><meta property="og:url" content="https://eddmann.com/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Building a Rubik's Cube Solver using Rust/WASM and Three.js/React"><meta property="og:description" content="After building the Pocket Cube Solver, I wished to expand upon this design and cater for a conventional 3x3x3 Rubik’s Cube. In this post, I discuss the process I went through in designing and building the solver and visual client alike - taking the learnings garnered from implementing the previous solver."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-07-06T00:00:00+00:00"><meta property="article:modified_time" content="2021-07-06T00:00:00+00:00"><meta property="article:tag" content="Rubiks-Cube"><meta property="article:tag" content="Typescript"><meta property="article:tag" content="Rust"><meta property="article:tag" content="React"><meta property="article:tag" content="Threejs"><meta name=twitter:card content="summary"><meta name=twitter:title content="Building a Rubik's Cube Solver using Rust/WASM and Three.js/React"><meta name=twitter:description content="After building the Pocket Cube Solver, I wished to expand upon this design and cater for a conventional 3x3x3 Rubik’s Cube. In this post, I discuss the process I went through in designing and building the solver and visual client alike - taking the learnings garnered from implementing the previous solver."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.c3ee6cab58dd3fee7e6960b0391e996ba9254804702bc60a52ec5e0e3591a018.css integrity="sha256-w+5sq1jdP+5+aWCwOR6Za6klSARwK8YKUuxeDjWRoBg="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.164d56ac6f4c8613b0b7109fd1b4d9dfdce1d004edab8e1afb7240013f9221d7.js integrity="sha256-Fk1WrG9MhhOwtxCf0bTZ39zh0ATtq44a+3JAAT+SIdc=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react>Building a Rubik's Cube Solver using Rust/WASM and Three.js/React</h1><time datetime=2021-07-06T00:00:00Z class=published-at>Jul 6, 2021</time></header><main class=u-prose><p>After building the <a href=/posts/building-an-optimal-pocket-cube-solver-using-rust-wasm-threejs-and-react/>Pocket Cube Solver</a>, I wished to expand upon this design and cater for a conventional 3x3x3 Rubik&rsquo;s Cube.
In this post, I discuss the process I went through in designing and building the solver and visual client alike - taking the learnings garnered from implementing the previous solver.</p><h2 id=characteristics-of-a-rubiks-cube>Characteristics of a Rubik&rsquo;s Cube</h2><p>As documented in my previous post, a Pocket Cube has a couple of key characteristics that make it easier to construct a solver using conventional <a href=https://en.wikipedia.org/wiki/Graph_traversal rel="external noopener" target=_blank>Graph searching algorithms</a>, with minimal pruning or heuristics required.
However, in the case of a 3x3x3 Rubik&rsquo;s Cube, this is not the case, largely due to the addition of a centre <em>cubie</em> - meaning the two no longer share the same optimisations that can be performed.
The cube itself has <em>43 quintillion, 252 quadrillion, 3 trillion, 274 billion, 489 million, 856 thousand</em> different valid states, which makes it computationally infeasible to visit each possible move sequence in an adequate time.
However, <a href=http://www.cube20.org/ rel="external noopener" target=_blank>research</a> has proven that God&rsquo;s Number for a Rubik&rsquo;s Cube is twenty - demonstrating that any initial state can be solved in twenty moves or fewer.</p><p><picture><source type=image/webp srcset="/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_a324aa5b49993e54.webp 350w, /posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_bcafa5948ba016e9.webp 700w, /posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_b5db361228198519.webp 1400w"><source type=image/jpeg srcset="/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_5d0d968b3871366a.jpg 350w, /posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_f6de01328a97088b.jpg 700w, /posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_a4a04987b9fc84bc.jpg 1400w"><img src=/posts/building-a-rubik-cube-solver-using-rust-wasm-threejs-and-react/cube_hu_f6de01328a97088b.jpg alt="Characteristics of a Rubik’s Cube" loading=lazy></picture></p><h2 id=solving-the-cube>Solving the Cube</h2><p>Along with conventional <a href=https://en.wikipedia.org/wiki/Layer_by_Layer rel="external noopener" target=_blank>Layer by Layer</a> approaches that <em>eventually</em> lead to a solved state, there has been much research into producing algorithms that perform this task more efficiently.</p><h3 id=korfs-algorithm>Korf&rsquo;s Algorithm</h3><p>Initially, when setting out to build this Rubik&rsquo;s Cube Solver, I had hoped to mirror the <a href=https://github.com/eddmann/pocket-cube-solver rel="external noopener" target=_blank>2x2x2 counterpart</a> and create an optimal solver that ran in the browser.
Prior work in this space documents algorithms such as <a href=https://www.aaai.org/Papers/AAAI/1997/AAAI97-109.pdf rel="external noopener" target=_blank>Richard Korf&rsquo;s</a>, which, with the aid of several pruning tables, can provide an optimal solution from any initial state using Iterative deepening depth-first search (IDDFS) to traverse the search space.
However, these pruning tables must be generated upfront and incur a large memory footprint - reaching upwards of 250MB in my experiments.
Additionally, it is not possible to set an upper bound on how long it would take to find an optimal solution, sometimes taking over forty minutes to complete!
When running tests, I found that any scramble exceeding ten random turns (starting from the goal state) resulted in an undesired wait for the client to return.
Although optimal, the memory and time footprint led me to continue my search to find a better fit for the target platform.</p><h3 id=thistlethwaites-and-kociembas-algorithms>Thistlethwaite&rsquo;s and Kociemba&rsquo;s Algorithms</h3><p>Based on the above evaluation, I instead sought to provide a solution that was <em>good enough</em> - averaging an upper bound of thirty-five moves or fewer.
Both <a href=https://www.jaapsch.net/puzzles/thistle.htm rel="external noopener" target=_blank>Morwen Thistlethwaite&rsquo;s</a> and the improved <a href=https://en.wikipedia.org/wiki/Optimal_solutions_for_Rubik%27s_Cube#Kociemba%27s_algorithm rel="external noopener" target=_blank>Herbert Kociemba&rsquo;s</a> algorithms solve a given cube using multiple phases (sub-groupings), where only certain moves and properties of the cube are relevant at any given time.
At each phase, we generate a move sequence that satisfies a given property, allowing us to progress toward solving the cube.
Again, pruning tables are used to accelerate transitions between different phases.</p><h3 id=pochmanns-algorithm>Pochmann&rsquo;s Algorithm</h3><p>Before setting out to implement one of the above algorithms, I stumbled upon an interesting <a href=https://www.stefan-pochmann.info/spocc/other_stuff/tools/solver_thistlethwaite/solver_thistlethwaite_cpp.txt rel="external noopener" target=_blank>C++ solver</a> that had a surprisingly small implementation and did not require additional memory for pruning tables!
The <a href=https://www.stefan-pochmann.info/spocc/ rel="external noopener" target=_blank>Stefan Pochmann</a> algorithm takes inspiration from the sub-grouping and multi-phase approach of Thistlethwaite&rsquo;s but instead defines several different requirements to transition between each phase.
This approach may result in a longer move sequence, but it enables the use of Bidirectional Search (as in the Pocket Cube Solver) at each phase, which is trivial to implement.</p><h2 id=building-the-solver>Building the Solver</h2><p>With multiple algorithms available to solve a Rubik&rsquo;s Cube, I designed my solution to accommodate multiple solvers being <em>plugged into</em> the same cube representation - achieved using Rust traits.
This approach allows for future exploration of the advantages and disadvantages of each algorithm.
I applied the same level of modularity to the <a href=https://github.com/eddmann/rubik-cube-solver/blob/main/solver/src/cube.rs rel="external noopener" target=_blank>cube</a> itself, recognising that different aspects of the cube are relevant depending on the algorithm used.</p><p>I decided to implement Pochmann&rsquo;s algorithm first, as it allowed me to leverage much of the knowledge and code from the 2x2x2 cube solver.
Using the Rubik&rsquo;s Cube model I built, I applied a simple representation translation that let me reference much of the original C++ implementation.
The only additional optimisation involved simplifying <a href=https://github.com/eddmann/rubik-cube-solver/blob/main/solver/src/pochmann_solver.rs#L302 rel="external noopener" target=_blank>multi-face turn moves</a> occurring between phases.
Once the solver was <a href=https://github.com/eddmann/rubik-cube-solver/blob/main/solver/src/pochmann_solver.rs rel="external noopener" target=_blank>implemented</a> and adequately tested, I moved on to visualising the solution for the client.</p><h2 id=visualising-the-solution>Visualising the Solution</h2><p>Similar to how I visualised the Pocket Cube, I reused much of the same model built for that solution.
Using a combination of React, <a href=https://threejs.org/ rel="external noopener" target=_blank>Three.js</a>, <a href=https://github.com/pmndrs/react-three-fiber rel="external noopener" target=_blank>react-three-fiber</a>, and TypeScript, I expanded upon the 2x2x2 design by adding the necessary additional <em>cubies</em> and rotation animation adjustments.
I was very pleased with how the previous work on the Pocket Cube could be adapted and expanded upon for this project.</p><p><a href=https://eddmann.com/rubik-cube-solver/><img src=solution.gif alt="Visualising the Solution"></a></p><h2 id=conclusion>Conclusion</h2><p>To conclude, exploring prior work in solving a 3x3x3 Rubik&rsquo;s Cube has been very insightful.
Being able to reuse much of the code from the <a href=https://eddmann.com/pocket-cube-solver/>2x2x2 solver</a> was immensely helpful, allowing me to focus on the unique challenges of building the solver.
Moving forward, I plan to expand beyond the single implemented solver, giving users the ability to select additional solvers (e.g., Thistlethwaite&rsquo;s and Kociemba&rsquo;s) for experimentation.</p></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/rubiks-cube>rubiks-cube</a></li><li><a href=/archive/tag/typescript>typescript</a></li><li><a href=/archive/tag/rust>rust</a></li><li><a href=/archive/tag/react>react</a></li><li><a href=/archive/tag/threejs>threejs</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/building-an-optimal-pocket-cube-solver-using-rust-wasm-threejs-and-react/>Building an optimal Pocket Cube (2x2x2) Solver using Rust/WASM and Three.js/React</a></li><li><a href=/posts/creating-a-react-based-chess-game-with-wasm-bots-in-typescript/>Creating a React-based Chess Game with WASM Bots in TypeScript</a></li><li><a href=/posts/advent-of-code-2015-day-25-let-it-snow/>Advent of Code 2015 - Day 25 - Let It Snow</a></li><li><a href=/posts/advent-of-code-2015-day-24-it-hangs-in-the-balance/>Advent of Code 2015 - Day 24 - It Hangs in the Balance</a></li><li><a href=/posts/advent-of-code-2015-day-23-opening-the-turing-lock/>Advent of Code 2015 - Day 23 - Opening the Turing Lock</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>