<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Advent of Code 2015 - Day 17 - No Such Thing as Too Much - Edd Mann</title>
<meta name=description content="Solving the Advent of Code 2015 Day 17 puzzle using TypeScript."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Advent of Code 2015 - Day 17 - No Such Thing as Too Much"><meta itemprop=description content="On the seventeenth day of Advent of Code 2015, the elves bought 150 litres of eggnog that we are asked to fit in the supplied containers for refrigeration."><meta itemprop=datePublished content="2021-02-10T00:00:00+00:00"><meta itemprop=dateModified content="2021-02-10T00:00:00+00:00"><meta itemprop=wordCount content="550"><meta itemprop=keywords content="Advent-of-Code,Advent-of-Code-2015,Typescript"><meta property="og:url" content="https://eddmann.com/posts/advent-of-code-2015-day-17-no-such-thing-as-too-much/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Advent of Code 2015 - Day 17 - No Such Thing as Too Much"><meta property="og:description" content="On the seventeenth day of Advent of Code 2015, the elves bought 150 litres of eggnog that we are asked to fit in the supplied containers for refrigeration."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2021-02-10T00:00:00+00:00"><meta property="article:modified_time" content="2021-02-10T00:00:00+00:00"><meta property="article:tag" content="Advent-of-Code"><meta property="article:tag" content="Advent-of-Code-2015"><meta property="article:tag" content="Typescript"><meta name=twitter:card content="summary"><meta name=twitter:title content="Advent of Code 2015 - Day 17 - No Such Thing as Too Much"><meta name=twitter:description content="On the seventeenth day of Advent of Code 2015, the elves bought 150 litres of eggnog that we are asked to fit in the supplied containers for refrigeration."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.0121a173d3063b9541f1f561a87125fd59dc1fac6110b21c15bba8bc141b70b1.css integrity="sha256-ASGhc9MGO5VB8fVhqHEl/VncH6xhELIcFbuovBQbcLE="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/advent-of-code-2015-day-17-no-such-thing-as-too-much/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Advent of Code 2015 - Day 17 - No Such Thing as Too Much</h1><time class=post__time>Feb 10, 2021</time></header><main class=prose><p>On the seventeenth day of Advent of Code 2015, the elves bought 150 litres of eggnog that we are asked to fit in the supplied containers for refrigeration.</p><h2 id=part-1>Part 1</h2><p>We are supplied with a list of all the different-sized containers available to us as input, and for part one, we are asked how many combinations of these will fit the 150-litre requirement.
At its core, today centres around the <a href=https://en.wikipedia.org/wiki/Subset_sum_problem rel="external noopener" target=_blank>Subset Sum problem</a>, whereby given a <a href=https://en.wikipedia.org/wiki/Multiset rel="external noopener" target=_blank>Multiset</a>, we are required to find all the possible subsets that sum to a given number (in this case, 150).
We begin by parsing the supplied containers into a form we can then process.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>parseContainers</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>input</span>.<span style=color:#a6e22e>split</span>(<span style=color:#e6db74>&#39;\n&#39;</span>).<span style=color:#a6e22e>map</span>(<span style=color:#a6e22e>toInt</span>);
</span></span></code></pre></div><p>There are several popular ways to solve the Subset Sum problem, each with its own complexity characteristics.
Due to the input being relatively small, I have opted for the native combinations approach, with a small optimisation to prune subsets that have already exceeded the desired total.
In the future, I hope to spend some time investigating how Dynamic Programming can help improve performance.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>subsetSum</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>numbers</span>: <span style=color:#66d9ef>number</span>[], <span style=color:#a6e22e>target</span>: <span style=color:#66d9ef>number</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span>[][] <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>recur</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>remaining</span>: <span style=color:#66d9ef>number</span>[], <span style=color:#a6e22e>subset</span>: <span style=color:#66d9ef>number</span>[]) <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>total</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>reduce</span>(<span style=color:#a6e22e>sum</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>total</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>target</span>) <span style=color:#66d9ef>return</span> [<span style=color:#a6e22e>subset</span>];
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>total</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>target</span>) <span style=color:#66d9ef>return</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>remaining</span>.<span style=color:#a6e22e>flatMap</span>((<span style=color:#a6e22e>n</span>, <span style=color:#a6e22e>i</span>) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>recur</span>(<span style=color:#a6e22e>remaining</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), [...<span style=color:#a6e22e>subset</span>, <span style=color:#a6e22e>n</span>])
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>recur</span>(<span style=color:#a6e22e>numbers</span>, []);
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>The above implementation uses a recursive closure to iterate through all the possible subsets.
An optimisation I omitted would be to check upon each iteration whether the sum of the current total and remaining numbers is less than the target.
If this is the case, we can prune these branches, as we know that no following subset will meet the desired criteria.</p><p>Following on from this, I also spent some time implementing the same recursive approach using Generators.
I find that recursive problems such as this can be succinctly defined in this manner.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>subsetSum</span>(
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>numbers</span>: <span style=color:#66d9ef>number</span>[],
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>target</span>: <span style=color:#66d9ef>number</span>
</span></span><span style=display:flex><span>)<span style=color:#f92672>:</span> <span style=color:#a6e22e>Generator</span>&lt;<span style=color:#f92672>number</span><span style=color:#960050;background-color:#1e0010>[]</span>&gt; {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>function</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>recur</span>(<span style=color:#a6e22e>remaining</span>: <span style=color:#66d9ef>number</span>[], <span style=color:#a6e22e>subset</span>: <span style=color:#66d9ef>number</span>[]) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>total</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>reduce</span>(<span style=color:#a6e22e>sum</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>total</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>target</span>) <span style=color:#66d9ef>yield</span> <span style=color:#a6e22e>subset</span>;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>total</span> <span style=color:#f92672>&gt;=</span> <span style=color:#a6e22e>target</span>) <span style=color:#66d9ef>return</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>let</span> <span style=color:#a6e22e>i</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>; <span style=color:#a6e22e>i</span> <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>remaining</span>.<span style=color:#a6e22e>length</span>; <span style=color:#a6e22e>i</span><span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>      <span style=color:#66d9ef>yield</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>recur</span>(<span style=color:#a6e22e>remaining</span>.<span style=color:#a6e22e>slice</span>(<span style=color:#a6e22e>i</span> <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>), [...<span style=color:#a6e22e>subset</span>, <span style=color:#a6e22e>remaining</span>[<span style=color:#a6e22e>i</span>]]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>yield</span><span style=color:#f92672>*</span> <span style=color:#a6e22e>recur</span>(<span style=color:#a6e22e>numbers</span>, []);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the ability to now determine all the possible subsets that sum to the given number, we can answer the first part of today&rsquo;s problem ðŸŒŸ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part1</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>subsetSum</span>(<span style=color:#a6e22e>parseContainers</span>(<span style=color:#a6e22e>input</span>), <span style=color:#ae81ff>150</span>).<span style=color:#a6e22e>length</span>;
</span></span></code></pre></div><h2 id=part-2>Part 2</h2><p>For part two, we are asked to investigate the possible subsets further, determining how many combinations of the least number of containers we can use.
Again, due to the search space being so small, we can harness the same functionality implemented in part one and construct an occurrences map per subset length.
With this occurrence mapping, we can then work out the smallest subset length present and return this count to answer part two ðŸŒŸ.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-typescript data-lang=typescript><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>part2</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>input</span>: <span style=color:#66d9ef>string</span>)<span style=color:#f92672>:</span> <span style=color:#66d9ef>number</span> <span style=color:#f92672>=&gt;</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>sizes</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>subsetSum</span>(<span style=color:#a6e22e>parseContainers</span>(<span style=color:#a6e22e>input</span>), <span style=color:#ae81ff>150</span>).<span style=color:#a6e22e>reduce</span>(
</span></span><span style=display:flex><span>    (<span style=color:#a6e22e>sizes</span>, <span style=color:#a6e22e>subset</span>) <span style=color:#f92672>=&gt;</span>
</span></span><span style=display:flex><span>      <span style=color:#a6e22e>sizes</span>.<span style=color:#66d9ef>set</span>(<span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>length</span>, (<span style=color:#a6e22e>sizes</span>.<span style=color:#66d9ef>get</span>(<span style=color:#a6e22e>subset</span>.<span style=color:#a6e22e>length</span>) <span style=color:#f92672>||</span> <span style=color:#ae81ff>0</span>) <span style=color:#f92672>+</span> <span style=color:#ae81ff>1</span>),
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>new</span> <span style=color:#a6e22e>Map</span>&lt;<span style=color:#f92672>number</span>, <span style=color:#a6e22e>number</span>&gt;()
</span></span><span style=display:flex><span>  );
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>sizes</span>.<span style=color:#66d9ef>get</span>(Math.<span style=color:#a6e22e>min</span>(...<span style=color:#a6e22e>sizes</span>.<span style=color:#a6e22e>keys</span>()));
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>As in part one, there are more performant solutions to achieving this end result.
In the future, I hope to explore the Subset Sum problem in more detail and investigate these options.</p></main><footer class=post__tags><a href=/archive/tag/advent-of-code>advent-of-code</a><a href=/archive/tag/advent-of-code-2015>advent-of-code-2015</a><a href=/archive/tag/typescript>typescript</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>