<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Asynchronous Calls within Flux - Edd Mann</title>
<meta name=description content="An in-depth exploration of managing asynchronous calls within the Flux architecture to enhance testing and design in React applications."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Asynchronous Calls within Flux"><meta itemprop=description content="The Flux architecture abides by a single unidirectional data-flow throughout the entire application. This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies. However, one issue we faced in our recently updated interface that tradesmen use to communicate with customers was how to handle asynchronous calls within these constraints. Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries."><meta itemprop=datePublished content="2015-10-28T00:00:00+00:00"><meta itemprop=dateModified content="2015-10-28T00:00:00+00:00"><meta itemprop=wordCount content="1150"><meta itemprop=keywords content="Flux,React,Javascript"><meta property="og:url" content="https://eddmann.com/posts/asynchronous-calls-within-flux/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Asynchronous Calls within Flux"><meta property="og:description" content="The Flux architecture abides by a single unidirectional data-flow throughout the entire application. This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies. However, one issue we faced in our recently updated interface that tradesmen use to communicate with customers was how to handle asynchronous calls within these constraints. Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2015-10-28T00:00:00+00:00"><meta property="article:modified_time" content="2015-10-28T00:00:00+00:00"><meta property="article:tag" content="Flux"><meta property="article:tag" content="React"><meta property="article:tag" content="Javascript"><meta name=twitter:card content="summary"><meta name=twitter:title content="Asynchronous Calls within Flux"><meta name=twitter:description content="The Flux architecture abides by a single unidirectional data-flow throughout the entire application. This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies. However, one issue we faced in our recently updated interface that tradesmen use to communicate with customers was how to handle asynchronous calls within these constraints. Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.020af028a86e4141eddb604604567804a169da6a588b326f18d39cd2db3b5eb4.css integrity="sha256-AgrwKKhuQUHt22BGBFZ4BKFp2mpYizJvGNOc0ts7XrQ="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/asynchronous-calls-within-flux/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.1052707861642a4eb63c758a2c16cbf5deb3b3ea2582f09f743a7d4c55fb9828.js integrity="sha256-EFJweGFkKk62PHWKLBbL9d6zs+olgvCfdDp9TFX7mCg=" defer></script></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1 class=transition-between-pages style=--id:asynchronous-calls-within-flux>Asynchronous Calls within Flux</h1><time datetime=2015-10-28T00:00:00Z class=post__time>Oct 28, 2015</time></header><main class=prose><p>The Flux architecture abides by a single unidirectional data-flow throughout the entire application.
This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies.
However, one issue we faced in our recently updated interface that tradesmen use to communicate with customers was how to handle asynchronous calls within these constraints.
Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries.</p><h2 id=basic-component-example>Basic Component Example</h2><p>There is a common use-case within client-side applications to both push and fetch data from an external resource asynchronously.
In the contrived component below we provide the client with the ability to act upon the enter-key being hit with a supplied submission handler.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TaskInput</span> <span style=color:#66d9ef>extends</span> <span style=color:#a6e22e>React</span>.<span style=color:#a6e22e>Component</span> {
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>ENTER_KEY</span> <span style=color:#f92672>=</span> <span style=color:#ae81ff>13</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>_handleSubmit</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>e</span>) =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>keyCode</span> <span style=color:#f92672>===</span> <span style=color:#a6e22e>ENTER_KEY</span>) {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>props</span>.<span style=color:#a6e22e>onSubmit</span>(<span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>target</span>.<span style=color:#a6e22e>value</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>e</span>.<span style=color:#a6e22e>preventDefault</span>();
</span></span><span style=display:flex><span>  };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>render</span>() {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#f92672>&lt;</span><span style=color:#a6e22e>input</span> <span style=color:#a6e22e>type</span><span style=color:#f92672>=</span><span style=color:#e6db74>&#34;text&#34;</span> <span style=color:#a6e22e>onKeyUp</span><span style=color:#f92672>=</span>{<span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>_handleSubmit</span>} <span style=color:#f92672>/&gt;</span>;
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=asynchronous-calls-within-components>Asynchronous Calls within Components</h2><p>We initially decided to keep the asynchronous call and response logic within the component itself.
This included the dispatch of either a success or fail action upon handling the result - due to external resource concerns (i.e. network issues, server-based validation) we could not be sure that a successful path would always occur.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>const</span> <span style=color:#a6e22e>postJson</span> <span style=color:#f92672>=</span> (<span style=color:#a6e22e>endpoint</span>, <span style=color:#a6e22e>payload</span>) =&gt;
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>fetch</span>(<span style=color:#a6e22e>endpoint</span>, {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>method</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;post&#39;</span>,
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>headers</span><span style=color:#f92672>:</span> { <span style=color:#e6db74>&#39;Content-Type&#39;</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;application/json&#39;</span> },
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>body</span><span style=color:#f92672>:</span> <span style=color:#a6e22e>JSON</span>.<span style=color:#a6e22e>stringify</span>(<span style=color:#a6e22e>payload</span>),
</span></span><span style=display:flex><span>  });
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>TaskInput</span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>onSubmit</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>message</span> =&gt; {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postJson</span>(<span style=color:#e6db74>&#39;/post&#39;</span>, { <span style=color:#a6e22e>message</span> })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>task</span> =&gt; <span style=color:#a6e22e>dispatch</span>({ <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;RECEIVE_TASK&#39;</span>, <span style=color:#a6e22e>task</span> }))
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#a6e22e>dispatch</span>({ <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;TASK_ERROR&#39;</span>, <span style=color:#a6e22e>error</span> }));
</span></span><span style=display:flex><span>  }}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>/&gt;</span>
</span></span></code></pre></div><p><picture><source type=image/webp srcset="/posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_eb11fadfb30428ee.webp 350w, /posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_93b58f31e1555f07.webp 700w, /posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_7bb4bdd80cd39f8d.webp 1400w"><source type=image/jpeg srcset="/posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_f926ade004f2b06.jpg 350w, /posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_8e4303be4bcb0414.jpg 700w, /posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_f7671bb6158a2e1a.jpg 1400w"><img src=/posts/asynchronous-calls-within-flux/asynchronous-calls-within-components_hu_8e4303be4bcb0414.jpg alt="Asynchronous Calls within Components" loading=lazy></picture></p><p>Although the above paradigm worked, we noticed many issues arise from its presence.
The first of which was how all the logic had now been co-located within the view layer.
You could question whether at this level it is necessary to know of these low-level details about how we were submitting a task.
More strongly put, creating and handling the external resource request did not seem to be a responsibility of the component at all.
This coupling, in turn, made it harder to test the component&rsquo;s behaviour, as now to validate that a submission is sent we were required to provide an environment where (the implementation detail) <code>fetch</code> is present.
Finally, the component itself was the only member of the system that knew of the client&rsquo;s desire to add the task.
It is not until the request had been resolved or rejected did we let the dispatcher (and in-turn the system as a whole) know about this intent and resolution.</p><h2 id=web-api-and-action-creator-addition>Web API and Action Creator Addition</h2><p>To begin trying to resolve these highlighted issues we decided to first abstract out the two raw dispatch calls into an &lsquo;<a href=https://facebook.github.io/flux/docs/actions-and-the-dispatcher.html#actions-and-action-creators rel="external noopener" target=_blank>Action Creator</a>&rsquo;.
This allowed us to devise a clean API which did not concern the callee with what dispatch calls, etc. were being fired in response to their invocation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ServerActions</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>receiveTask</span>(<span style=color:#a6e22e>task</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dispatch</span>({ <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;RECEIVE_TASK&#39;</span>, <span style=color:#a6e22e>task</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>taskError</span>(<span style=color:#a6e22e>error</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dispatch</span>({ <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;TASK_ERROR&#39;</span>, <span style=color:#a6e22e>error</span> });
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Using this Action Creator we then went about abstracting out the external API call into a &lsquo;Web API&rsquo;, supplying the available server actions at runtime.
This provided us with the ability to easily swap out real actions with test doubles, validating the correctness of API calls within the testing phase.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebAPI</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>serverActions</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>message</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postJson</span>(<span style=color:#e6db74>&#39;/post&#39;</span>, { <span style=color:#a6e22e>message</span> })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>task</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverActions</span>.<span style=color:#a6e22e>receiveTask</span>(<span style=color:#a6e22e>task</span>))
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverActions</span>.<span style=color:#a6e22e>taskError</span>(<span style=color:#a6e22e>error</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>With the addition of these two members, we could simply replace the submission logic found in the component with a call directly to the Web API.
This refactoring made it easier to now test the component in isolation as well, with only a Web API test double instance being required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>TaskInput</span> <span style=color:#a6e22e>onSubmit</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>message</span> =&gt; <span style=color:#a6e22e>webApi</span>.<span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>message</span>)} <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p><picture><source type=image/webp srcset="/posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_50bd95043a7ff692.webp 350w, /posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_1105b4630933d8a5.webp 700w, /posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_91e52934fb498f16.webp 1363w"><source type=image/jpeg srcset="/posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_8e3a6de6d57929bb.jpg 350w, /posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_dbb3b8fd1b4004d0.jpg 700w, /posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_fd5f90ccd5bf3f7e.jpg 1363w"><img src=/posts/asynchronous-calls-within-flux/web-api-and-action-creator-addition_hu_dbb3b8fd1b4004d0.jpg alt="Web API and Action Creator Addition" loading=lazy></picture></p><p>However, there were still issues that persisted after this refactoring.
Still the component and, now additionally, the Web API were the only ones aware of this action being carried out within the system.
At present, there was no way of providing the user with an optimistic representation of what the application state would look like - not until the response had been returned.</p><h2 id=optimistic-asynchronous-calls>Optimistic Asynchronous Calls</h2><p>At present, as we are not sure when the asynchronous call will return, we did not notify the system of any event until the promise had been resolved or rejected.
However, we felt that it would be a far better user experience to optimistically apply the request to the current client state and reconcile this action when the asynchronous event returned.</p><p>To achieve this we decided to abstract out the call made to the Web API into its own action creator.
We then dispatched a new action which, provided with a unique client id, optimistically performed the resulting resolution.
It would then go about calling the Web API as per the previous implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>ClientActions</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>webApi</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>message</span>) {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>const</span> <span style=color:#a6e22e>clientId</span> <span style=color:#f92672>=</span> <span style=color:#a6e22e>uniqueId</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>dispatch</span>({ <span style=color:#a6e22e>type</span><span style=color:#f92672>:</span> <span style=color:#e6db74>&#39;ADD_TASK&#39;</span>, <span style=color:#a6e22e>clientId</span>, <span style=color:#a6e22e>message</span> });
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>webApi</span>.<span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>clientId</span>, <span style=color:#a6e22e>message</span>);
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looking at the implementation above you will notice that we generated a random <code>clientId</code> which is used to temporarily identify the created resource until the external API provides us with a canonical id.
The Web API and server actions were in-turn required to be altered to cater for this temporary identifier.
Stores that were concerned with this action could add the pending resource as they desired, maybe including it with appended meta information (i.e. status: &lsquo;ADDING&rsquo;).
Finally, when the result from the asynchronous request had been received, the stores could go about reconciling their state, i.e. replacing the temporary id with the supplied one or removing it if there had been an error.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#66d9ef>class</span> <span style=color:#a6e22e>WebApi</span> {
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>serverActions</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#75715e>// ...
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span>  <span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>clientId</span>, <span style=color:#a6e22e>message</span>) {
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>postJson</span>(<span style=color:#e6db74>&#39;/post&#39;</span>, { <span style=color:#a6e22e>message</span> })
</span></span><span style=display:flex><span>      .<span style=color:#a6e22e>then</span>(<span style=color:#a6e22e>task</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverActions</span>.<span style=color:#a6e22e>recieveTask</span>(<span style=color:#a6e22e>clientId</span>, <span style=color:#a6e22e>task</span>))
</span></span><span style=display:flex><span>      .<span style=color:#66d9ef>catch</span>(<span style=color:#a6e22e>err</span> =&gt; <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>serverActions</span>.<span style=color:#a6e22e>taskError</span>(<span style=color:#a6e22e>clientId</span>, <span style=color:#a6e22e>error</span>));
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>We could now access the updated task action by way of the client actions creator abstraction.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-js data-lang=js><span style=display:flex><span><span style=color:#f92672>&lt;</span><span style=color:#a6e22e>TaskInput</span> <span style=color:#a6e22e>onSubmit</span><span style=color:#f92672>=</span>{<span style=color:#a6e22e>message</span> =&gt; <span style=color:#a6e22e>clientActions</span>.<span style=color:#a6e22e>addTask</span>(<span style=color:#a6e22e>message</span>)} <span style=color:#f92672>/&gt;</span>
</span></span></code></pre></div><p><picture><source type=image/webp srcset="/posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_7e963458a347bcac.webp 350w, /posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_f5e649f641d6957a.webp 700w, /posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_bf836978aabe0c70.webp 1400w"><source type=image/jpeg srcset="/posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_8ef0e8353d691bbb.jpg 350w, /posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_4cac1ad91eeac512.jpg 700w, /posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_aa6cf0bf38c8da1d.jpg 1400w"><img src=/posts/asynchronous-calls-within-flux/optimistic-asynchronous-calls_hu_4cac1ad91eeac512.jpg alt="Optimistic Asynchronous Calls" loading=lazy></picture></p><p>To conclude, this final refactoring allowed us to clearly visualise and work within specific boundaries of the application, all with their own rates of change.
We have found a significant ease in testing areas of the application in isolation, as well as a far easier to reason about mental model.
Below is a list of some of the key strengths within testing that we have found since incorporating this model into our architecture:</p><ul><li>We can easily validate the correctness of a Component&rsquo;s contractual calls to Client Actions.</li><li>Client Actions can be tested by assertion of store state after they have been invoked, along with their contractual calls to Web APIs.</li><li>The Web API can be tested to ensure that it works with the external resource, by way of what is returned to the Server Action methods.</li><li>The Server Actions can be invoked and application store state asserted for the correctness of their actions.</li></ul><p>If you wish to see a full example of these concepts in practice, you can check out the <a href=https://github.com/mybuilder/task-app rel="external noopener" target=_blank>task-app</a> repository on GitHub.</p></main><footer class=post__tags><a href=/archive/tag/flux>flux</a><a href=/archive/tag/react>react</a><a href=/archive/tag/javascript>javascript</a></footer></article><div class="related-posts prose"><h3>Related Posts</h3><ul><li><a href=/posts/arabic-to-roman-numerals-converter-in-javascript/>Arabic to Roman Numerals Converter in JavaScript</a></li><li><a href=/posts/cartesian-product-in-javascript/>Cartesian Product in JavaScript</a></li><li><a href=/posts/peano-numbers-and-arithmetic-in-javascript/>Peano Numbers and Arithmetic in JavaScript</a></li><li><a href=/posts/implementing-classical-inheritance-in-javascript/>Implementing Classical Inheritance in JavaScript</a></li><li><a href=/posts/how-the-new-keyword-works-in-javascript/>How the 'new' keyword works in JavaScript</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div><button class=theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>