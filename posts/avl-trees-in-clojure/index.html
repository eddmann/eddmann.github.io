<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Implementing the self-balancing AVL binary search tree in Clojure">

    <title>
        
            AVL Trees in Clojure &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">AVL Trees in Clojure</h1>
    <time datetime="2016-09-03T00:00:00+00:00" class="post-date">03 Sep 2016</time>
    <p>An AVL tree is a self-balancing binary search tree, where-by the height of a node’s children differ by at most one.
In the event that this property is violated a re-balancing process takes place. 
In the past I have discussed how to implement a <a href="/posts/binary-search-trees-in-clojure/">Binary Search Tree in Clojure</a>, providing average time complexity of O(log n).
However, in the event that the order of insertion is sequential (either every value greater than, or every value less than the last), time complexity increases to be linear, the same as a linked-list.
Self-balancing trees such as the AVL variant provide us with the familiar worst-case of O(log n), thanks to it’s re-balancing phase.</p>

<h3 id="balance-factor">Balance Factor</h3>

<p>Using the previous Binary Search Tree implementation as a base, we are able to expand upon this to include the AVL property.
For the sake of performance you would typically store the height of each nodes children within the structure, however, as I wish to re-use the existing implementation I will instead calculate their height upon <code class="language-plaintext highlighter-rouge">factor</code> invocation.
The balance factor per. node is calculated by the difference between the two child node’s heights, as shown below.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">height</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="w"> </span><span class="nb">count</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">tree</span><span class="w">
      </span><span class="p">(</span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">))</span><span class="w">
           </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="nb">count</span><span class="p">)))</span><span class="w">
      </span><span class="nb">count</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">factor</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]}]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">height</span><span class="w"> </span><span class="nb">right</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>The above two functions provide us with the described behavior, allowing us to supply a root node and return it’s balance factor.</p>

<h3 id="rotations">Rotations</h3>

<p>So as to complete the final re-balancing step we must also be able to rotate a given node both left and right within the tree structure.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate-left</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">right</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="p">(</span><span class="no">:el</span><span class="w"> </span><span class="nb">right</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="n">tree</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">rotate-right</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="nb">left</span><span class="w">
    </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="p">(</span><span class="no">:el</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="n">tree</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>This can be achieved as shown above, taking advantage of an immutable approach.</p>

<h3 id="re-balancing-phase">Re-balancing Phase</h3>

<p>With the balance factor and rotation actions now available, we are able to begin work on the four different situations a node could be placed in that would require a tree rotation.</p>

<p><img src="/uploads/avl-trees-in-clojure/lr-ll-cases.png" alt="Left Right, Left Left Cases" /></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-left-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="mi">-1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-left-right-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">is-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="p">(</span><span class="no">:right</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p><img src="/uploads/avl-trees-in-clojure/rl-rr-cases.png" alt="Right Left, Right Right Cases" /></p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-right-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="mi">1</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-right-left-case?</span><span class="w"> </span><span class="p">[</span><span class="n">tree</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">and</span><span class="w"> </span><span class="p">(</span><span class="nf">is-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">&lt;</span><span class="w"> </span><span class="p">(</span><span class="nf">factor</span><span class="w"> </span><span class="p">(</span><span class="no">:left</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w"> </span><span class="mi">0</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>With these conditions now locatable, we can apply the desired tree rotations which can be seen visualised in the diagrams above.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="p">[{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}]</span><span class="w">
  </span><span class="p">(</span><span class="k">cond</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-right-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="nb">left</span><span class="p">)</span><span class="w"> </span><span class="nb">right</span><span class="p">))</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-left-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;Node</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="nb">right</span><span class="p">)))</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-right-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-right</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w">
    </span><span class="p">(</span><span class="nf">is-left-case?</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">rotate-left</span><span class="w"> </span><span class="n">tree</span><span class="p">)</span><span class="w">
    </span><span class="no">:else</span><span class="w"> </span><span class="n">tree</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<h3 id="example-usage">Example Usage</h3>

<p>Finally, we are able to create a new AVL insertion/deletion variant, that is a composition of the Binary Search Tree functions and the newly created <code class="language-plaintext highlighter-rouge">balance</code> one.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">avl-insert</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="n">insert</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">avl-remove</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">balance</span><span class="w"> </span><span class="nb">remove</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">seq-&gt;avl</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">reduce</span><span class="w"> </span><span class="n">avl-insert</span><span class="w"> </span><span class="n">nil</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>These created data-structures can then be visualised using the following function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">tabs</span><span class="w"> </span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">clojure.string/join</span><span class="p">(</span><span class="nb">repeat</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="s">"\t"</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">visualise</span><span class="w">
  </span><span class="p">([</span><span class="n">tree</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="n">tree</span><span class="w"> </span><span class="mi">0</span><span class="p">))</span><span class="w">
  </span><span class="p">([{</span><span class="no">:keys</span><span class="w"> </span><span class="p">[</span><span class="n">el</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="nb">right</span><span class="p">]</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">tree</span><span class="p">}</span><span class="w"> </span><span class="n">depth</span><span class="p">]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="n">tree</span><span class="w">
      </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="nb">right</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">))</span><span class="w"> </span><span class="p">(</span><span class="nf">tabs</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="n">el</span><span class="w"> </span><span class="s">"\n"</span><span class="w"> </span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="nb">left</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">depth</span><span class="p">)))</span><span class="w">
      </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">tabs</span><span class="w"> </span><span class="n">depth</span><span class="p">)</span><span class="w"> </span><span class="s">"~\n"</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="nf">visualise</span><span class="w"> </span><span class="p">(</span><span class="nf">seq-&gt;avl</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">]))</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">;       3</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">; 2</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span><span class="c1">;       1</span><span class="w">
</span><span class="c1">;              ~</span><span class="w">
</span></code></pre></div></div>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
