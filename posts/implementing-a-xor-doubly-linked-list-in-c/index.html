<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Learn how to implement a memory efficient XOR doubly linked-list in C for effective low-level memory management.">

    <title>
        
            Implementing a XOR Doubly Linked-List in C &middot; Edd Mann
        
    </title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Implementing a XOR Doubly Linked-List in C</h1>
    <time datetime="2014-01-03T00:00:00+00:00" class="post-date">03 Jan 2014</time>
    <p>This post examines the implementation of a XOR doubly linked-list in C.
It provides a detailed explanation of how pointer arithmetic combined with the XOR operation can reduce memory usage in a linked list.
The discussion covers both the benefits and the challenges of managing memory at a low level in C.</p>



<h2 id="what-about-java">What about Java?</h2>

<p>After experimenting with the <a href="/posts/experimenting-with-the-xor-swap-method-in-java/">XOR swap method in Java</a> I had hoped to follow it up with an exploration of the XOR doubly linked-list.
Java objects, however, are not directly accessible through pointer reference.
This is by no means a limitation, as it allows the garbage collector to efficiently and safely handle memory allocation.
Sometimes it is desired to have such access, and you can take advantage of <a href="http://en.wikipedia.org/wiki/Java_Native_Interface">JNI</a> to call assembly, or C/C++ code from within Java.
Another option is to use the <a href="http://mishadoff.github.io/blog/java-magic-part-4-sun-dot-misc-dot-unsafe/">sun.misc.Unsafe</a> class, which provides many <em>unsafe</em> operations, one of which is to retrieve object memory address locations.</p>

<h2 id="time-for-some-c">Time for some C</h2>

<p>Despite these alternatives, I felt compelled to continue my exploration of C.
I implemented this data structure using a language with robust (albeit scary) low-level memory-management support.
From previous posts you are aware that a doubly linked list stores items with pointers in both directions.
This allows for traversal both forwards and backwards, albeit at the expense of having to store two pointers per element.
Through the magic of the bitwise XOR operation, however, we are able to store each node’s previous and next pointers in the memory allocated to just one.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdint.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdbool.h&gt;</span><span class="cp">
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">item</span><span class="p">;</span>
    <span class="k">struct</span> <span class="n">node</span> <span class="o">*</span><span class="n">np</span><span class="p">;</span>
<span class="p">}</span> <span class="n">node</span><span class="p">;</span>

<span class="n">node</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="o">*</span><span class="n">tail</span><span class="p">;</span>

<span class="n">node</span> <span class="o">*</span><span class="nf">xor</span><span class="p">(</span><span class="n">node</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">node</span> <span class="o">*</span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="p">)</span> <span class="p">((</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">a</span> <span class="o">^</span> <span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="kt">int</span> <span class="n">item</span><span class="p">,</span> <span class="n">bool</span> <span class="n">at_tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="p">(</span><span class="n">node</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">node</span><span class="p">));</span>
    <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">item</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">tail</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">at_tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">tail</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="n">tail</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">xor</span><span class="p">(</span><span class="n">tail</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">head</span><span class="p">);</span>
        <span class="n">head</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">xor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">));</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">delete</span><span class="p">(</span><span class="n">bool</span> <span class="n">from_tail</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"Empty list.</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
        <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">from_tail</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">tail</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ptr</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">prev</span><span class="p">)</span> <span class="n">head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">prev</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">xor</span><span class="p">(</span><span class="n">prev</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">));</span>
        <span class="n">tail</span> <span class="o">=</span> <span class="n">prev</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">item</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">;</span>
        <span class="n">node</span> <span class="o">*</span><span class="n">next</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">ptr</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">==</span> <span class="n">next</span><span class="p">)</span> <span class="n">tail</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">else</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">np</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">xor</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="n">next</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">));</span>
        <span class="n">head</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="n">free</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">item</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">list</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">curr</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">node</span> <span class="o">*</span><span class="n">prev</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="nb">NULL</span> <span class="o">!=</span> <span class="n">curr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">"%d "</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">item</span><span class="p">);</span>
        <span class="n">next</span> <span class="o">=</span> <span class="n">xor</span><span class="p">(</span><span class="n">prev</span><span class="p">,</span> <span class="n">curr</span><span class="o">-&gt;</span><span class="n">np</span><span class="p">);</span>
        <span class="n">prev</span> <span class="o">=</span> <span class="n">curr</span><span class="p">;</span>
        <span class="n">curr</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">argv</span><span class="p">[])</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">insert</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">6</span><span class="p">);</span>

    <span class="n">list</span><span class="p">();</span> <span class="c1">// 10 9 8 7 6 1 2 3 4 5</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
        <span class="n">delete</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">);</span>

    <span class="n">list</span><span class="p">();</span> <span class="c1">// 8 7 6 1 2 3</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Firstly, I would like to credit <a href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-2/">this</a> post and <a href="http://stackoverflow.com/a/3532455">this</a> StackOverflow answer, which helped shape my implementation.
Since in C we are unable to perform XOR operations on pointers directly, we must first convert them to integers using the <code class="language-plaintext highlighter-rouge">uintptr_t</code> data type and then cast back, as can be seen in the ‘xor’ function.
At its root, the implementation works by storing the resulting XOR value from the previous and next pointer locations for each node.
From this value we are then able to ‘undo’ the operation using the supplied known pointer, returning the other pointer’s value.
If the node appears at the head or tail of the list, the known pointer’s value is XORed with 0 (<code class="language-plaintext highlighter-rouge">NULL</code>), effectively doing nothing.
Below are the different operations that are used to build up and then traverse the list:</p>

<ul>
  <li>previous ^ next = value (stored in node)</li>
  <li>value ^ previous = next (forward)</li>
  <li>value ^ next = previous (backward)</li>
</ul>

<p>Looking at the <code class="language-plaintext highlighter-rouge">list</code> method, you can see that we are able to traverse the list in either direction by calculating the next pointer using the current value and the previous node’s value (starting with NULL).
An issue with this implementation is that it only works if you start traversal from the head or tail, as you are required to know the previous pointer’s value.
This diminishes one of the main advantages of using a doubly linked list, which is the ability to remove any given node by its reference alone.</p>

<h2 id="resources">Resources</h2>

<ul>
  <li><a href="http://www.params.me/2011/06/xor-linked-list-in-java.html">XOR Linked List in Java</a></li>
  <li><a href="http://javapapers.com/core-java/address-of-a-java-object/">Address of a Java Object</a></li>
  <li><a href="http://codethink.no-ip.org/wordpress/archives/712">Resurrecting sun.misc.Unsafe</a></li>
  <li><a href="http://www.geeksforgeeks.org/xor-linked-list-a-memory-efficient-doubly-linked-list-set-2/">XOR Linked List - A Memory Efficient Doubly Linked List</a></li>
  <li><a href="http://stackoverflow.com/questions/3531972/c-code-for-xor-linked-list">C code for XOR linked list</a></li>
</ul>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
