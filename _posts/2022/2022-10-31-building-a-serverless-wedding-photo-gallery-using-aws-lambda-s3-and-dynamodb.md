---
layout: post
title: 'Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB'
meta: 'Explore how to build a serverless wedding photo gallery using AWS Lambda, S3, and DynamoDB, enabling guests to share high-quality photos effortlessly.'
tags: aws lambda s3 dynamodb serverless
---

Whilst [documenting](https://github.com/eddmann/our-wedding-infra#stage-applications) how I structured the [infrastructure](https://github.com/eddmann/our-wedding-infra) used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern.
In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day.
So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place.
I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting.
In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB.
The final implementation can be found in [this GitHub repository](https://github.com/eddmann/our-wedding-gallery).

<!--more-->

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/diagram.png" alt="The AWS architecture diagram" />

## The API

For the backend API, I opted to use the Node 16 (`nodejs16.x`) supported Lambda runtime, conforming to the RESTful Hypertext Application Language (HAL) standard.
Like in previous projects, I used the [Serverless Framework](https://www.serverless.com/) to manage deploying the transient application while leaving the foundational building blocks for Terraform.
Each API endpoint's functionality is split into individually packaged artefacts using [esbuild](https://www.serverless.com/plugins/serverless-esbuild) for bundling and transpilation.
This provides smaller artefacts that only contain the dependencies (such as Sharp, AWS-SDK) which are actually required within each of the desired endpoints.

### Persistence

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/nosql-workbench.png" alt="The DynamoDB table schema" />

For storing the photo metadata and gallery listing (used for infinite scroll), I opted to use a [Single-Table Design](https://www.alexdebrie.com/posts/dynamodb-single-table/) DynamoDB table.
This uses the `PK`/`SK` and `GSI*PK`/`GSI*SK` partition/sort key pattern found in Single-Table Design, allowing optimal data retrieval based on predefined access patterns.

The `GSI1PK` is used as a _hot key_ ðŸ˜¬ for listing the gallery photos in sorted processed timestamp order, using the last evaluated key as a marker to progressively provide the _next_ batch of gallery photos to the client.
Using a _hot key_ is not best practice, but based on this usage pattern and load, it suffices for this use case.

In its current form, the use of a _Single-Table Design_ may seem unnecessary since the application lacks multiple access patterns and concerns.
However, there is future scope to better showcase the idea with additional functionality, such as photo comments.

### Photo Upload and Resizing

Uploaded photos are stored within an initial _upload_ S3 bucket using pre-signed [form POST requests](https://docs.aws.amazon.com/AmazonS3/latest/API/sigv4-UsingHTTPPOST.html), which are generated by the API based on a pre-request supplied by the client.
Upon successful photo upload, the resulting `s3:ObjectCreated` event triggers a Lambda function responsible for moving the photo to the _persistent_ S3 bucket and generating resized web and thumbnail variants in WebP (using [Node.js Sharp](https://sharp.pixelplumbing.com/)).
At the end of this process, a record with the photo's metadata is stored in the DynamoDB table for inclusion in the gallery response.
The initial _upload_ S3 bucket uses a lifecycle rule to clean up any failed photo uploads after seven days.

### Local Development

As stated above, one of my goals was to have local feature parity for development purposes.
Thanks to a combination of [Serverless Offline](https://www.serverless.com/plugins/serverless-offline), [Serverless DynamoDB Local](https://www.serverless.com/plugins/serverless-dynamodb-local), and [Serverless S3 Local](https://www.serverless.com/plugins/serverless-s3-local), I was able to achieve just that ðŸŽ‰.
I was pleasantly surprised at how easy it was to replicate both pre-signing S3 POST requests and handling S3 event triggers thanks to [s3rver](https://github.com/jamhall/s3rver).
Doing this allowed me to have greater confidence in my implementation before deploying it to AWS.

## The Client

<img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/gallery.png" alt="The lazy-loaded photo gallery" style="width: 48%; max-width: 250px; display: inline;" /> <img src="/uploads/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/lightbox.png" alt="The photo lightbox" style="width: 48%; max-width: 250px; display: inline;" />

The client is developed as a Single-Page Application (SPA) using React and Create React App.
I used this project as an opportunity to explore [Tailwind CSS](https://tailwindcss.com/) for presentational concerns.
The client is built statically within the [build pipeline](https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows), distributed via S3, and fronted by CloudFront.
To ensure only authorised users have access to the gallery, a [CloudFront function](https://github.com/eddmann/our-wedding-infra/blob/main/stage/apps/gallery/resources/viewer-request.js) enforces that shared HTTP Basic Authentication credentials are supplied.
As the same CloudFront distribution is used to front the client, API, and S3 buckets, we can be certain that all requests are protected by these security measures.

### Photo Lazy Loading and Lightbox

The gallery is presented as an [infinite scrollable list](https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/PhotoGallery.js), which progressively (lazily) requests the _next_ available batch of photos.
When a photo is clicked on, a full-screen [lightbox variant](https://github.com/eddmann/our-wedding-gallery/blob/main/client/src/component/Lightbox.js) is displayed, providing the ability to visually swipe back and forth (on mobile devices) between photos.
Effectively handling touch events, with graceful desktop mouse click fallback, was an interesting challenge using React Hooks.

## Conclusion

I really enjoyed the chance to add additional functionality that could be hosted within the infrastructure project I had set up for our wedding website.
Being able to replicate all the behaviour within a local setting was very satisfying, enabling a quick REPL for API/client development.
I was also very happy with the decision to structure both the client and API in a [monorepo](https://en.wikipedia.org/wiki/Monorepo), with independent [build pipelines](https://github.com/eddmann/our-wedding-gallery/tree/main/.github/workflows) for any changes that are pushed.

Finally, after seeing how this gallery has been used in practice, I feel the addition of handling video media would be a great future improvement.
Using [AWS Elemental MediaConvert](https://aws.amazon.com/mediaconvert/) as a possible means to process uploaded video media could provide similar _elastic compute_ functionality that Node.js Sharp, hosted on Lambda, does for photos.
