<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Serverless on Edd Mann</title><link>https://eddmann.com/archive/tag/serverless/</link><description>Recent content in Serverless on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Mon, 01 Sep 2025 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/serverless/index.xml" rel="self" type="application/rss+xml"/><item><title>Improving an F1 Picks Game in 4 Hours: It's Lights Out and Away We Go!</title><link>https://eddmann.com/posts/improving-an-f1-picks-game-in-4-hours/</link><pubDate>Mon, 01 Sep 2025 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/improving-an-f1-picks-game-in-4-hours/</guid><description>How I levelled up my F1 Picks game in another 4-hour sprint - leveraging Laravel Boost, LLM-driven guidelines, Tailwind styling, and robust tests with Cursor + GPT-5 - to deliver a F1-inspired upgrade just in time for Dutch GP qualifying.</description></item><item><title>üïµÔ∏è Webhook Spy: A Super-Simple Serverless Webhook Spy Service</title><link>https://eddmann.com/posts/webhook-spy-a-super-simple-serverless-webhook-spy-service/</link><pubDate>Tue, 24 Sep 2024 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/webhook-spy-a-super-simple-serverless-webhook-spy-service/</guid><description>A walkthrough of Webhook Spy ‚Äî a minimal serverless tool for inspecting webhooks and inter-service communication. Built with two Lambdas and DynamoDB, it&amp;rsquo;s fast to deploy, cheap to run, and groups requests effortlessly by path.</description></item><item><title>Exploring NextJS 14 at Full Throttle: An F1 Picks Rebuild</title><link>https://eddmann.com/posts/exploring-nextjs-14-at-full-throttle-an-f1-picks-rebuild/</link><pubDate>Tue, 03 Sep 2024 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/exploring-nextjs-14-at-full-throttle-an-f1-picks-rebuild/</guid><description>I rebuilt my family&amp;rsquo;s Formula 1 prediction game using NextJS 14, embracing new features like the App Router, React Server Components, and Server Actions. Deploying to AWS Lambda with the Lambda Web Adaptor was a fun challenge that pushed me to explore serverless architecture in a modern frontend context. While the code is a bit wild, the journey taught me a ton about the evolving NextJS ecosystem and infrastructure-as-code with CDK.</description></item><item><title>Building an F1 Picks Game in 4 Hours: It's Lights Out and Away We Go!</title><link>https://eddmann.com/posts/building-an-f1-picks-game-in-4-hours/</link><pubDate>Fri, 30 Aug 2024 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/building-an-f1-picks-game-in-4-hours/</guid><description>My family and I have been playing an Formula 1 prediction game for the 2024 season, sharing our picks via WhatsApp and tallying scores manually. Before the F1 summer break ended, I wanted to see how quickly I could build a platform to streamline this process online.</description></item><item><title>Building a Choreographed, Event-Driven Workflow with AWS EventBridge</title><link>https://eddmann.com/posts/building-a-choreographed-event-driven-workflow-with-aws-eventbridge/</link><pubDate>Thu, 20 Jun 2024 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/building-a-choreographed-event-driven-workflow-with-aws-eventbridge/</guid><description>This post walks through building a choreographed, event-driven order fulfilment system on AWS using EventBridge, Lambda, and SQS. It covers how events propagate between subdomains, the trade-offs between choreography and orchestration, and how to handle idempotency, observability, and event schema design. Inspired by a real-world example in Monolith to Microservices, the post also includes infrastructure-as-code examples using both CloudFormation and Terraform.</description></item><item><title>Serverless Transactional Outbox Pattern: Two Practical Approaches</title><link>https://eddmann.com/posts/serverless-transactional-outbox-pattern-two-practical-approaches/</link><pubDate>Fri, 14 Jun 2024 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/serverless-transactional-outbox-pattern-two-practical-approaches/</guid><description>In this post, I explore how to implement the Transactional Outbox pattern using serverless technologies. I compare two practical approaches: one using DynamoDB Streams for event publishing, and the other using a relational database with a polling worker. Each approach has trade-offs, but both ensure atomicity between data changes and event publication.</description></item><item><title>Building a Serverless Wedding Photo Gallery using AWS Lambda, S3 and DynamoDB</title><link>https://eddmann.com/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/</link><pubDate>Mon, 31 Oct 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/building-a-serverless-wedding-photo-gallery-using-aws-lambda-s3-and-dynamodb/</guid><description>&lt;p>Whilst &lt;a href="https://github.com/eddmann/our-wedding-infra#stage-applications" rel="external noopener" target="_blank">documenting&lt;/a> how I structured the &lt;a href="https://github.com/eddmann/our-wedding-infra" rel="external noopener" target="_blank">infrastructure&lt;/a> used for hosting our wedding website, I mentioned the possibility of showcasing its use for another application concern.
In the tradition of over-engineering a problem related to our wedding, we really did not want resized/compressed photos shared through WhatsApp/iMessage of the big day.
So instead, I decided to create a serverless photo gallery that provided guests with the ability to share the original photos in one place.
I also wanted to explore the ability to achieve this while having 100% feature parity locally in a development setting.
In this post, I would like to discuss how I went about building these photo-upload/resizing and lazy-loaded gallery capabilities using AWS Lambda, S3 and DynamoDB.
The final implementation can be found in &lt;a href="https://github.com/eddmann/our-wedding-gallery" rel="external noopener" target="_blank">this GitHub repository&lt;/a>.&lt;/p></description></item><item><title>Managing long-running AWS Fargate ECS tasks within your Serverless project</title><link>https://eddmann.com/posts/managing-long-running-aws-fargate-ecs-tasks-within-your-serverless-project/</link><pubDate>Wed, 16 Mar 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/managing-long-running-aws-fargate-ecs-tasks-within-your-serverless-project/</guid><description>&lt;p>I am a big proponent of the Serverless movement.
The ability to concentrate efforts on only the code and infrastructure concerns that directly add business value is very powerful.
Function-as-a-Service (FaaS) offerings like AWS Lambda impose limitations that help in designing more fault-tolerant and scalable systems, leaning towards event-driven architectures.
However, there are times when we need to execute behaviour that exceeds common FaaS duration limits (i.e. AWS Lambda&amp;rsquo;s 15-minute limit).
In this case, we ideally do not want to resort to a lower level of compute (i.e. a VPS such as EC2), but instead, be able to define and run such behaviour alongside our FaaS counterparts.
In this post, I would like to discuss a &lt;a href="https://github.com/eddmann/serverless-fargate" rel="external noopener" target="_blank">Serverless Framework plugin&lt;/a> I have written, which aids in bridging this gap by way of ECS and &lt;a href="https://aws.amazon.com/fargate/" rel="external noopener" target="_blank">AWS Fargate&lt;/a>.&lt;/p></description></item><item><title>Separating out the Lambda Bref runtime from your project's Composer dependencies</title><link>https://eddmann.com/posts/separating-out-the-lambda-bref-runtime-from-your-projects-composer-dependencies/</link><pubDate>Tue, 08 Feb 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/separating-out-the-lambda-bref-runtime-from-your-projects-composer-dependencies/</guid><description>&lt;p>Having had great success using AWS Lambda within our insurance product (&lt;a href="https://mybuilder-plus.com/" rel="external noopener" target="_blank">MyBuilder Plus&lt;/a>), late last year we made the decision to move &lt;strong>all&lt;/strong> our web request traffic over to the platform!
However, we noticed when attempting to migrate over one application in particular, that we could not use the latest release of &lt;a href="https://bref.sh/" rel="external noopener" target="_blank">Bref&lt;/a> (the PHP runtime) due to a conflict between required Symfony &lt;a href="https://symfony.com/doc/current/components/process.html" rel="external noopener" target="_blank">Process component&lt;/a> versions.&lt;/p></description></item><item><title>Our Wedding Website, Three Years in the Making...</title><link>https://eddmann.com/posts/our-wedding-website-three-years-in-the-making/</link><pubDate>Fri, 28 Jan 2022 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/our-wedding-website-three-years-in-the-making/</guid><description>&lt;p>Like many developers, over-engineering personal projects in the spirit of learning is something I am well aware of doing.
So, when it came time to decide how we were going to collect RSVPs for our upcoming wedding, I already had ideas.
What resulted was a solution that follows DDD, CQRS, Hexagonal Architecture, Event Sourcing, and is deployed on AWS Lambda using PHP.&lt;/p></description></item><item><title>Mince Pie Challenge: Viewing and Removing Mince Pies with Amazon DynamoDB</title><link>https://eddmann.com/posts/mince-pie-challenge-viewing-and-removing-mince-pies-with-amazon-dynamodb/</link><pubDate>Tue, 16 Oct 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-viewing-and-removing-mince-pies-with-amazon-dynamodb/</guid><description>&lt;p>In this post we will progress in implementing the proposed endpoint behaviour documented in our &lt;a href="https://eddmann.com/posts/mince-pie-challenge-designing-the-restful-api-with-raml/#viewing-the-pies">RAML design&lt;/a>.
Using the online/offline DynamoDB abstractions that we constructed in the &lt;a href="https://eddmann.com/posts/mince-pie-challenge-adding-and-listing-mince-pies-with-amazon-dynamodb/">previous post&lt;/a>, we will incorporate the ability to view and remove specified mince pies from the challenge.&lt;/p></description></item><item><title>Mince Pie Challenge: Adding and Listing Mince Pies with Amazon DynamoDB</title><link>https://eddmann.com/posts/mince-pie-challenge-adding-and-listing-mince-pies-with-amazon-dynamodb/</link><pubDate>Thu, 16 Aug 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-adding-and-listing-mince-pies-with-amazon-dynamodb/</guid><description>&lt;p>In the &lt;a href="https://eddmann.com/posts/mince-pie-challenge-adding-the-bootstrap-endpoint-and-serverless-offline/">previous post&lt;/a> we began to implement the API endpoints, starting off with creating the bootstrap response.
We did this in a manner that catered for both online and offline development access.
In this post we will incorporate the ability to add and list mince pies, persisting the state within &lt;a href="https://aws.amazon.com/dynamodb/" rel="external noopener" target="_blank">Amazon DynamoDB&lt;/a>.
Following this, we will enrich our offline development process by setting up an &lt;a href="https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/DynamoDBLocal.html" rel="external noopener" target="_blank">Amazon DynamoDB Local&lt;/a> instance using Docker.&lt;/p></description></item><item><title>Mince Pie Challenge: Adding the Bootstrap Endpoint and Serverless Offline</title><link>https://eddmann.com/posts/mince-pie-challenge-adding-the-bootstrap-endpoint-and-serverless-offline/</link><pubDate>Fri, 27 Jul 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-adding-the-bootstrap-endpoint-and-serverless-offline/</guid><description>&lt;p>Up until now, we have spent our time setting up the API project to provide a confident testing pipeline (with types) and Amazon Cognito authentication.
We will now move on to implementing the first &lt;strong>real&lt;/strong> API endpoint, that being the Bootstrap response.
Along the way, we will configure &lt;a href="https://github.com/dherault/serverless-offline" rel="external noopener" target="_blank">Serverless Offline&lt;/a>, allowing us to locally interact with the API without having to provision any online resources.&lt;/p></description></item><item><title>Mince Pie Challenge: Authentication with Amazon Cognito and JSON Web Tokens</title><link>https://eddmann.com/posts/mince-pie-challenge-authentication-with-amazon-cognito-and-json-web-tokens/</link><pubDate>Tue, 26 Jun 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-authentication-with-amazon-cognito-and-json-web-tokens/</guid><description>&lt;p>Now that we have set up the Serverless Framework, we can go about investigating how Authentication and Authorisation will be handled within the application.
For this, we will be using &lt;a href="https://aws.amazon.com/cognito/" rel="external noopener" target="_blank">Amazon Cognito&lt;/a>, a fully managed web service which handles the user sign-up, sign-in and management processes.&lt;/p></description></item><item><title>Mince Pie Challenge: Setting up the Serverless Framework with Docker, Webpack and Babel</title><link>https://eddmann.com/posts/mince-pie-challenge-setting-up-the-serverless-framework-with-docker-webpack-and-babel/</link><pubDate>Fri, 15 Jun 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-setting-up-the-serverless-framework-with-docker-webpack-and-babel/</guid><description>&lt;p>Now that we have spent some time working out how the API is going to look, we can move on to building it!
We will start off by configuring the initial API project, setting up a Dockerised &lt;a href="https://serverless.com/" rel="external noopener" target="_blank">Serverless Framework&lt;/a> with &lt;a href="https://webpack.js.org/" rel="external noopener" target="_blank">Webpack&lt;/a> and &lt;a href="https://babeljs.io/" rel="external noopener" target="_blank">Babel&lt;/a> support.&lt;/p></description></item><item><title>Mince Pie Challenge: Building a Serverless RESTful API and React Client</title><link>https://eddmann.com/posts/mince-pie-challenge-building-a-serverless-restful-api-and-react-client/</link><pubDate>Thu, 07 Jun 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/mince-pie-challenge-building-a-serverless-restful-api-and-react-client/</guid><description>&lt;p>Since moving our infrastructure over to the AWS stack, I have been keen to explore how we can take advantage of the numerous services at our disposal, alongside the serverless methodology.
In this blog &lt;a href="https://eddmann.com/archive/tag/mince-pie-challenge-series">series&lt;/a>, I wish to document my experience of building a complete serverless application which harnesses as many of the AWS offerings as possible.
We will explore building both a RESTful API and a React client, all hosted without any servers to maintain!&lt;/p></description></item><item><title>Unlocking the AWS WAF Logs</title><link>https://eddmann.com/posts/unlocking-the-aws-waf-logs/</link><pubDate>Fri, 12 Jan 2018 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/unlocking-the-aws-waf-logs/</guid><description>&lt;p>In this post we discuss our recent move to route all requests through &lt;a href="https://aws.amazon.com/cloudfront/" rel="external noopener" target="_blank">CloudFront&lt;/a>.
This allows us to parse all traffic through the &lt;a href="https://aws.amazon.com/waf/" rel="external noopener" target="_blank">AWS Web Application Firewall&lt;/a> (WAF).
We highlight the reasoning behind this change, and some issues and remedies encountered when trying to garner concrete logs from the WAF instance.&lt;/p></description></item><item><title>Creating a 'Winning' Audio Lambda Service using Serverless, Polly and compiled SOX</title><link>https://eddmann.com/posts/creating-a-winning-audio-lambda-service-using-serverless-polly-and-compiled-sox/</link><pubDate>Mon, 11 Dec 2017 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/creating-a-winning-audio-lambda-service-using-serverless-polly-and-compiled-sox/</guid><description>&lt;p>Following on from my previous post which discussed &lt;a href="https://eddmann.com/posts/memes-as-a-service-using-lambda-serverless-and-imagemagick/">manipulating images&lt;/a>, I would now like to expand upon this and look into how you can interact with audio using Lambda.
To highlight this use-case we will be creating a simple service which, given a name and an optional voice (provided by &lt;a href="https://aws.amazon.com/polly/" rel="external noopener" target="_blank">Polly&lt;/a>), will synthesise the name and include it in a returned &amp;ldquo;And the winner is&amp;hellip;&amp;rdquo; applause MP3 file.
This will demonstrate how to integrate Polly within Lambda, compile and execute native code within Lambda and return a binary MP3 file to the client.&lt;/p></description></item><item><title>'Memes as a Service' using Lambda, Serverless and ImageMagick</title><link>https://eddmann.com/posts/memes-as-a-service-using-lambda-serverless-and-imagemagick/</link><pubDate>Mon, 04 Dec 2017 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/memes-as-a-service-using-lambda-serverless-and-imagemagick/</guid><description>&lt;p>I&amp;rsquo;ve recently become really interested in the concept of Functions as a Service (FaaS) and the &lt;a href="https://serverless.com/" rel="external noopener" target="_blank">Serverless Framework&lt;/a>.
I decided to create a small experimental AWS Lambda function to explore how it could be used to manipulate images.
For this contrived example, I came up with the (silly) idea of &amp;lsquo;Memes as a Service&amp;rsquo; (everything needs to be a service nowadays).&lt;/p></description></item><item><title>Scheduling EC2 Instances using Lambda and CloudWatch Events</title><link>https://eddmann.com/posts/scheduling-ec2-instances-using-lambda-and-cloudwatch-events/</link><pubDate>Fri, 24 Nov 2017 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/scheduling-ec2-instances-using-lambda-and-cloudwatch-events/</guid><description>&lt;p>Over the past couple of months, MyBuilder has been transitioning from primarily a dedicated server stack (with orchestration through &lt;a href="https://puppet.com/" rel="external noopener" target="_blank">Puppet&lt;/a>) to cloud infrastructure by way of &lt;a href="https://aws.amazon.com/" rel="external noopener" target="_blank">Amazon Web Services&lt;/a>.
We have been a proponent of AWS for quite some time, taking advantage of services such as S3 and CloudFront in our current setup.
We are also not unfamiliar with EC2, spreading some of our application requirements onto several instances over the past couple of years.
However, we have not been fully embracing the &amp;lsquo;Cloud nature&amp;rsquo; of the product and are still treating each server as something between a &lt;a href="https://martinfowler.com/bliki/SnowflakeServer.html" rel="external noopener" target="_blank">Snowflake&lt;/a> and a &lt;a href="https://martinfowler.com/bliki/PhoenixServer.html" rel="external noopener" target="_blank">Phoenix&lt;/a>.&lt;/p></description></item></channel></rss>