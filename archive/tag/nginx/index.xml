<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Nginx on Edd Mann</title><link>https://eddmann.com/archive/tag/nginx/</link><description>Recent content in Nginx on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Sat, 05 Apr 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/nginx/index.xml" rel="self" type="application/rss+xml"/><item><title>Self-Signed SSL Certificates with Nginx and Apache</title><link>https://eddmann.com/posts/self-signed-ssl-certificates-with-nginx-and-apache/</link><pubDate>Sat, 05 Apr 2014 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/self-signed-ssl-certificates-with-nginx-and-apache/</guid><description>&lt;p>Since having the opportunity to discuss web application security (&lt;a href="https://threedevsandamaybe.com/web-application-security-part-1/" rel="external noopener" target="_blank">part 1&lt;/a>, &lt;a href="https://threedevsandamaybe.com/web-application-security-part-2/" rel="external noopener" target="_blank">part 2&lt;/a>) recently on the podcast, I thought it was a good time to have a deeper look into SSL/TLS (Transport Layer Security).
There are plenty of good resources online discussing the &lt;a href="http://www.youtube.com/watch?v=iQsKdtjwtYI" rel="external noopener" target="_blank">technical side&lt;/a> of the topic.
However, at a high level, point-to-point encryption and server identification are the two problems it attempts to solve.&lt;/p></description></item><item><title>Processing Apache and Nginx Access Logs</title><link>https://eddmann.com/posts/processing-apache-and-nginx-access-logs/</link><pubDate>Sat, 21 Dec 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/processing-apache-and-nginx-access-logs/</guid><description>&lt;p>Tools such as &lt;a href="http://awstats.sourceforge.net/" rel="external noopener" target="_blank">AWStats&lt;/a> and &lt;a href="http://code.google.com/p/logstalgia/" rel="external noopener" target="_blank">Logstalgia&lt;/a> are great, but sometimes they can be overkill for the problem we are trying to solve.
It turns out that with a couple of simple Unix commands we can gather a lot of useful information from the data stored in the access logs.
Both Apache and Nginx by default use the &lt;a href="http://httpd.apache.org/docs/1.3/logs.html#combined" rel="external noopener" target="_blank">combined&lt;/a> log format, which I will be basing this post&amp;rsquo;s examples on.
Below are two different methods of accessing either an uncompressed single file or multiple compressed files (following the supplied wild-card pattern).&lt;/p></description></item><item><title>Installing Nginx/Apache, MySQL, PHP 5.5 (LAMP) stack on CentOS 6.4</title><link>https://eddmann.com/posts/installing-nginx-apache-mysql-php-5-5-lamp-stack-on-cent-os-6-4/</link><pubDate>Fri, 29 Nov 2013 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/installing-nginx-apache-mysql-php-5-5-lamp-stack-on-cent-os-6-4/</guid><description>&lt;p>With the widespread appeal and flexibility of an &lt;a href="http://en.wikipedia.org/wiki/Virtual_private_server" rel="external noopener" target="_blank">VPS&lt;/a> and &lt;a href="http://www.vagrantup.com/" rel="external noopener" target="_blank">Vagrant&lt;/a>, a shift from mere FTP access to setting up a fresh installation from scratch has taken effect.
Tools like &lt;a href="http://puppetlabs.com/" rel="external noopener" target="_blank">Puppet&lt;/a> and &lt;a href="http://www.opscode.com/chef/" rel="external noopener" target="_blank">Chef&lt;/a> are great for certain use-cases (i.e. large deployments, dev-ops teams), but starting with the terminal is your best friend.
In this post I will take you through the process of setting up a trivial LAMP stack on CentOS 6.4, with the option to use either &lt;a href="http://httpd.apache.org/" rel="external noopener" target="_blank">Apache&lt;/a> or &lt;a href="http://nginx.com/" rel="external noopener" target="_blank">Nginx&lt;/a>.
Both will take advantage of the features PHP-FPM provides you, via FastCGI.&lt;/p></description></item></channel></rss>