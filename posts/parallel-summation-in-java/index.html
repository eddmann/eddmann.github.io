<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Parallel Summation in Java - Edd Mann</title>
<meta name=description content="Learn how to implement parallel summation in Java using threads for enhanced performance and speed optimisation."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Parallel Summation in Java"><meta itemprop=description content="Summation is the common operation of adding a sequence of numbers together, resulting in their total. The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress. For small sequences, a single-threaded implementation will suffice. However, when the size increases, the use of other available CPU cores helps to provide the necessary speed optimisations. As addition is an associative operation, it makes no difference to the end result in which order we process the collection. This behaviour works well for our implementation design."><meta itemprop=datePublished content="2014-03-14T00:00:00+00:00"><meta itemprop=dateModified content="2014-03-14T00:00:00+00:00"><meta itemprop=wordCount content="555"><meta itemprop=keywords content="Java,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/parallel-summation-in-java/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Parallel Summation in Java"><meta property="og:description" content="Summation is the common operation of adding a sequence of numbers together, resulting in their total. The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress. For small sequences, a single-threaded implementation will suffice. However, when the size increases, the use of other available CPU cores helps to provide the necessary speed optimisations. As addition is an associative operation, it makes no difference to the end result in which order we process the collection. This behaviour works well for our implementation design."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-03-14T00:00:00+00:00"><meta property="article:modified_time" content="2014-03-14T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Parallel Summation in Java"><meta name=twitter:description content="Summation is the common operation of adding a sequence of numbers together, resulting in their total. The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress. For small sequences, a single-threaded implementation will suffice. However, when the size increases, the use of other available CPU cores helps to provide the necessary speed optimisations. As addition is an associative operation, it makes no difference to the end result in which order we process the collection. This behaviour works well for our implementation design."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.6b7f2bb661aac83aa99b773fd7544e8e2e4cc6f1117afae5fa2224c1a4618175.css integrity="sha256-a38rtmGqyDqpm3c/11ROji5MxvERevrl+iIkwaRhgXU="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/parallel-summation-in-java/><script>(function(){document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")})()</script><script src=/script.min.c886797fe1c76f3a5cace46b687d1d56b58c9e0df4f37c62bffbcda7eb40fce8.js integrity="sha256-yIZ5f+HHbzpcrORraH0dVrWMng3083xiv/vNp+tA/Og=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:parallel-summation-in-java>Parallel Summation in Java</h1><time datetime=2014-03-14T00:00:00Z class=time>Mar 14, 2014</time></header><main class=u-prose><p>Summation is the common operation of adding a sequence of numbers together, resulting in their total.
The trivial implementation is to iterate over the full collection of numbers, keeping a running total as you progress.
For small sequences, a single-threaded implementation will suffice.
However, when the size increases, the use of other available CPU cores helps to provide the necessary speed optimisations.
As addition is an associative operation, it makes no difference to the end result in which order we process the collection.
This behaviour works well for our implementation design.</p><p>Below is an example implementation which splits the summation of a sequence of numbers into (close to) equal collections.
Each collection is processed in parallel within its own thread.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>Summation</span> <span style=color:#66d9ef>extends</span> Thread {
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> low, high, partial;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#a6e22e>Summation</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> low, <span style=color:#66d9ef>int</span> high)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>arr</span> <span style=color:#f92672>=</span> arr;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>low</span> <span style=color:#f92672>=</span> low;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>this</span>.<span style=color:#a6e22e>high</span> <span style=color:#f92672>=</span> Math.<span style=color:#a6e22e>min</span>(high, arr.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>getPartialSum</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> partial;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>run</span>()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        partial <span style=color:#f92672>=</span> sum(arr, low, high);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> sum(arr, 0, arr.<span style=color:#a6e22e>length</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>sum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> low, <span style=color:#66d9ef>int</span> high)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> low; i <span style=color:#f92672>&lt;</span> high; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            total <span style=color:#f92672>+=</span> arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> total;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parallelSum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> parallelSum(arr, Runtime.<span style=color:#a6e22e>getRuntime</span>().<span style=color:#a6e22e>availableProcessors</span>());
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>int</span> <span style=color:#a6e22e>parallelSum</span>(<span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr, <span style=color:#66d9ef>int</span> threads)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> size <span style=color:#f92672>=</span> (<span style=color:#66d9ef>int</span>) Math.<span style=color:#a6e22e>ceil</span>(arr.<span style=color:#a6e22e>length</span> <span style=color:#f92672>*</span> 1.<span style=color:#a6e22e>0</span> <span style=color:#f92672>/</span> threads);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Summation<span style=color:#f92672>[]</span> sums <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Summation<span style=color:#f92672>[</span>threads<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> threads; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>            sums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Summation(arr, i <span style=color:#f92672>*</span> size, (i <span style=color:#f92672>+</span> 1) <span style=color:#f92672>*</span> size);
</span></span><span style=display:flex><span>            sums<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span>.<span style=color:#a6e22e>start</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>try</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>for</span> (Summation sum : sums) {
</span></span><span style=display:flex><span>                sum.<span style=color:#a6e22e>join</span>();
</span></span><span style=display:flex><span>            }
</span></span><span style=display:flex><span>        } <span style=color:#66d9ef>catch</span> (InterruptedException e) { }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>int</span> total <span style=color:#f92672>=</span> 0;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (Summation sum : sums) {
</span></span><span style=display:flex><span>            total <span style=color:#f92672>+=</span> sum.<span style=color:#a6e22e>getPartialSum</span>();
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> total;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looking at the implementation above, you will notice that I have taken advantage of static functionality to combine both the sum and thread instances required to complete the task.
Calling &lsquo;parallelSum&rsquo; with a single argument (being the specified array), the system is queried on how many available processing cores are present.
We then create &lsquo;Summation&rsquo; instances that are supplied with the low and high range of indexes within the subject array they are required to process.
These are then started and subsequently joined into the main thread for the final round of partial sum addition to complete the process.</p><p>So as to see the benefits of parallelising such an operation, an example benchmark has been provided below.
The implementation is provided in this case with 100,000,000 random integers between 1 and 100, and timed on its performance to run as both a single and parallel operation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#f92672>import</span> java.util.Random;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> <span style=color:#a6e22e>main</span>(String<span style=color:#f92672>[]</span> args)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    Random rand <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> Random();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>int</span><span style=color:#f92672>[]</span> arr <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> <span style=color:#66d9ef>int</span><span style=color:#f92672>[</span>100000000<span style=color:#f92672>]</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i <span style=color:#f92672>=</span> 0; i <span style=color:#f92672>&lt;</span> arr.<span style=color:#a6e22e>length</span>; i<span style=color:#f92672>++</span>) {
</span></span><span style=display:flex><span>        arr<span style=color:#f92672>[</span>i<span style=color:#f92672>]</span> <span style=color:#f92672>=</span> rand.<span style=color:#a6e22e>nextInt</span>(101) <span style=color:#f92672>+</span> 1; <span style=color:#75715e>// 1..100</span>
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>long</span> start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Summation.<span style=color:#a6e22e>sum</span>(arr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Single: &#34;</span> <span style=color:#f92672>+</span> (System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start)); <span style=color:#75715e>// Single: 44</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    start <span style=color:#f92672>=</span> System.<span style=color:#a6e22e>currentTimeMillis</span>();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    Summation.<span style=color:#a6e22e>parallelSum</span>(arr);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    System.<span style=color:#a6e22e>out</span>.<span style=color:#a6e22e>println</span>(<span style=color:#e6db74>&#34;Parallel: &#34;</span> <span style=color:#f92672>+</span> (System.<span style=color:#a6e22e>currentTimeMillis</span>() <span style=color:#f92672>-</span> start)); <span style=color:#75715e>// Parallel: 25</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Looking at the results above, you will see that using the parallelised approach provides us with noticeable speed gains.
An interesting observation I made when running the benchmark was that increasing the number of threads to two did not significantly improve the speed.</p></main><footer class=post__tags><a href=/archive/tag/java>java</a><a href=/archive/tag/algorithms>algorithms</a></footer></article><div class="related-posts u-prose"><h3>Related Posts</h3><ul><li><a href=/posts/implementing-heapsort-in-java-and-c/>Implementing Heapsort in Java and C</a></li><li><a href=/posts/experimenting-with-the-xor-swap-method-in-java/>Experimenting with the XOR Swap Method in Java</a></li><li><a href=/posts/least-significant-digit-lsd-radix-sort-in-java/>Least Significant Digit (LSD) Radix Sort in Java</a></li><li><a href=/posts/shunting-yard-implementation-in-java/>Shunting Yard Implementation in Java</a></li><li><a href=/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/>Decimal to Hexadecimal using Bitwise, Bit Shift Operations in Java</a></li></ul></div><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>