<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Experimenting with the XOR Swap Method in Java - Edd Mann</title>
<meta name=description content="Explore the implementation and theory behind the XOR swap method in Java, a unique technique for swapping variable values without a temporary variable, complete with code examples and detailed explanations."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Experimenting with the XOR Swap Method in Java"><meta itemprop=description content="The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable. Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length bit-strings will work. Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to higher-level programmers. Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes. An example of such an abstraction is the garbage collector found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention."><meta itemprop=datePublished content="2013-12-29T00:00:00+00:00"><meta itemprop=dateModified content="2013-12-29T00:00:00+00:00"><meta itemprop=wordCount content="508"><meta itemprop=keywords content="Java,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Experimenting with the XOR Swap Method in Java"><meta property="og:description" content="The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable. Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length bit-strings will work. Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to higher-level programmers. Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes. An example of such an abstraction is the garbage collector found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2013-12-29T00:00:00+00:00"><meta property="article:modified_time" content="2013-12-29T00:00:00+00:00"><meta property="article:tag" content="Java"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="Experimenting with the XOR Swap Method in Java"><meta name=twitter:description content="The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable. Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length bit-strings will work. Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to higher-level programmers. Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes. An example of such an abstraction is the garbage collector found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention."><meta name=twitter:site content="@edd_mann"><link rel=stylesheet href=/css/style.min.edfc847d0ae5aa99c1aab7f57def3e24393a345c6730bf7976fe9a89a0796d4a.css integrity="sha256-7fyEfQrlqpnBqrf1fe8+JDk6NFxnML95dv6aiaB5bUo="><link rel=preload as=image href=/assets/x.svg crossorigin=anonymous><link rel=preload as=image href=/assets/github.svg crossorigin=anonymous><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/experimenting-with-the-xor-swap-method-in-java/><script>document.documentElement.setAttribute("data-theme",localStorage.getItem("theme")||window.matchMedia("(prefers-color-scheme: dark)").matches&&"dark"||"light")</script><script src=/script.min.7f6917401c23509595a4da9144cfe3c8fde343c0352e6d627aa366129e1bdb48.js integrity="sha256-f2kXQBwjUJWVpNqRRM/jyP3jQ8A1Lm1ieqNmEp4b20g=" defer></script></head><body><header class="site-header l-wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><button class=site-header__mobile-navigation-button type=button title="Toggle mobile site navigation" aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></button><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=l-wrapper><article><header class=l-page-title><h1 class=u-transition-between-pages style=--id:experimenting-with-the-xor-swap-method-in-java>Experimenting with the XOR Swap Method in Java</h1><time datetime=2013-12-29T00:00:00Z class=published-at>Dec 29, 2013</time></header><main class=u-prose><p>The exclusive disjunction (or XOR) swap algorithm is a little trick to swap values of the same data type without the use of a temporary variable.
Typically, low-level data types like integers are used in practice, but in theory any value represented by fixed-length <a href=http://en.wikipedia.org/wiki/Bit_array rel="external noopener" target=_blank>bit-strings</a> will work.
Though it is considered bad practice in most use cases, it does help to highlight implementation details which can seem foreign to <a href=http://en.wikipedia.org/wiki/High-level_programming_language rel="external noopener" target=_blank>higher-level</a> programmers.
Due to the high levels of abstraction implemented to aid the development of complex systems, we sometimes lose the beauty of working with the underlying bits and bytes.
An example of such an abstraction is the <a href=http://javabook.compuware.com/content/memory/how-garbage-collection-works.aspx rel="external noopener" target=_blank>garbage collector</a> found in the JVM, which handles memory management concerns that, in lower-level languages, would require significant attention.</p><h2 id=decimal-to-binary-representation>Decimal to Binary Representation</h2><p>To display each value&rsquo;s binary representation in the experiment, we could simply use the <a href=http://docs.oracle.com/javase/7/docs/api/java/lang/Integer.html#toBinaryString%28int%29 rel="external noopener" target=_blank>Integer.toBinaryString</a> method.
However, as this is a learning exercise, below are two alternative implementations.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>toBin</span>(<span style=color:#66d9ef>int</span> decimal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (decimal <span style=color:#f92672>==</span> 0) <span style=color:#66d9ef>return</span> <span style=color:#e6db74>&#34;0&#34;</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    StringBuilder sb <span style=color:#f92672>=</span> <span style=color:#66d9ef>new</span> StringBuilder();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>while</span> (decimal <span style=color:#f92672>&gt;</span> 0) {
</span></span><span style=display:flex><span>        sb.<span style=color:#a6e22e>append</span>(decimal <span style=color:#f92672>&amp;</span> 1);
</span></span><span style=display:flex><span>        decimal <span style=color:#f92672>&gt;&gt;=</span> 1;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> sb.<span style=color:#a6e22e>reverse</span>().<span style=color:#a6e22e>toString</span>();
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The first example uses a bitwise AND and shift operation to inspect each bit of the integer value.
This implementation handles the use case of being initially supplied with a decimal value of zero.
The resulting value is built using a StringBuilder and reversed before the string instance is created.
This is required as we wish to represent the least significant digit at the rightmost position.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> String <span style=color:#a6e22e>toBin</span>(<span style=color:#66d9ef>int</span> decimal)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> (decimal <span style=color:#f92672>&gt;</span> 0)
</span></span><span style=display:flex><span>        <span style=color:#f92672>?</span> toBin(decimal <span style=color:#f92672>/</span> 2) <span style=color:#f92672>+</span> (decimal <span style=color:#f92672>%</span> 2)
</span></span><span style=display:flex><span>        : <span style=color:#e6db74>&#34;&#34;</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>The second example uses division and modulus to recursively build up a string representation.</p><h2 id=the-algorithm>The Algorithm</h2><p>Directing attention back to the algorithm, no stipulations are placed on the value; however, due to <a href=http://en.wikipedia.org/wiki/Aliasing_%28computing%29 rel="external noopener" target=_blank>aliasing</a> concerns, the two variables must be stored in different (distinct) memory address spaces.
With this knowledge in hand, we can now produce an example of the algorithm.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-java data-lang=java><span style=display:flex><span><span style=color:#66d9ef>int</span> x, y;
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> 1, y <span style=color:#f92672>=</span> 2; <span style=color:#75715e>// x=01, y=10</span>
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> x <span style=color:#f92672>^</span> y;    <span style=color:#75715e>// x=11, y=10</span>
</span></span><span style=display:flex><span>y <span style=color:#f92672>=</span> x <span style=color:#f92672>^</span> y;    <span style=color:#75715e>// x=11, y=01</span>
</span></span><span style=display:flex><span>x <span style=color:#f92672>=</span> x <span style=color:#f92672>^</span> y;    <span style=color:#75715e>// x=10, y=01</span>
</span></span></code></pre></div><p>After initialising the two integers, we combine (XOR) the two values, storing the resulting value back into the first variable.
As the XOR operation is <a href=http://en.wikipedia.org/wiki/Commutative_property rel="external noopener" target=_blank>commutative</a>, we are free to change the operand ordering of any or all three of the statements.
We then move on to XOR the resulting first value and the initial second value, storing the result in the second variable&rsquo;s location.
Using an XOR in this manner effectively cancels out all the information we have gained from the second variable in the initial operation, leaving us with only the first value.
Finally, we XOR the two values yet again, but this time storing the resulting value back into the first variable, which, due to cancellation, leaves us with only the second value.</p><h2 id=resources>Resources</h2><ul><li><a href=http://en.wikipedia.org/wiki/XOR_swap_algorithm rel="external noopener" target=_blank>XOR swap algorithm</a></li><li><a href=http://en.wikipedia.org/wiki/Bit_array rel="external noopener" target=_blank>Bit array</a></li><li><a href=http://javabook.compuware.com/content/memory/how-garbage-collection-works.aspx rel="external noopener" target=_blank>Java Memory Management</a></li></ul></main><footer class=post-footer><ul class="tags tags--large"><li><a href=/archive/tag/java>java</a></li><li><a href=/archive/tag/algorithms>algorithms</a></li></ul><div class=related><h3 class=related__title>Related Posts</h3><ul class=related__posts><li><a href=/posts/least-significant-digit-lsd-radix-sort-in-java/>Least Significant Digit (LSD) Radix Sort in Java</a></li><li><a href=/posts/shunting-yard-implementation-in-java/>Shunting Yard Implementation in Java</a></li><li><a href=/posts/decimal-to-hexadecimal-using-bitwise-bit-shift-operations-in-java/>Decimal to Hexadecimal using Bitwise, Bit Shift Operations in Java</a></li><li><a href=/posts/merge-sort-comparison-in-java-and-scala/>Merge sort comparison in Java and Scala</a></li><li><a href=/posts/implementing-a-queue-in-java-using-arrays-and-linked-lists/>Implementing a Queue in Java using Arrays and Linked Lists</a></li></ul></div></footer></article><div class=scroll-watcher></div></main><footer class="site-footer l-wrapper"><div>&copy; 2025, Edd Mann</div><button class=site-footer__theme-toggle type=button title="Toggle theme" aria-label="Toggle theme"><svg fill="currentcolor" viewBox="0 0 32 32" role="img"><title>Theme toggle icon</title><desc>A circle representing the moon for toggling theme</desc><path d="M16 .5C7.4.5.5 7.4.5 16S7.4 31.5 16 31.5 31.5 24.6 31.5 16 24.6.5 16 .5zm0 28.1V3.4C23 3.4 28.6 9 28.6 16S23 28.6 16 28.6z"/></svg></button></footer></body></html>