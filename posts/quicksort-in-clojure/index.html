<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>QuickSort in Clojure - Edd Mann</title>
<meta name=description content="Discover diverse and efficient implementations of the QuickSort algorithm in Clojure using lazy sequences and functional programming techniques."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="QuickSort in Clojure"><meta itemprop=description content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta itemprop=datePublished content="2016-01-11T00:00:00+00:00"><meta itemprop=dateModified content="2016-01-11T00:00:00+00:00"><meta itemprop=wordCount content="281"><meta itemprop=keywords content="Clojure,Functional-Programming,Algorithms"><meta property="og:url" content="https://eddmann.com/posts/quicksort-in-clojure/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="QuickSort in Clojure"><meta property="og:description" content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-01-11T00:00:00+00:00"><meta property="article:modified_time" content="2016-01-11T00:00:00+00:00"><meta property="article:tag" content="Clojure"><meta property="article:tag" content="Functional-Programming"><meta property="article:tag" content="Algorithms"><meta name=twitter:card content="summary"><meta name=twitter:title content="QuickSort in Clojure"><meta name=twitter:description content="This past weekend I had the opportunity to delve more deeply into Clojure’s core library. I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6c18b9cbfe138a24784e64860eaa9d70076170f03c68d8be3b3f1ae99e51df9f.css integrity="sha256-bBi5y/4TiiR4TmSGDqqdcAdhcPA8aNi+Oz8a6Z5R358="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x3x.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/quicksort-in-clojure/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>QuickSort in Clojure</h1><time class=post__time>Jan 11, 2016</time></header><main class=prose><p>This past weekend I had the opportunity to delve more deeply into Clojure&rsquo;s <a href=https://clojuredocs.org/clojure.core rel="external noopener" target=_blank>core library</a>.
I experimented with some interesting aspects of the library by implementing the QuickSort algorithm in a couple of different ways.</p><h2 id=random-number-generation>Random Number Generation</h2><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>numbers [n]
</span></span><span style=display:flex><span>  (take n (<span style=color:#a6e22e>repeatedly</span> <span style=color:#f92672>#</span>(rand-int <span style=color:#ae81ff>100</span>))))
</span></span></code></pre></div><p>Using the above function we are able to take advantage of lazy sequences to create an infinite list of random integers.
This infinite list is made finite (using <code>take</code>) when supplying the function with the desired number of integers required.</p><h2 id=solution-1>Solution 1</h2><p>The first implementation declaratively describes the QuickSort algorithm.
It uses collection filtering to split the input based on the selected pivot.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (concat (<span style=color:#a6e22e>quick-sort</span> (filter <span style=color:#f92672>#</span>(&lt; % pivot) coll))
</span></span><span style=display:flex><span>            [pivot]
</span></span><span style=display:flex><span>            (<span style=color:#a6e22e>quick-sort</span> (filter <span style=color:#f92672>#</span>(&gt;= % pivot) coll)))))
</span></span></code></pre></div><h2 id=solution-2>Solution 2</h2><p>The second implementation removes the duplication created by the two filtering predicates by specifying a single <code>greater?</code> function.
This function is used for both filtering and subsequently removing (the inverse) from the supplied collection.
We also employ the lazy concatenation function which returns a lazy sequence that is only evaluated when required.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>[greater? <span style=color:#f92672>#</span>(&gt; % pivot)]
</span></span><span style=display:flex><span>      (lazy-cat (<span style=color:#a6e22e>quick-sort</span> (remove greater? coll))
</span></span><span style=display:flex><span>                [pivot]
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>quick-sort</span> (filter greater? coll))))))
</span></span></code></pre></div><h2 id=solution-3>Solution 3</h2><p>The final implementation utilises the <code>group-by</code> function provided by the core library.
This function neatly partitions the collection into two separate lists in an extremely expressive manner.
We are then able to destructure the returned map, assigning the true and false values to more clearly named <code>lesser</code> and <code>greater</code> variables.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-clojure data-lang=clojure><span style=display:flex><span>(<span style=color:#66d9ef>defn </span>quick-sort [[pivot <span style=color:#f92672>&amp;</span> coll]]
</span></span><span style=display:flex><span>  (when pivot
</span></span><span style=display:flex><span>    (<span style=color:#66d9ef>let </span>[{lesser false greater true} (<span style=color:#a6e22e>group-by</span> <span style=color:#f92672>#</span>(&gt; % pivot) coll)]
</span></span><span style=display:flex><span>      (lazy-cat (<span style=color:#a6e22e>quick-sort</span> lesser)
</span></span><span style=display:flex><span>                [pivot]
</span></span><span style=display:flex><span>                (<span style=color:#a6e22e>quick-sort</span> greater)))))
</span></span></code></pre></div></main><footer class=post__tags><a href=/archive/tag/clojure>clojure</a><a href=/archive/tag/functional-programming>functional-programming</a><a href=/archive/tag/algorithms>algorithms</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>