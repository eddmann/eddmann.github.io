<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Flux on Edd Mann</title><link>https://eddmann.com/archive/tag/flux/</link><description>Recent content in Flux on Edd Mann</description><generator>Hugo</generator><language>en-GB</language><lastBuildDate>Wed, 28 Oct 2015 00:00:00 +0000</lastBuildDate><atom:link href="https://eddmann.com/archive/tag/flux/index.xml" rel="self" type="application/rss+xml"/><item><title>Asynchronous Calls within Flux</title><link>https://eddmann.com/posts/asynchronous-calls-within-flux/</link><pubDate>Wed, 28 Oct 2015 00:00:00 +0000</pubDate><guid>https://eddmann.com/posts/asynchronous-calls-within-flux/</guid><description>&lt;p>The Flux architecture abides by a single unidirectional data-flow throughout the entire application.
This provides us with a host of benefits, ranging from easier to reason about code, to clearer testing strategies.
However, one issue we faced in our recently updated interface that tradesmen use to communicate with customers was how to handle asynchronous calls within these constraints.
Throughout this post I wish to guide you through the iterative design decisions made, along with the resulting abstractions and boundaries.&lt;/p></description></item></channel></rss>