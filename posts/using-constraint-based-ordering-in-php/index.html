<!doctype html><html lang=en><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><title>Using Constraint-based Ordering in PHP - Edd Mann</title>
<meta name=description content="Learn how to implement constraint-based ordering in PHP to evenly distribute shortlist fees in a dataset, improving aesthetics and readability."><meta name=author content="Edd Mann"><script async src="https://www.googletagmanager.com/gtag/js?id=G-ZPQ7WHNXH4"></script><script>var dnt,doNotTrack=!1;if(!1&&(dnt=navigator.doNotTrack||window.doNotTrack||navigator.msDoNotTrack,doNotTrack=dnt=="1"||dnt=="yes"),!doNotTrack){window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-ZPQ7WHNXH4")}</script><meta itemprop=name content="Using Constraint-based Ordering in PHP"><meta itemprop=description content="An interesting problem arose last week when we wished to generate a listing of recently completed jobs (along with their shortlist fees). Upon reviewing some earlier attempts, we did not like the aesthetics present when many of a particular shortlist fee were clustered together (i.e. two or more adjacent jobs with the same shortlist fee). What we were instead looking for was to create a constraint-based ordering that, when applied to the recently completed jobs, would give an even distribution of shortlist fees (data-set permitting)."><meta itemprop=datePublished content="2016-11-24T00:00:00+00:00"><meta itemprop=dateModified content="2016-11-24T00:00:00+00:00"><meta itemprop=wordCount content="501"><meta itemprop=keywords content="Php"><meta property="og:url" content="https://eddmann.com/posts/using-constraint-based-ordering-in-php/"><meta property="og:site_name" content="Edd Mann"><meta property="og:title" content="Using Constraint-based Ordering in PHP"><meta property="og:description" content="An interesting problem arose last week when we wished to generate a listing of recently completed jobs (along with their shortlist fees). Upon reviewing some earlier attempts, we did not like the aesthetics present when many of a particular shortlist fee were clustered together (i.e. two or more adjacent jobs with the same shortlist fee). What we were instead looking for was to create a constraint-based ordering that, when applied to the recently completed jobs, would give an even distribution of shortlist fees (data-set permitting)."><meta property="og:locale" content="en_GB"><meta property="og:type" content="article"><meta property="article:section" content="posts"><meta property="article:published_time" content="2016-11-24T00:00:00+00:00"><meta property="article:modified_time" content="2016-11-24T00:00:00+00:00"><meta property="article:tag" content="Php"><meta name=twitter:card content="summary"><meta name=twitter:title content="Using Constraint-based Ordering in PHP"><meta name=twitter:description content="An interesting problem arose last week when we wished to generate a listing of recently completed jobs (along with their shortlist fees). Upon reviewing some earlier attempts, we did not like the aesthetics present when many of a particular shortlist fee were clustered together (i.e. two or more adjacent jobs with the same shortlist fee). What we were instead looking for was to create a constraint-based ordering that, when applied to the recently completed jobs, would give an even distribution of shortlist fees (data-set permitting)."><meta name=twitter:site content="@edd_mann"><link rel="preload stylesheet" as=style href=/css/style.min.6c18b9cbfe138a24784e64860eaa9d70076170f03c68d8be3b3f1ae99e51df9f.css integrity="sha256-bBi5y/4TiiR4TmSGDqqdcAdhcPA8aNi+Oz8a6Z5R358="><link rel=preload as=image href=/assets/x.svg><link rel=preload as=image href=/assets/github.svg><link rel=icon type=image/png sizes=32x32 href=/favicon-32x3x.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://eddmann.com/posts/using-constraint-based-ordering-in-php/></head><body><header class="site-header wrapper"><a href=https://eddmann.com/><h3 class=site-header__title>Edd Mann
<span style=--url:url(/assets/code.svg)>Developer</span></h3></a><div class=site-header__mobile-navigation-button aria-label="Toggle mobile site navigation" aria-expanded=false aria-controls=site-navigation></div><div class=site-header__navigation id=site-navigation><nav aria-label="Primary navigation"><ul class=site-header__primary-navigation><li><a href=/archive>Archive</a></li><li><a href=/projects>Projects</a></li><li><a href=/about>About</a></li></ul></nav><nav aria-label="Social links"><ul class=site-header__social-navigation><li><a class=social-icon style=--url:url(/assets/x.svg) href=https://x.com/edd_mann rel="external noopener" target=_blank>Twitter (X)</a></li><li><a class=social-icon style=--url:url(/assets/github.svg) href=https://github.com/eddmann rel="external noopener" target=_blank>GitHub</a></li></ul></nav></div></header><main class=wrapper><article><header class=page-title><h1>Using Constraint-based Ordering in PHP</h1><time class=post__time>Nov 24, 2016</time></header><main class=prose><p>An interesting problem arose last week when we wished to generate a listing of recently completed jobs (along with their shortlist fees).
Upon reviewing some earlier attempts, we did not like the aesthetics present when many of a particular shortlist fee were clustered together (i.e. two or more adjacent jobs with the same shortlist fee).
What we were instead looking for was to create a constraint-based ordering that, when applied to the recently completed jobs, would give an even distribution of shortlist fees (data-set permitting).</p><h2 id=initial-solution>Initial Solution</h2><p>The first approach I took to achieving this end goal was to apply a low-high ordering pattern.
To make the process easier, I decided that initially sorting the jobs based on shortlist fees would alleviate us from any intensive comparison checks later on.
I was then able to use a single pass through the list to create a result that guaranteed &lsquo;as good of&rsquo; a low-high constraint applied as possible.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>orderFeesByLowHigh</span>(<span style=color:#66d9ef>array</span> $fees)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>($fees);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    $listing <span style=color:#f92672>=</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> ($l <span style=color:#f92672>=</span> <span style=color:#ae81ff>0</span>, $h <span style=color:#f92672>=</span> <span style=color:#a6e22e>count</span>($fees) <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>; $l <span style=color:#f92672>&lt;</span> <span style=color:#a6e22e>count</span>($fees) <span style=color:#f92672>/</span> <span style=color:#ae81ff>2</span>; $l<span style=color:#f92672>++</span>, $h<span style=color:#f92672>--</span>) {
</span></span><span style=display:flex><span>        $listing[] <span style=color:#f92672>=</span> $fees[$l];
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> ($l <span style=color:#f92672>!=</span> $h) $listing[] <span style=color:#f92672>=</span> $fees[$h];
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> $listing;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h2 id=taking-another-approach>Taking Another Approach</h2><p>Upon reflection, however, I did not feel that the resulting list looked &lsquo;random&rsquo; enough.
Over the weekend, I thought that maybe incorporating a middle value would help achieve a better outcome.
I decided to try and implement such an approach in a more functional manner, thinking about the declarative steps required to create the result.
I was able to break down the process into three separate actions, as shown in the example below:</p><p><picture><source type=image/webp srcset=/posts/using-constraint-based-ordering-in-php/idea_hu_4c1fdde900453b93.webp><source type=image/jpeg srcset=/posts/using-constraint-based-ordering-in-php/idea_hu_dccc77ab1bdfec0b.jpg><img src=/posts/using-constraint-based-ordering-in-php/idea_hu_dccc77ab1bdfec0b.jpg alt="Visualisation of a Different Approach to Solving the Problem" loading=lazy></picture></p><p>Unfortunately, PHP does not include the ability to <code>partition</code> or <code>interleave</code> arrays, so I created a couple of simple implementations to aid my solution.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>partition</span>(<span style=color:#66d9ef>array</span> $arr, $total)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> ($total <span style=color:#f92672>&lt;</span> <span style=color:#ae81ff>2</span>) <span style=color:#66d9ef>return</span> [$arr];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    $size <span style=color:#f92672>=</span> <span style=color:#a6e22e>ceil</span>(<span style=color:#a6e22e>count</span>($arr) <span style=color:#f92672>/</span> $total);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>array_merge</span>(
</span></span><span style=display:flex><span>        [<span style=color:#a6e22e>array_slice</span>($arr, <span style=color:#ae81ff>0</span>, $size)],
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>partition</span>(<span style=color:#a6e22e>array_slice</span>($arr, $size), $total <span style=color:#f92672>-</span> <span style=color:#ae81ff>1</span>)
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>interleave</span>(<span style=color:#75715e>/* array */</span> <span style=color:#f92672>...</span>$arrs)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (<span style=color:#66d9ef>empty</span>($arrs)) <span style=color:#66d9ef>return</span> [];
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>array_merge</span>(
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>array_map</span>(<span style=color:#e6db74>&#39;head&#39;</span>, $arrs),
</span></span><span style=display:flex><span>        <span style=color:#a6e22e>interleave</span>(<span style=color:#f92672>...</span><span style=color:#a6e22e>array_filter</span>(<span style=color:#a6e22e>array_map</span>(<span style=color:#e6db74>&#39;tail&#39;</span>, $arrs)))
</span></span><span style=display:flex><span>    );
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>head</span>(<span style=color:#66d9ef>array</span> $arr) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>reset</span>($arr); }
</span></span><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>tail</span>(<span style=color:#66d9ef>array</span> $arr) { <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>array_slice</span>($arr, <span style=color:#ae81ff>1</span>); }
</span></span></code></pre></div><p>With these helper functions now in our toolkit, I was able to easily express the problem we were trying to solve in the following implementation.</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-php data-lang=php><span style=display:flex><span><span style=color:#66d9ef>function</span> <span style=color:#a6e22e>orderFeesByLowMidHigh</span>(<span style=color:#66d9ef>array</span> $fees)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#a6e22e>sort</span>($fees);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> <span style=color:#a6e22e>interleave</span>(<span style=color:#f92672>...</span><span style=color:#a6e22e>partition</span>($fees, <span style=color:#ae81ff>3</span>));
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>Following the sorting step in the previous implementation, we then wish to partition the fees into three separate chunks.
With these chunks, we then interleave the encompassing fees into the resulting listing.
I feel the output generated from this function yielded a more aesthetically pleasing result and did not look as much like a pattern as the previous low-high solution.
This could be due to the combination of not only a middle fee but also where the fee is taken from.
In the imperative low-high solution, we always take the next lowest and highest fees, which can be very disjoint from one another and noticeable to someone browsing the list.</p></main><footer class=post__tags><a href=/archive/tag/php>php</a></footer></article></main><footer class="site-footer wrapper"><div>&copy; 2025, Edd Mann</div></footer><script>(function(){document.querySelector(".site-header__mobile-navigation-button").addEventListener("click",e=>{document.documentElement.classList.toggle("mobile-navigation-open"),e.target.setAttribute("aria-expanded",e.target.getAttribute("aria-expanded")==="false"?"true":"false")});const n=document.querySelector(".site-header");let t=window.pageYOffset,e=!1;window.addEventListener("scroll",()=>{if(e)return;const s=window.pageYOffset;window.requestAnimationFrame(()=>{n.classList.toggle("is-sticky",t>s),t=s,e=!1}),e=!0})})()</script></body></html>