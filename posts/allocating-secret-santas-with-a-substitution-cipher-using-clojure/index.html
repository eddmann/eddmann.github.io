<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Documenting how I went about allocating Secret Santas with a substitution cipher using Clojure">

    <title>Allocating Secret Santas with a Substitution Cipher using Clojure &middot; Edd Mann</title>

    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Sans+Pro:400,700,700italic,400italic">
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="/styles.css">

    <link rel="shortcut icon" href="/favicon.ico">

    <link rel="alternate" href="/rss.xml" title="" type="application/rss+xml">

    <script>
        var _gaq=[['_setAccount','UA-32512081-1'],['_setDomainName','eddmann.com'],['_trackPageview']];
        (function() {
            var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
            ga.src = 'https://ssl.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
        })();
    </script>
</head>

    <body>
        <div class="container content">
            <header class="masthead">
                <h3 class="masthead-title">
                    <a href="/" title="Home">Edd Mann</a>
                    <small><i class="fa fa-code"></i> Developer</small>
                </h3>
                <nav>
                    <a href="https://twitter.com/edd_mann"><i class="fa fa-twitter"></i></a>
                    <a href="https://github.com/eddmann"><i class="fa fa-github"></i></a>
                    <a href="mailto:the@eddmann.com"><i class="fa fa-envelope"></i></a>
                </nav>
                <div class="cf"></div>
            </header>

            <main>
                <article class="post">
    <h1 class="post-title">Allocating Secret Santas with a Substitution Cipher using Clojure</h1>
    <time datetime="2019-02-09T00:00:00+00:00" class="post-date">09 Feb 2019</time>
    <p>Over Christmas I found myself delving back into a bit of Clojure, one such problem I stumbled upon solving was allocating <a href="https://en.wikipedia.org/wiki/Secret_Santa">Secret Santas</a>.
In this post I will discuss how I went about grouping a given list of names based on certain criteria, and then correctly pairing up each person.
From here, I will then highlight how I expanded upon the solution to allow these allocations to be distributed, hidden from prying eyes with a simple <a href="https://en.wikipedia.org/wiki/ROT13">ROT13</a> substitution cipher.
</p>

<h3 id="allocating-secret-santas">Allocating Secret Santas</h3>

<p>The first problem that I had to tackle was loading in a given text file which contained all the given participants and their gender, in CSV form.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>james,m
robert,m
david,m
michael,m
mary,f
sally,f
jane,f,
anne,f
</code></pre></div></div>

<p>The solution I wanted to develop catered for the use-case that certain criteria had to be met to make participants eligible to pair with each other.
In this case the invariant was that participants could only buy gifts for the same gender.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure.string</span><span class="w"> </span><span class="no">:only</span><span class="w"> </span><span class="p">[</span><span class="n">split</span><span class="w"> </span><span class="n">split-lines</span><span class="p">]])</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">participants</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">split</span><span class="w"> </span><span class="n">%</span><span class="w"> </span><span class="o">#</span><span class="s">","</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">split-lines</span><span class="w"> </span><span class="p">(</span><span class="nb">slurp</span><span class="w"> </span><span class="n">file</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">group</span><span class="w"> </span><span class="p">[</span><span class="n">participants</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">partition-by</span><span class="w"> </span><span class="nb">second</span><span class="w"> </span><span class="n">participants</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>To achieve this I first <a href="https://clojuredocs.org/clojure.core/slurp"><code class="language-plaintext highlighter-rouge">slurped</code></a> in the file contents, treating each given line as a new participant.
I then went about breaking each entry into their name and gender.
This in-turn then allowed me to group the given list based on gender (the <a href="https://clojuredocs.org/clojure.core/second"><code class="language-plaintext highlighter-rouge">second</code></a> and finally return only the grouped participant names.</p>

<p>Now that we had the grouped names we could begin pairing up each participant.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="p">[</span><span class="n">buyers</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">receivers</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">vector</span><span class="w"> </span><span class="n">buyers</span><span class="w"> </span><span class="p">(</span><span class="nf">shuffle</span><span class="w"> </span><span class="n">buyers</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="nb">every?</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="nb">apply</span><span class="w"> </span><span class="n">distinct?</span><span class="p">)</span><span class="w"> </span><span class="n">receivers</span><span class="p">)</span><span class="w">
      </span><span class="n">receivers</span><span class="w">
      </span><span class="p">(</span><span class="nf">recur</span><span class="w"> </span><span class="n">buyers</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>I solved this with a recursive approach which simply zipped the buyers with another randomly shuffled buyer.
In the event that a buyer had been paired with themselves, the action would be repeated.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">secret-santa</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">mapcat</span><span class="w"> </span><span class="n">allocate</span><span class="w"> </span><span class="p">(</span><span class="nf">group</span><span class="w"> </span><span class="p">(</span><span class="nf">participants</span><span class="w"> </span><span class="n">file</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>Once complete I was able to compose these building blocks together.
As participants were allocated within groups I used <a href="https://clojuredocs.org/clojure.core/mapcat"><code class="language-plaintext highlighter-rouge">mapcat</code></a> to ensure that the result was a flat listing of all the pairings.</p>

<h3 id="hiding-the-pairings-using-a-substitution-cipher">Hiding the Pairings using a Substitution Cipher</h3>

<p>Now that I could pair up a given list of grouped participants, I then thought about how this could be easily distributed via a print-out without anyone else knowing each others picks.
I decided that a simple <a href="https://en.wikipedia.org/wiki/Substitution_cipher">substitution cipher</a> such as ROT13 would do the trick.
I felt it would provide just enough friction to make it hard to work out based on a quick gaze, for example.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="o">^</span><span class="no">:private</span><span class="w"> </span><span class="n">lower-case</span><span class="w">
  </span><span class="p">(</span><span class="nb">seq</span><span class="w"> </span><span class="s">"abcdefghijklmnopqrstuvwxyz"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">rot13</span><span class="w"> </span><span class="p">[</span><span class="n">text</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">cipher</span><span class="w"> </span><span class="p">(</span><span class="nf">-&gt;&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">cycle</span><span class="w"> </span><span class="n">lower-case</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">drop</span><span class="w"> </span><span class="mi">13</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">26</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">zipmap</span><span class="w"> </span><span class="n">lower-case</span><span class="p">))]</span><span class="w">
    </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">replace</span><span class="w"> </span><span class="n">cipher</span><span class="w"> </span><span class="n">text</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<p>To achieve this I first created a simple ROT13 implementation which catered for lower-case alphabet substitutions.
This lead me to think that although the value would be a cipher, the length did not change and based on the provided names this could possibly disclosure a pairing.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">rand-str</span><span class="w"> </span><span class="p">[</span><span class="n">length</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="nf">repeatedly</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">rand-nth</span><span class="w"> </span><span class="n">lower-case</span><span class="p">)))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn-</span><span class="w"> </span><span class="n">padded-rot13</span><span class="w"> </span><span class="p">[</span><span class="n">length</span><span class="w"> </span><span class="n">text</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">padding</span><span class="w"> </span><span class="p">(</span><span class="nb">/</span><span class="w"> </span><span class="p">(</span><span class="nb">-</span><span class="w"> </span><span class="n">length</span><span class="w"> </span><span class="p">(</span><span class="nb">count</span><span class="w"> </span><span class="n">text</span><span class="p">))</span><span class="w"> </span><span class="mi">2</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">rand-str</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/ceil</span><span class="w"> </span><span class="n">padding</span><span class="p">))</span><span class="w">
         </span><span class="p">(</span><span class="nf">rot13</span><span class="w"> </span><span class="n">text</span><span class="p">)</span><span class="w">
         </span><span class="p">(</span><span class="nf">rand-str</span><span class="w"> </span><span class="p">(</span><span class="nf">Math/floor</span><span class="w"> </span><span class="n">padding</span><span class="p">)))))</span><span class="w">
</span></code></pre></div></div>

<p>To resolve this issue I decided to pad each given name with equal amounts of random alphabet values based on the maximum participants name length.
This padding was applied to both the beginning and end of the cipher, enclosing the real name in the middle.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">secret-santa-cipher</span><span class="w"> </span><span class="p">[</span><span class="n">file</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">santas</span><span class="w"> </span><span class="p">(</span><span class="nf">secret-santa</span><span class="w"> </span><span class="n">file</span><span class="p">)</span><span class="w">
        </span><span class="n">max-name</span><span class="w"> </span><span class="p">(</span><span class="nb">apply</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">count</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">first</span><span class="w"> </span><span class="n">santas</span><span class="p">)))</span><span class="w">
        </span><span class="n">cipher</span><span class="w"> </span><span class="p">(</span><span class="nb">partial</span><span class="w"> </span><span class="n">padded-rot13</span><span class="w"> </span><span class="n">max-name</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[[</span><span class="n">buyer</span><span class="w"> </span><span class="n">receiver</span><span class="p">]]</span><span class="w"> </span><span class="p">[</span><span class="n">buyer</span><span class="w"> </span><span class="p">(</span><span class="nf">cipher</span><span class="w"> </span><span class="n">receiver</span><span class="p">)])</span><span class="w"> </span><span class="n">santas</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>Finally, I was able to decorate the <code class="language-plaintext highlighter-rouge">secret-santa</code> function with the ability to return cipher text.
This ensured that all paired up receivers were hidden and required a little work to uncover.</p>

<p>I envision being able to use the solution this coming December, printing and cutting out each of the pairings to distribute to participants.</p>

</article>

            </main>

            <footer class="footer">
                <img src="https://www.gravatar.com/avatar/c5c2978bb14d16460f73399c394b6acd?s=160">
                <ul>
                    <li>Developer at <a href="http://www.mybuilder.com/">MyBuilder</a></li>
                    <li><a href="http://threedevsandamaybe.com/">Three Devs and a Maybe</a> podcast co-host</li>
                    <li>All ramblings can be found in the <a href="/archive/">Archive</a></li>
                </ul>
                <div class="cf"></div>
            </footer>
        </div>
    </body>
</html>
